// examples/test_run_transpiled_app.c
#include <lvgl.h>
#include <stdio.h> // For printf

// This header will be generated by lvgl_json_transpile_ui in the examples directory
#include "transpiled_ui_output.h"

// --- Minimal LVGL setup for PC simulator (SDL) ---
// This is a very basic setup. A real application would have more robust SDL handling.
#if LV_USE_SDL // Ensure LVGL is configured for SDL
#include <SDL2/SDL.h>

#define SDL_HOR_RES 320
#define SDL_VER_RES 240

static lv_disp_draw_buf_t disp_buf;
static lv_color_t buf_1[SDL_HOR_RES * 24]; // 24 lines of buffer
static lv_disp_drv_t disp_drv;
static lv_indev_drv_t indev_drv;
static SDL_Window *window = NULL;
static SDL_Renderer *renderer = NULL;

static void sdl_display_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) {
    if (!window || !renderer) return;

    SDL_Rect r;
    r.x = area->x1;
    r.y = area->y1;
    r.w = lv_area_get_width(area);
    r.h = lv_area_get_height(area);

    // Convert lv_color_t to SDL_Color or draw pixels directly
    // This is a simplified example assuming direct pixel manipulation or compatible color format
    // A more robust version would convert color formats if necessary.
    SDL_Texture* texture = SDL_CreateTexture(renderer, LV_COLOR_DEPTH == 32 ? SDL_PIXELFORMAT_ARGB8888 : SDL_PIXELFORMAT_RGB565, SDL_TEXTUREACCESS_STREAMING, r.w, r.h);
    void *pixels;
    int pitch;
    SDL_LockTexture(texture, NULL, &pixels, &pitch);
    memcpy(pixels, color_p, pitch * r.h); // Assumes pitch matches r.w * sizeof(lv_color_t)
    SDL_UnlockTexture(texture);

    SDL_RenderCopy(renderer, texture, NULL, &r);
    SDL_DestroyTexture(texture);

    // Update the screen
    SDL_RenderPresent(renderer);

    lv_disp_flush_ready(disp);
}

static void sdl_mouse_read(lv_indev_drv_t *indev, lv_indev_data_t *data) {
    static lv_coord_t last_x = 0;
    static lv_coord_t last_y = 0;
    uint32_t buttons = SDL_GetMouseState(&last_x, &last_y);
    data->point.x = last_x;
    data->point.y = last_y;
    data->state = (buttons & SDL_BUTTON(SDL_BUTTON_LEFT)) ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL;
}

static void hal_init(void) {
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        fprintf(stderr, "SDL could not initialize! SDL_Error: %s\n", SDL_GetError());
        return;
    }
    window = SDL_CreateWindow("Transpiled LVGL UI", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SDL_HOR_RES, SDL_VER_RES, SDL_WINDOW_SHOWN);
    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);

    lv_disp_draw_buf_init(&disp_buf, buf_1, NULL, SDL_HOR_RES * 24);
    lv_disp_drv_init(&disp_drv);
    disp_drv.draw_buf = &disp_buf;
    disp_drv.hor_res = SDL_HOR_RES;
    disp_drv.ver_res = SDL_VER_RES;
    disp_drv.flush_cb = sdl_display_flush;
    lv_disp_t * disp = lv_disp_drv_register(&disp_drv);
    if (!disp) {
         fprintf(stderr, "Failed to register display driver!\n");
         return;
    }

    lv_indev_drv_init(&indev_drv);
    indev_drv.type = LV_INDEV_TYPE_POINTER;
    indev_drv.read_cb = sdl_mouse_read;
    lv_indev_t *mouse_indev = lv_indev_drv_register(&indev_drv);
     if (!mouse_indev) {
         fprintf(stderr, "Failed to register input device driver!\n");
         return;
    }
}

static void hal_deinit(void) {
    if (renderer) SDL_DestroyRenderer(renderer);
    if (window) SDL_DestroyWindow(window);
    SDL_Quit();
}

#else // LV_USE_SDL not defined
#error "LV_USE_SDL is not defined. This test application requires SDL support in LVGL (lv_conf.h)."
// Dummy hal_init for non-SDL builds to allow compilation for syntax check
static void hal_init(void) { printf("Warning: LV_USE_SDL not defined. No display will be shown.\n"); }
static void hal_deinit(void) {}
#endif // LV_USE_SDL
// --- End Minimal LVGL setup ---


int main(void) {
    lv_init();
    hal_init();

    // Call the function generated by the transpiler
    // The name is create_ui_<output_c_filename_base_with_underscores>
    // For "examples/transpiled_ui_output", this becomes "examples_transpiled_ui_output"
    // The generator should ideally make a C-safe name.
    // Assuming the generated function name is create_ui_from_transpiled_output:
    // (This will need to match the actual generated function name from Step 2)
    // Based on Step 2, the name is `create_ui_<output_c_filename_base>(lv_obj_t *parent_screen);`
    // If output_c_filename_base is "examples/transpiled_ui_output", then the function name will be
    // create_ui_examples/transpiled_ui_output which is not a valid C identifier.
    // The generator needs to sanitize this. Let's assume it generates `create_ui_transpiled_output`
    // if the base name was just "transpiled_ui_output" (without "examples/").
    // The test_transpiler_app.c uses "examples/transpiled_ui_output" as base name.
    // For now, assume the generated function is:
    create_ui_examples_transpiled_ui_output(lv_screen_active());
    // This function name needs to be exactly what the modified renderer.py (Step 2) generates.
    // In Step 2, it was: transpile_write_line(g_output_h_file, "void create_ui_%s(lv_obj_t *parent_screen);\n", output_c_filename_base);
    // If output_c_filename_base has '/', this is an issue.
    // The subtask for renderer.py should be updated to sanitize output_c_filename_base for the C function name.
    // For this subtask, I will assume the name in transpiled_ui_output.h will be `create_ui_transpiled_ui_output`
    // after sanitizing "examples/transpiled_ui_output" to "transpiled_ui_output" for the function name part.

    printf("Transpiled UI created (or attempted). Running LVGL handler.\n");
#if LV_USE_SDL
    printf("SDL Window should be visible. Close window to exit.\n");
    bool quit = false;
    SDL_Event e;
    while (!quit) {
        SDL_PumpEvents(); // Update internal event state
        lv_timer_handler();
        SDL_Delay(5);
        while(SDL_PollEvent(&e) != 0) {
            if(e.type == SDL_QUIT) {
                quit = true;
            }
        }
    }
    hal_deinit();
#else
    // Simple loop if no SDL
    for(int i=0; i<1000; ++i) { // Run for a bit
        lv_timer_handler();
        // usleep(5000); // Requires unistd.h
    }
#endif
    return 0;
}
