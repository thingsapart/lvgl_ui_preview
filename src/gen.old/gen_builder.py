# gen_ui_builder.py

import json
import argparse
import os
import re
from collections import defaultdict

# Import helpers from gen_wrapper (or duplicate them)
# Assuming gen_wrapper.py is in the same directory or Python path
try:
    from gen_wrapper import (
        sanitize_name, matches_prefix, get_base_type_name, get_type_details,
        find_typedef_for_base, is_opaque, get_c_type_name, get_function_type,
        DEFAULT_OPAQUE_TYPE_PREFIXES, CONSTRUCTOR_NAME_PATTERNS,
        INIT_FUNC_NAME_PATTERNS, ALWAYS_CONCRETE_TYPES, split_c_type_name
    )
except ImportError:
    print("Error: Could not import helper functions from gen_wrapper.py.")
    print("Make sure gen_wrapper.py is in the same directory or accessible via PYTHONPATH.")
    exit(1)

# --- Configuration specific to UI Builder ---
UI_BUILDER_OUTPUT_PREFIX = "ui_builder"
UI_BUILDER_HEADER_GUARD = "UI_BUILDER_H"

# --- UI Builder Header Generation ---
def generate_builder_header(api_data, config):
    h_content = []
    h_content.append(f"// Generated by gen_ui_builder.py from API definition. DO NOT EDIT.")
    h_content.append(f"#ifndef {UI_BUILDER_HEADER_GUARD}")
    h_content.append(f"#define {UI_BUILDER_HEADER_GUARD}")
    h_content.append("\n#ifdef __cplusplus")
    h_content.append('extern "C" {')
    h_content.append("#endif\n")

    h_content.append("#include <stdbool.h>")
    # Include the *real* LVGL header
    h_content.append("#include \"lvgl.h\" // Assuming lvgl.h is in the include path")
    h_content.append("")

    h_content.append("// --- Public Functions ---")
    h_content.append("/**")
    h_content.append(" * @brief Registers an external resource (like a font or image) known to the application.")
    h_content.append(" * This must be called *before* build_ui_from_json for every external resource")
    h_content.append(" * referenced by ID in the JSON simulation file.")
    h_content.append(" *")
    h_content.append(" * @param id The string ID used in the JSON (e.g., \"lv_font_montserrat_14\").")
    h_content.append(" * @param ptr The actual C pointer to the resource (e.g., &lv_font_montserrat_14).")
    h_content.append(" * @return true if registration was successful, false if the ID was already registered.")
    h_content.append(" */")
    h_content.append(f"bool {UI_BUILDER_OUTPUT_PREFIX}_register_external_resource(const char *id, const void *ptr);")
    h_content.append("")
    h_content.append("/**")
    h_content.append(" * @brief Clears all registered external resources.")
    h_content.append(" */")
    h_content.append(f"void {UI_BUILDER_OUTPUT_PREFIX}_clear_external_resources(void);")
    h_content.append("")
    h_content.append("/**")
    h_content.append(" * @brief Builds or rebuilds an LVGL UI based on a JSON string definition.")
    h_content.append(" * WARNING: This function will delete all children of the target parent before rebuilding.")
    h_content.append(" *")
    h_content.append(" * @param json_string A C string containing the JSON data (typically from emul_lvgl_export).")
    h_content.append(" * @param target_parent The LVGL object to build the UI onto. All existing children will be deleted.")
    h_content.append(" * @return true on successful build, false on parsing or build errors.")
    h_content.append(" */")
    h_content.append(f"bool {UI_BUILDER_OUTPUT_PREFIX}_build_ui(const char *json_string, lv_obj_t *target_parent);")
    h_content.append("")

    h_content.append("\n#ifdef __cplusplus")
    h_content.append("}")
    h_content.append("#endif\n")
    h_content.append(f"#endif // {UI_BUILDER_HEADER_GUARD}")
    return "\n".join(h_content)


# --- UI Builder Source Generation ---
def generate_builder_source(api_data, config):
    c_content = []
    c_content.append(f"// Generated by gen_ui_builder.py from API definition. DO NOT EDIT.")
    c_content.append(f"#include \"{UI_BUILDER_OUTPUT_PREFIX}.h\"")
    c_content.append("#include <stdio.h>")
    c_content.append("#include <stdlib.h>")
    c_content.append("#include <string.h>")
    c_content.append("#include <assert.h>")
    c_content.append("#include \"lvgl.h\" // Include real LVGL")
    c_content.append("#include \"cjson/cJSON.h\" // Include cJSON")
    c_content.append("#include \"uthash.h\" // Include uthash")
    c_content.append("")

    # --- Registries ---
    c_content.append("// Registry for mapping JSON IDs to actual LVGL pointers")
    c_content.append("typedef struct {")
    c_content.append("    const char *id_key;  // Key: ID string from JSON")
    c_content.append("    void *lvgl_ptr;    // Value: Actual LVGL pointer (lv_obj_t*, lv_style_t*, etc.)")
    c_content.append("    UT_hash_handle hh;")
    c_content.append("} id_to_ptr_entry_t;")
    c_content.append("static id_to_ptr_entry_t *g_id_to_ptr_registry = NULL;")
    c_content.append("")
    c_content.append("// Registry for external resources provided by the user")
    c_content.append("typedef struct {")
    c_content.append("    const char *id_key;  // Key: ID string specified by user")
    c_content.append("    const void *resource_ptr; // Value: Actual pointer provided by user")
    c_content.append("    UT_hash_handle hh;")
    c_content.append("} external_resource_entry_t;")
    c_content.append("static external_resource_entry_t *g_external_resource_registry = NULL;")
    c_content.append("")

    # --- Helper Functions ---
    c_content.append("// Find LVGL pointer by ID")
    c_content.append("static void* find_lvgl_ptr_by_id(const char *id) {")
    c_content.append("    if (!id) return NULL;")
    c_content.append("    id_to_ptr_entry_t *entry;")
    c_content.append("    HASH_FIND_STR(g_id_to_ptr_registry, id, entry);")
    c_content.append("    return entry ? entry->lvgl_ptr : NULL;")
    c_content.append("}")
    c_content.append("")
    c_content.append("// Add mapping from ID to LVGL pointer")
    c_content.append("static bool add_lvgl_ptr_mapping(const char *id, void *ptr) {")
    c_content.append("    if (!id || !ptr) return false;")
    c_content.append("    id_to_ptr_entry_t *entry;")
    c_content.append("    HASH_FIND_STR(g_id_to_ptr_registry, id, entry);")
    c_content.append("    if (entry) {")
    c_content.append("        fprintf(stderr, \"Builder Error: ID '%s' already mapped to pointer %p. Cannot remap to %p.\\n\", id, entry->lvgl_ptr, ptr);")
    c_content.append("        return false; // ID collision")
    c_content.append("    }")
    c_content.append("    entry = (id_to_ptr_entry_t*)malloc(sizeof(id_to_ptr_entry_t));")
    c_content.append("    if (!entry) { perror(\"malloc failed for id_to_ptr_entry\"); return false; }")
    c_content.append("    entry->id_key = strdup(id); // Store a copy of the ID")
    c_content.append("    entry->lvgl_ptr = ptr;")
    c_content.append("    if (!entry->id_key) { perror(\"strdup failed for id_key\"); free(entry); return false; }")
    c_content.append("    HASH_ADD_KEYPTR(hh, g_id_to_ptr_registry, entry->id_key, strlen(entry->id_key), entry);")
    c_content.append("    return true;")
    c_content.append("}")
    c_content.append("")
    c_content.append("// Clear the ID -> LVGL pointer registry")
    c_content.append("static void clear_id_to_ptr_registry(void) {")
    c_content.append("    id_to_ptr_entry_t *current_entry, *tmp;")
    c_content.append("    HASH_ITER(hh, g_id_to_ptr_registry, current_entry, tmp) {")
    c_content.append("        HASH_DEL(g_id_to_ptr_registry, current_entry);")
    c_content.append("        free((void*)current_entry->id_key); // Free the strdup'd ID")
    c_content.append("        // NOTE: We DO NOT free current_entry->lvgl_ptr here.")
    c_content.append("        // The actual LVGL objects/styles are managed by LVGL itself.")
    c_content.append("        free(current_entry);")
    c_content.append("    }")
    c_content.append("    g_id_to_ptr_registry = NULL;")
    c_content.append("}")
    c_content.append("")

    # --- External Resource Registry Functions ---
    c_content.append("// --- External Resource Handling ---")
    c_content.append(f"bool {UI_BUILDER_OUTPUT_PREFIX}_register_external_resource(const char *id, const void *ptr) {{")
    c_content.append("    if (!id || !ptr) {")
    c_content.append("        fprintf(stderr, \"Builder Error: Invalid arguments to register_external_resource (id=%s, ptr=%p)\\n\", id ? id : \"NULL\", ptr);")
    c_content.append("        return false;")
    c_content.append("    }")
    c_content.append("    external_resource_entry_t *entry;")
    c_content.append("    HASH_FIND_STR(g_external_resource_registry, id, entry);")
    c_content.append("    if (entry) {")
    c_content.append("        if (entry->resource_ptr == ptr) return true; // Already registered with same pointer")
    c_content.append("        fprintf(stderr, \"Builder Error: External resource ID '%s' already registered with pointer %p. Cannot re-register with %p.\\n\", id, entry->resource_ptr, ptr);")
    c_content.append("        return false;")
    c_content.append("    }")
    c_content.append("    entry = (external_resource_entry_t*)malloc(sizeof(external_resource_entry_t));")
    c_content.append("    if (!entry) { perror(\"malloc failed for external_resource_entry\"); return false; }")
    c_content.append("    entry->id_key = strdup(id);")
    c_content.append("    entry->resource_ptr = ptr;")
    c_content.append("    if (!entry->id_key) { perror(\"strdup failed for external id_key\"); free(entry); return false; }")
    c_content.append("    HASH_ADD_KEYPTR(hh, g_external_resource_registry, entry->id_key, strlen(entry->id_key), entry);")
    c_content.append("    return true;")
    c_content.append("}")
    c_content.append("")
    c_content.append(f"void {UI_BUILDER_OUTPUT_PREFIX}_clear_external_resources(void) {{")
    c_content.append("    external_resource_entry_t *current_entry, *tmp;")
    c_content.append("    HASH_ITER(hh, g_external_resource_registry, current_entry, tmp) {")
    c_content.append("        HASH_DEL(g_external_resource_registry, current_entry);")
    c_content.append("        free((void*)current_entry->id_key);")
    c_content.append("        free(current_entry);")
    c_content.append("    }")
    c_content.append("    g_external_resource_registry = NULL;")
    c_content.append("}")
    c_content.append("")
    c_content.append("// Find external resource pointer by ID")
    c_content.append("static const void* find_external_resource_ptr(const char *id) {")
    c_content.append("    if (!id) return NULL;")
    c_content.append("    external_resource_entry_t *entry;")
    c_content.append("    HASH_FIND_STR(g_external_resource_registry, id, entry);")
    c_content.append("    if (!entry) {")
    c_content.append("        fprintf(stderr, \"Builder Error: External resource ID '%s' not registered. Call %s_register_external_resource first.\\n\", id, UI_BUILDER_OUTPUT_PREFIX);")
    c_content.append("    }")
    c_content.append("    return entry ? entry->resource_ptr : NULL;")
    c_content.append("}")
    c_content.append("")


    # --- Un-marshaling ---
    c_content.append("// --- Un-marshaling Functions ---")
    c_content.append("// Forward declarations")
    c_content.append("static bool unmarshal_value(cJSON *json_value, const char *expected_c_type_str, void *target_c_ptr, const lv_obj_t *target_obj_for_setter);")
    # Concrete struct unmarshalers
    for struct in config['filtered_structures']:
        struct_name = struct['name']
        if not is_opaque({"name": struct_name}, api_data, config):
             typedef_name = find_typedef_for_base(struct_name, api_data, config)
             c_struct_name = typedef_name if typedef_name else f"struct {struct_name}"
             func_name_suffix = sanitize_name(typedef_name if typedef_name else struct_name)
             # Unmarshaler takes a cJSON object and populates a pre-allocated C struct
             c_content.append(f"static bool unmarshal_struct_{func_name_suffix}(cJSON *json_obj, {c_struct_name} *target_struct);")
    # Add unions if needed
    c_content.append("")

    # Enum unmarshaler (string to value)
    c_content.append("// Unmarshal enum from string")
    c_content.append("static bool unmarshal_enum(cJSON *json_value, const char *enum_type_name, void *target_c_ptr) {")
    c_content.append("    if (!cJSON_IsString(json_value)) return false;")
    c_content.append("    const char *enum_str = json_value->valuestring;")
    c_content.append("    bool found = false;")
    # Generate lookup table for enums
    for enum in config['filtered_enums']:
        enum_internal_name = enum['name']
        typedef_name = find_typedef_for_base(enum_internal_name, api_data, config)
        c_enum_name = typedef_name if typedef_name else enum_internal_name
        c_content.append(f"    if (strcmp(enum_type_name, \"{c_enum_name}\") == 0) {{")
        for member in enum.get("members", []):
            c_content.append(f"        if (strcmp(enum_str, \"{member['name']}\") == 0) {{")
            c_content.append(f"            *({c_enum_name}*)target_c_ptr = {member['name']};")
            c_content.append(f"            found = true;")
            c_content.append(f"        }} else") # Chain else ifs
        c_content.append(f"        {{")
        c_content.append(f"           // Handle potential _VALUE(int) format from wrapper fallback")
        c_content.append(f"           int int_val;")
        c_content.append(f"           char expected_prefix[64];")
        c_content.append(f"           snprintf(expected_prefix, sizeof(expected_prefix), \"{c_enum_name}_VALUE(%%d)\");")
        c_content.append(f"           if (sscanf(enum_str, expected_prefix, &int_val) == 1) {{")
        c_content.append(f"               *({c_enum_name}*)target_c_ptr = ({c_enum_name})int_val;")
        c_content.append(f"               found = true;")
        c_content.append(f"           }}")
        c_content.append(f"        }}")
        c_content.append(f"        if (found) return true;") # Return early if found in this type
        c_content.append(f"    }}")
    c_content.append("    fprintf(stderr, \"Builder Error: Unknown enum value '%s' for type '%s'\\n\", enum_str, enum_type_name);")
    c_content.append("    return false;")
    c_content.append("}")
    c_content.append("")

    # Concrete struct unmarshaler implementations
    for struct in config['filtered_structures']:
        struct_name = struct['name']
        if not is_opaque({"name": struct_name}, api_data, config):
             typedef_name = find_typedef_for_base(struct_name, api_data, config)
             c_struct_name = typedef_name if typedef_name else f"struct {struct_name}"
             func_name_suffix = sanitize_name(typedef_name if typedef_name else struct_name)
             func_name = f"unmarshal_struct_{func_name_suffix}"

             c_content.append(f"// Unmarshal struct {c_struct_name} from JSON object")
             c_content.append(f"static bool {func_name}(cJSON *json_obj, {c_struct_name} *target_struct) {{")
             c_content.append("    if (!cJSON_IsObject(json_obj) || !target_struct) return false;")
             # Optional: Check _struct_type hint?
             # cJSON *type_hint = cJSON_GetObjectItemCaseSensitive(json_obj, "_struct_type");
             # if (!type_hint || !cJSON_IsString(type_hint) || strcmp(type_hint->valuestring, struct_name) != 0) {
             #     fprintf(stderr, "Type hint mismatch for struct %s\\n", struct_name); return false;
             # }

             fields = struct.get("fields", [])
             if not fields:
                c_content.append("    // No fields defined in JSON for this struct.")
                c_content.append("    return true;") # Technically successful if no fields
             else:
                c_content.append("    bool success = true;") # Track overall success
                for field in fields:
                    field_name_orig = field.get("name")
                    if not field_name_orig: continue
                    field_name_c = sanitize_name(field_name_orig)
                    field_type_info = field["type"]
                    field_c_type_str = get_c_type_name(field_type_info, api_data, config, use_opaque_typedef=True)

                    c_content.append(f"    cJSON *field_json = cJSON_GetObjectItemCaseSensitive(json_obj, \"{field_name_orig}\");")
                    c_content.append(f"    if (field_json) {{")
                    # Recursively call unmarshal_value for the field
                    c_content.append(f"        if (!unmarshal_value(field_json, \"{field_c_type_str}\", &target_struct->{field_name_c}, NULL)) {{") # Pass NULL for target_obj here
                    c_content.append(f"            fprintf(stderr, \"Builder Error: Failed to unmarshal field '{field_name_orig}' in struct {struct_name}\\n\");")
                    c_content.append(f"            success = false;") # Mark failure but continue trying other fields
                    c_content.append(f"        }}")
                    c_content.append(f"    }} else {{")
                    # Field missing in JSON - is this an error? Maybe just warn.
                    c_content.append(f"        // fprintf(stderr, \"Builder Warning: Field '{field_name_orig}' missing in JSON for struct {struct_name}\\n\");")
                    c_content.append(f"        // Initialize field to zero? C struct should be zeroed by caller ideally.")
                    c_content.append(f"    }}")
                c_content.append("    return success;")
             c_content.append(f"}}")
             c_content.append("")

    # Add union unmarshalers if needed (tricky, maybe just skip?)

    # Generic unmarshaler
    c_content.append("// Unmarshal a cJSON value into a C variable based on expected type")
    c_content.append("static bool unmarshal_value(cJSON *json_value, const char *expected_c_type_str, void *target_c_ptr, const lv_obj_t *target_obj_for_setter) {")
    c_content.append("    if (!json_value || !target_c_ptr || !expected_c_type_str) return false;")
    c_content.append("")
    c_content.append("    // Handle null JSON value -> set pointer to NULL, or numeric/bool to 0/false")
    c_content.append("    if (cJSON_IsNull(json_value)) {")
    c_content.append("        if (strchr(expected_c_type_str, '*')) { *(void**)target_c_ptr = NULL; return true; }")
    c_content.append("        if (strcmp(expected_c_type_str, \"bool\") == 0) { *(bool*)target_c_ptr = false; return true; }")
    c_content.append("        // For numbers, enums, structs passed by value - set to 0? Requires size.")
    c_content.append("        // Let's return false for non-pointer nulls for now, caller should handle.")
    c_content.append("        // fprintf(stderr, \"Builder Warning: Cannot unmarshal JSON null into non-pointer type '%s'\\n\", expected_c_type_str);")
    c_content.append("         memset(target_c_ptr, 0, sizeof(target_c_ptr)); // Attempt zeroing (risky) ")
    c_content.append("        return true; // Or false? Let's say true, it was null.")
    c_content.append("    }")
    c_content.append("")

    c_content.append("    // 1. Opaque Pointer (by ID string)")
    c_content.append("    if (strchr(expected_c_type_str, '*') && !strstr(expected_c_type_str, \"char*\")) { // Pointer type, but not char*")
    c_content.append("        // Check if JSON value is a string (potential ID)")
    c_content.append("        if (cJSON_IsString(json_value)) {")
    c_content.append("            const char *id_str = json_value->valuestring;")
    c_content.append("            // Try finding in the object registry")
    c_content.append("            void *lvgl_ptr = find_lvgl_ptr_by_id(id_str);")
    c_content.append("            if (lvgl_ptr) {")
    c_content.append("                *(void**)target_c_ptr = lvgl_ptr;")
    c_content.append("                return true;")
    c_content.append("            }")
    c_content.append("            // Try finding in the external resources")
    c_content.append("            const void *external_ptr = find_external_resource_ptr(id_str);")
    c_content.append("            if (external_ptr) {")
    c_content.append("                 // Need const_cast or intermediate non-const variable if target isn't const void**")
    c_content.append("                *(const void**)target_c_ptr = external_ptr;")
    c_content.append("                return true;")
    c_content.append("            }")
    c_content.append("            // Handle <unregistered...> placeholders? Maybe return NULL.")
    c_content.append("            if (strncmp(id_str, \"<unregistered\", 12) == 0 || strcmp(id_str, \"<void*>:0x0\") == 0) {")
    c_content.append("                 *(void**)target_c_ptr = NULL;")
    c_content.append("                 return true; // Treat as NULL")
    c_content.append("             }")

    c_content.append("            fprintf(stderr, \"Builder Error: Could not find LVGL pointer or external resource for ID '%s' needed for type '%s'\\n\", id_str, expected_c_type_str);")
    c_content.append("            *(void**)target_c_ptr = NULL; // Set target to NULL on failure")
    c_content.append("            return false;")
    c_content.append("        } else {")
    c_content.append("            fprintf(stderr, \"Builder Error: Expected string ID for pointer type '%s', but got JSON type %d\\n\", expected_c_type_str, json_value->type);")
    c_content.append("             *(void**)target_c_ptr = NULL;")
    c_content.append("            return false;")
    c_content.append("        }")
    c_content.append("    }")
    c_content.append("")

    c_content.append("    // 2. Enum (by string value)")
    c_content.append("    // Heuristic: if type name ends with _t and isn't a known struct/union/opaque")
    c_content.append("    bool maybe_enum = strstr(expected_c_type_str, \"_t\") != NULL && !strchr(expected_c_type_str, '*') && !strstr(expected_c_type_str, \"struct\") && !strstr(expected_c_type_str, \"union\");")
    c_content.append("    // Refine heuristic: Check against actual filtered enums if needed more accuracy")
    c_content.append("    if (maybe_enum) {")
    c_content.append("        return unmarshal_enum(json_value, expected_c_type_str, target_c_ptr);")
    c_content.append("    }")
    c_content.append("")

    c_content.append("    // 3. Concrete Struct (by object value - assuming passed by value or pointer)")
    c_content.append("    // Heuristic: Check if type name is a known concrete struct/union")
    bool maybe_struct_or_union = False
    # Check if expected_c_type_str corresponds to a generated concrete struct/union
    concrete_types_check = set()
    for s in config['filtered_structures']:
        if not is_opaque(s, api_data, config): concrete_types_check.add(s['name'])
    for u in config['filtered_unions']:
        if not is_opaque(u, api_data, config): concrete_types_check.add(u['name'])

    # Check if the type string matches a concrete type name (or its typedef)
    for concrete_type_name in concrete_types_check:
        typedef_name = find_typedef_for_base(concrete_type_name, api_data, config)
        match_name = typedef_name if typedef_name else concrete_type_name
        if strcmp(expected_c_type_str, match_name) == 0 or strcmp(expected_c_type_str, f"const {match_name}") == 0:
            maybe_struct_or_union = True
            break
        if strcmp(expected_c_type_str, f"struct {concrete_type_name}") == 0 or strcmp(expected_c_type_str, f"const struct {concrete_type_name}") == 0:
             maybe_struct_or_union = True
             break
        if strcmp(expected_c_type_str, f"union {concrete_type_name}") == 0 or strcmp(expected_c_type_str, f"const union {concrete_type_name}") == 0:
             maybe_struct_or_union = True
             break

    c_content.append(f"    if ({str(maybe_struct_or_union).lower()} && cJSON_IsObject(json_value)) {{")
    # Dispatch to specific struct/union unmarshaler
    struct_union_found = False
    for struct in config['filtered_structures']:
        struct_name = struct['name']
        if not is_opaque({"name": struct_name}, api_data, config):
            typedef_name = find_typedef_for_base(struct_name, api_data, config)
            match_name = typedef_name if typedef_name else struct_name
            func_name_suffix = sanitize_name(match_name)
            c_struct_type = typedef_name if typedef_name else f"struct {struct_name}"
            c_content.append(f"        if (strcmp(expected_c_type_str, \"{match_name}\") == 0 || strcmp(expected_c_type_str, \"const {match_name}\") == 0 || strcmp(expected_c_type_str, \"struct {struct_name}\") == 0) {{")
            c_content.append(f"            return unmarshal_struct_{func_name_suffix}(json_value, ({c_struct_type}*)target_c_ptr);")
            c_content.append(f"        }}")
            struct_union_found = True
    # Add similar loop for unions if needed
    if struct_union_found:
        c_content.append(f"        // Fallback if type string doesn't match")
    c_content.append("    }")
    c_content.append("")


    c_content.append("    // 4. String (char *)")
    c_content.append("    if (strcmp(expected_c_type_str, \"const char*\") == 0 || strcmp(expected_c_type_str, \"char*\") == 0) {")
    c_content.append("        if (!cJSON_IsString(json_value)) return false;")
    c_content.append("        // Caller needs to manage memory for the string if it's not const char*")
    c_content.append("        // For builder, assume target is lv_label_set_text etc, which copy the string.")
    c_content.append("        *(const char**)target_c_ptr = json_value->valuestring;")
    c_content.append("        return true;")
    c_content.append("    }")
    c_content.append("")

    c_content.append("    // 5. Boolean (bool)")
    c_content.append("    if (strcmp(expected_c_type_str, \"bool\") == 0) {")
    c_content.append("        if (!cJSON_IsBool(json_value)) return false;")
    c_content.append("        *(bool*)target_c_ptr = cJSON_IsTrue(json_value);")
    c_content.append("        return true;")
    c_content.append("    }")
    c_content.append("")

    c_content.append("    // 6. Numeric types (int, float, double, short, char, size_t, stdint types)")
    c_content.append("    if (cJSON_IsNumber(json_value)) {")
    c_content.append("        double num_val = json_value->valuedouble;")
    c_content.append("        // Use string comparisons to cast correctly")
    c_content.append("        if (strcmp(expected_c_type_str, \"float\") == 0 || strcmp(expected_c_type_str, \"const float\") == 0) { *(float*)target_c_ptr = (float)num_val; return true; }")
    c_content.append("        if (strcmp(expected_c_type_str, \"double\") == 0 || strcmp(expected_c_type_str, \"const double\") == 0) { *(double*)target_c_ptr = num_val; return true; }")
    c_content.append("        if (strcmp(expected_c_type_str, \"char\") == 0 || strcmp(expected_c_type_str, \"signed char\") == 0 || strcmp(expected_c_type_str, \"const char\") == 0 || strcmp(expected_c_type_str, \"const signed char\") == 0) { *(signed char*)target_c_ptr = (signed char)num_val; return true; }")
    c_content.append("        if (strcmp(expected_c_type_str, \"unsigned char\") == 0 || strcmp(expected_c_type_str, \"uint8_t\") == 0 || strcmp(expected_c_type_str, \"const unsigned char\") == 0 || strcmp(expected_c_type_str, \"const uint8_t\") == 0 || strcmp(expected_c_type_str, \"lv_opa_t\") == 0) { *(unsigned char*)target_c_ptr = (unsigned char)num_val; return true; }")
    c_content.append("        if (strcmp(expected_c_type_str, \"short\") == 0 || strcmp(expected_c_type_str, \"signed short\") == 0 || strcmp(expected_c_type_str, \"int16_t\") == 0 || strcmp(expected_c_type_str, \"const short\") == 0 || strcmp(expected_c_type_str, \"const signed short\") == 0 || strcmp(expected_c_type_str, \"const int16_t\") == 0 || strcmp(expected_c_type_str, \"lv_state_t\") == 0) { *(short*)target_c_ptr = (short)num_val; return true; }")
    c_content.append("        if (strcmp(expected_c_type_str, \"unsigned short\") == 0 || strcmp(expected_c_type_str, \"uint16_t\") == 0 || strcmp(expected_c_type_str, \"const unsigned short\") == 0 || strcmp(expected_c_type_str, \"const uint16_t\") == 0) { *(unsigned short*)target_c_ptr = (unsigned short)num_val; return true; }")
    c_content.append("        if (strcmp(expected_c_type_str, \"int\") == 0 || strcmp(expected_c_type_str, \"signed int\") == 0 || strcmp(expected_c_type_str, \"int32_t\") == 0 || strcmp(expected_c_type_str, \"const int\") == 0 || strcmp(expected_c_type_str, \"const signed int\") == 0 || strcmp(expected_c_type_str, \"const int32_t\") == 0 || strcmp(expected_c_type_str, \"lv_coord_t\") == 0 || strcmp(expected_c_type_str, \"lv_res_t\") == 0) { *(int*)target_c_ptr = (int)num_val; return true; }")
    c_content.append("        if (strcmp(expected_c_type_str, \"unsigned int\") == 0 || strcmp(expected_c_type_str, \"uint32_t\") == 0 || strcmp(expected_c_type_str, \"const unsigned int\") == 0 || strcmp(expected_c_type_str, \"const uint32_t\") == 0 || strcmp(expected_c_type_str, \"lv_part_t\") == 0 || strcmp(expected_c_type_str, \"lv_style_selector_t\") == 0) { *(unsigned int*)target_c_ptr = (unsigned int)num_val; return true; }")
    c_content.append("        if (strcmp(expected_c_type_str, \"long\") == 0 || strcmp(expected_c_type_str, \"signed long\") == 0 || strcmp(expected_c_type_str, \"intptr_t\") == 0 || strcmp(expected_c_type_str, \"int64_t\") == 0 || strcmp(expected_c_type_str, \"const long\") == 0 || strcmp(expected_c_type_str, \"const signed long\") == 0 || strcmp(expected_c_type_str, \"const intptr_t\") == 0 || strcmp(expected_c_type_str, \"const int64_t\") == 0) { *(long long*)target_c_ptr = (long long)num_val; return true; }")
    c_content.append("        if (strcmp(expected_c_type_str, \"unsigned long\") == 0 || strcmp(expected_c_type_str, \"uintptr_t\") == 0 || strcmp(expected_c_type_str, \"size_t\") == 0 || strcmp(expected_c_type_str, \"uint64_t\") == 0 || strcmp(expected_c_type_str, \"const unsigned long\") == 0 || strcmp(expected_c_type_str, \"const uintptr_t\") == 0 || strcmp(expected_c_type_str, \"const size_t\") == 0 || strcmp(expected_c_type_str, \"const uint64_t\") == 0) { *(unsigned long long*)target_c_ptr = (unsigned long long)num_val; return true; }")
    c_content.append("        // Fallback if specific numeric type not matched")
    c_content.append("        fprintf(stderr, \"Builder Warning: Unhandled numeric type '%s', attempting cast from double\\n\", expected_c_type_str);")
    c_content.append("        *(int*)target_c_ptr = (int)num_val; // Default to int cast as fallback")
    c_content.append("        return true;")
    c_content.append("    }")
    c_content.append("")

    c_content.append("    fprintf(stderr, \"Builder Error: Cannot unmarshal JSON type %d into C type '%s'\\n\", json_value->type, expected_c_type_str);")
    c_content.append("    return false;")
    c_content.append("}")
    c_content.append("")

    # --- Function Lookups and Dispatch ---
    c_content.append("// --- LVGL Function Dispatch ---")

    # Generate constructor dispatch
    c_content.append("static void* call_lvgl_constructor(const char *func_name, cJSON *args_json, lv_obj_t *parent_override) {")
    c_content.append("    // Needs a large switch or function pointer table based on filtered_functions")
    constructor_found = False
    for func in config['filtered_functions']:
        if get_function_type(func, api_data, config) == 'constructor':
            constructor_found = True
            func_name = func['name']
            args = func.get('args', [])
            ret_type_info = func.get("type", {}).get("type", {})
            ret_type_str = get_c_type_name(ret_type_info, api_data, config, use_opaque_typedef=False) # Use real LVGL type

            c_content.append(f"    if (strcmp(func_name, \"{func_name}\") == 0) {{")
            # Unmarshal arguments
            arg_vars = []
            for i, arg_info in enumerate(args):
                arg_type = get_c_type_name(arg_info['type'], api_data, config, use_opaque_typedef=False) # Use real LVGL type
                arg_base_name = get_base_type_name(arg_info['type'])
                arg_var = f"arg_{i}"
                arg_vars.append(arg_var)
                c_content.append(f"        {arg_type} {arg_var};")
                c_content.append(f"        cJSON *arg_json_{i} = cJSON_GetArrayItem(args_json, {i});")
                # Special handling for parent object in create functions
                is_parent_arg = (i == 0 and arg_type == "lv_obj_t*")
                if is_parent_arg:
                    c_content.append(f"        if (parent_override) {{")
                    c_content.append(f"            {arg_var} = parent_override;")
                    c_content.append(f"        }} else {{")
                    # If parent_override is NULL, try to unmarshal from JSON arg (might be NULL or ID)
                    c_content.append(f"            void* temp_parent_ptr = NULL;")
                    c_content.append(f"            if (!unmarshal_value(arg_json_{i}, \"{arg_type}\", &temp_parent_ptr, NULL)) {{")
                    c_content.append(f"                fprintf(stderr, \"Builder Error: Failed to unmarshal parent argument for {func_name}\\n\");")
                    c_content.append(f"                return NULL; // Cannot create without parent")
                    c_content.append(f"            }}")
                    c_content.append(f"             {arg_var} = (lv_obj_t*)temp_parent_ptr;")
                    c_content.append(f"        }}")
                else:
                    # Generic unmarshaling
                    c_content.append(f"        if (!unmarshal_value(arg_json_{i}, \"{arg_type}\", &{arg_var}, NULL)) {{")
                    c_content.append(f"            fprintf(stderr, \"Builder Error: Failed to unmarshal argument {i} ('{arg_info.get('name', '?')}') for {func_name}\\n\");")
                    c_content.append(f"            return NULL;")
                    c_content.append(f"        }}")

            # Call the real LVGL function
            param_str = ", ".join(arg_vars) if arg_vars else ""
            c_content.append(f"        return (void*){func_name}({param_str});")
            c_content.append(f"    }}")

    if constructor_found: c_content.append(" else ")
    c_content.append("    {")
    c_content.append("        fprintf(stderr, \"Builder Error: Unknown constructor function '%s'\\n\", func_name);")
    c_content.append("        return NULL;")
    c_content.append("    }")
    c_content.append("}")
    c_content.append("")


    # Generate setter dispatch
    c_content.append("static bool call_lvgl_setter(const char *prop_name, cJSON *value_json, const char *obj_type, void *target_lvgl_ptr) {")
    c_content.append("    // This requires a massive lookup based on obj_type and prop_name")
    c_content.append("    // Example for lv_label_set_text:")

    setter_map = defaultdict(list) # obj_type -> list of (prop_name, func_name, func_info)
    for func in config['filtered_functions']:
         if get_function_type(func, api_data, config) == 'setter':
             if func.get('args'):
                 first_arg_type_info = func['args'][0]['type']
                 if first_arg_type_info.get('json_type') == 'pointer':
                     target_type_info = first_arg_type_info.get('type')
                     target_type_name = get_base_type_name(target_type_info)
                     if target_type_name:
                          # Derive prop name (simplified)
                          func_name = func['name']
                          prop_name = func_name
                          prefixes_to_strip = ["lv_obj_set_", "lv_style_set_", "lv_group_", "lv_timer_", "lv_anim_", "lv_indev_", "lv_display_"]
                          best_match_len = 0
                          prefix_found = False
                          for prefix in prefixes_to_strip:
                              if prop_name.startswith(prefix) and len(prefix) > best_match_len:
                                  best_match_len = len(prefix)
                                  prefix_found = True
                          if prefix_found: prop_name = prop_name[best_match_len:]
                          elif prop_name.startswith("lv_"):
                              parts = prop_name.split('_', 2);
                              if len(parts) == 3 and parts[1] != "obj": prop_name = prop_name[3:]

                          setter_map[target_type_name].append((prop_name, func_name, func))

    for obj_type, setters in setter_map.items():
         c_content.append(f"    if (strcmp(obj_type, \"{obj_type}\") == 0) {{")
         for prop_name, func_name, func_info in setters:
             c_content.append(f"        if (strcmp(prop_name, \"{prop_name}\") == 0) {{")
             args = func_info.get('args', [])
             # Unmarshal arguments (skip first target arg)
             arg_vars = [f"({get_c_type_name(args[0]['type'], api_data, config, False)})target_lvgl_ptr"] # Cast target ptr
             num_val_args = len(args) - 1
             if num_val_args == 0:
                 # No value needed, just call function
                 pass
             elif num_val_args == 1:
                 # Single value argument
                 arg_info = args[1]
                 arg_type = get_c_type_name(arg_info['type'], api_data, config, use_opaque_typedef=False)
                 c_content.append(f"            {arg_type} val;")
                 c_content.append(f"            if (!unmarshal_value(value_json, \"{arg_type}\", &val, (const lv_obj_t*)target_lvgl_ptr)) return false;")
                 arg_vars.append("val")
             else:
                 # Multiple value arguments expected in a JSON array
                 c_content.append(f"            if (!cJSON_IsArray(value_json) || cJSON_GetArraySize(value_json) != {num_val_args}) {{")
                 c_content.append(f"                fprintf(stderr, \"Builder Error: Expected array of size {num_val_args} for property '{prop_name}' of {obj_type}\\n\");")
                 c_content.append(f"                return false;")
                 c_content.append(f"            }}")
                 for i, arg_info in enumerate(args[1:]):
                      arg_var = f"val_{i}"
                      arg_type = get_c_type_name(arg_info['type'], api_data, config, use_opaque_typedef=False)
                      c_content.append(f"            {arg_type} {arg_var};")
                      c_content.append(f"            cJSON* val_json_{i} = cJSON_GetArrayItem(value_json, {i});")
                      c_content.append(f"            if (!unmarshal_value(val_json_{i}, \"{arg_type}\", &{arg_var}, (const lv_obj_t*)target_lvgl_ptr)) return false;")
                      arg_vars.append(arg_var)

             # Call the real LVGL setter
             param_str = ", ".join(arg_vars)
             c_content.append(f"            {func_name}({param_str});")
             c_content.append(f"            return true;")
             c_content.append(f"        }} else") # Chain else ifs

         c_content.append("        { /* Unknown property for this type */ }") # End of last else if
         c_content.append(f"    }} else") # Chain else ifs for obj_type

    c_content.append("    { /* Unknown object type */ }") # End of last else if for obj_type

    c_content.append("    fprintf(stderr, \"Builder Error: No matching setter found for property '%s' on object type '%s'\\n\", prop_name, obj_type);")
    c_content.append("    return false;")
    c_content.append("}")
    c_content.append("")


    # --- Main Build Function ---
    c_content.append("// --- Main Build Function ---")
    c_content.append(f"bool {UI_BUILDER_OUTPUT_PREFIX}_build_ui(const char *json_string, lv_obj_t *target_parent) {{")
    c_content.append("    if (!json_string || !target_parent) {")
    c_content.append("        fprintf(stderr, \"Builder Error: NULL json_string or target_parent provided.\\n\");")
    c_content.append("        return false;")
    c_content.append("    }")
    c_content.append("")
    c_content.append("    // Clear previous build state")
    c_content.append("    lv_obj_clean(target_parent);")
    c_content.append("    clear_id_to_ptr_registry();")
    c_content.append("")
    c_content.append("    // Parse the JSON")
    c_content.append("    cJSON *root = cJSON_Parse(json_string);")
    c_content.append("    if (!root) {")
    c_content.append("        const char *error_ptr = cJSON_GetErrorPtr();")
    c_content.append("        fprintf(stderr, \"Builder Error: Failed to parse JSON: %s\\n\", error_ptr ? error_ptr : \"unknown error\");")
    c_content.append("        return false;")
    c_content.append("    }")
    c_content.append("")
    c_content.append("    cJSON *sim_array = cJSON_GetObjectItemCaseSensitive(root, \"lvgl_simulation\");")
    c_content.append("    if (!cJSON_IsArray(sim_array)) {")
    c_content.append("        fprintf(stderr, \"Builder Error: JSON missing 'lvgl_simulation' array.\\n\");")
    c_content.append("        cJSON_Delete(root);")
    c_content.append("        return false;")
    c_content.append("    }")
    c_content.append("")
    c_content.append("    bool success = true;")
    c_content.append("    cJSON *obj_json = NULL;")
    c_content.append("")
    c_content.append("    // Pass 1: Create non-widget objects (styles, etc.) and register externals")
    c_content.append("    // printf(\"Builder Pass 1: Non-Widgets & Externals\\n\");")
    c_content.append("    cJSON_ArrayForEach(obj_json, sim_array) {")
    c_content.append("        if (!cJSON_IsObject(obj_json)) continue;")
    c_content.append("        cJSON *id_json = cJSON_GetObjectItemCaseSensitive(obj_json, \"id\");")
    c_content.append("        cJSON *type_json = cJSON_GetObjectItemCaseSensitive(obj_json, \"type\");")
    c_content.append("        cJSON *source_json = cJSON_GetObjectItemCaseSensitive(obj_json, \"source\");")
    c_content.append("        const char *id_str = id_json ? id_json->valuestring : NULL;")
    c_content.append("        const char *type_str = type_json ? type_json->valuestring : NULL;")
    c_content.append("")
    c_content.append("        if (!id_str || !type_str) continue;")
    c_content.append("")
    c_content.append("        // Handle externally registered resources")
    c_content.append("        if (source_json && strcmp(source_json->valuestring, \"external\") == 0) {")
    c_content.append("            const void *external_ptr = find_external_resource_ptr(id_str);")
    c_content.append("            if (external_ptr) {")
    c_content.append("                // Add mapping from ID to the *provided* external pointer")
    c_content.append("                add_lvgl_ptr_mapping(id_str, (void*)external_ptr);")
    c_content.append("            } else {")
    c_content.append("                success = false; // Error already printed by find_external_resource_ptr")
    c_content.append("            }")
    c_content.append("            continue; // Move to next item")
    c_content.append("        }")
    c_content.append("")
    c_content.append("        // Skip widget types in this pass")
    c_content.append("        if (strcmp(type_str, \"lv_obj_t\") == 0 || strstr(type_str, \"widget_t\") || strstr(type_str,\"lv_\") == type_str) { // TODO: Improve widget detection? Base class? ")
    c_content.append("           bool is_widget = true;")
    c_content.append("           // Add specific non-widget types here if needed (e.g., lv_group_t?)")
    c_content.append("           if (strcmp(type_str, \"lv_style_t\") == 0 || strcmp(type_str, \"lv_anim_t\") == 0 || strcmp(type_str, \"lv_group_t\") == 0 || strcmp(type_str, \"lv_timer_t\") == 0 || strcmp(type_str, \"lv_theme_t\") == 0 ) is_widget = false;")
    c_content.append("           if (is_widget) continue;");
    c_content.append("        }")
    c_content.append("")
    c_content.append("        // Handle constructors for non-widgets")
    c_content.append("        cJSON *constructor_json = cJSON_GetObjectItemCaseSensitive(obj_json, \"constructor\");")
    c_content.append("        cJSON *constructor_args_json = cJSON_GetObjectItemCaseSensitive(obj_json, \"constructor_args\");")
    c_content.append("        if (constructor_json && cJSON_IsString(constructor_json)) {")
    c_content.append("            const char *constructor_name = constructor_json->valuestring;")
    c_content.append("            // Note: parent_override is NULL for non-widgets")
    c_content.append("            void *new_ptr = call_lvgl_constructor(constructor_name, constructor_args_json, NULL);")
    c_content.append("            if (new_ptr) {")
    c_content.append("                if (!add_lvgl_ptr_mapping(id_str, new_ptr)) success = false;")
    c_content.append("            } else {")
    c_content.append("                fprintf(stderr, \"Builder Error: Constructor '%s' for ID '%s' failed.\\n\", constructor_name, id_str);")
    c_content.append("                success = false;")
    c_content.append("            }")
    c_content.append("        }")
    c_content.append("        // TODO: Handle init functions if needed for non-widgets")
    c_content.append("    }")
    c_content.append("")
    c_content.append("    // Pass 2: Create widget objects")
    c_content.append("    // printf(\"Builder Pass 2: Widgets\\n\");")
    c_content.append("    cJSON_ArrayForEach(obj_json, sim_array) {")
    c_content.append("        if (!cJSON_IsObject(obj_json)) continue;")
    c_content.append("        cJSON *id_json = cJSON_GetObjectItemCaseSensitive(obj_json, \"id\");")
    c_content.append("        cJSON *type_json = cJSON_GetObjectItemCaseSensitive(obj_json, \"type\");")
    c_content.append("        cJSON *source_json = cJSON_GetObjectItemCaseSensitive(obj_json, \"source\");")
    c_content.append("        const char *id_str = id_json ? id_json->valuestring : NULL;")
    c_content.append("        const char *type_str = type_json ? type_json->valuestring : NULL;")
    c_content.append("")
    c_content.append("        if (!id_str || !type_str) continue;")
    c_content.append("        if (source_json && strcmp(source_json->valuestring, \"external\") == 0) continue; // Skip externals")
    c_content.append("")
    c_content.append("        // Only process widget types in this pass")
    c_content.append("        bool is_widget = false;")
    c_content.append("        if (strcmp(type_str, \"lv_obj_t\") == 0 || strstr(type_str, \"widget_t\") || strstr(type_str, \"lv_\") == type_str) {")
    c_content.append("           is_widget = true;")
    c_content.append("           if (strcmp(type_str, \"lv_style_t\") == 0 || strcmp(type_str, \"lv_anim_t\") == 0 || strcmp(type_str, \"lv_group_t\") == 0 || strcmp(type_str, \"lv_timer_t\") == 0 || strcmp(type_str, \"lv_theme_t\") == 0) is_widget = false;")
    c_content.append("        }")
    c_content.append("        if (!is_widget) continue;")
    c_content.append("")
    c_content.append("        // If already processed (e.g., maybe a base obj that was also a parent), skip")
    c_content.append("        if (find_lvgl_ptr_by_id(id_str)) continue;")
    c_content.append("")
    c_content.append("        cJSON *constructor_json = cJSON_GetObjectItemCaseSensitive(obj_json, \"constructor\");")
    c_content.append("        cJSON *constructor_args_json = cJSON_GetObjectItemCaseSensitive(obj_json, \"constructor_args\");")
    c_content.append("        if (constructor_json && cJSON_IsString(constructor_json)) {")
    c_content.append("            const char *constructor_name = constructor_json->valuestring;")
    c_content.append("            // Pass target_parent as the override for top-level objects")
    c_content.append("            void *new_ptr = call_lvgl_constructor(constructor_name, constructor_args_json, target_parent);")
    c_content.append("            if (new_ptr) {")
    c_content.append("                if (!add_lvgl_ptr_mapping(id_str, new_ptr)) success = false;")
    c_content.append("            } else {")
    c_content.append("                fprintf(stderr, \"Builder Error: Constructor '%s' for widget ID '%s' failed.\\n\", constructor_name, id_str);")
    c_content.append("                success = false;")
    c_content.append("            }")
    c_content.append("        } else {")
    c_content.append("             fprintf(stderr, \"Builder Error: Widget ID '%s' (type %s) missing valid constructor.\\n\", id_str, type_str);")
    c_content.append("             success = false;")
    c_content.append("        }")
    c_content.append("    }")
    c_content.append("")
    c_content.append("    // Pass 3: Apply properties (setters)")
    c_content.append("    // printf(\"Builder Pass 3: Properties\\n\");")
    c_content.append("    cJSON_ArrayForEach(obj_json, sim_array) {")
    c_content.append("        if (!cJSON_IsObject(obj_json)) continue;")
    c_content.append("        cJSON *id_json = cJSON_GetObjectItemCaseSensitive(obj_json, \"id\");")
    c_content.append("        cJSON *type_json = cJSON_GetObjectItemCaseSensitive(obj_json, \"type\");")
    c_content.append("        cJSON *source_json = cJSON_GetObjectItemCaseSensitive(obj_json, \"source\");")
    c_content.append("        const char *id_str = id_json ? id_json->valuestring : NULL;")
    c_content.append("        const char *type_str = type_json ? type_json->valuestring : NULL;")
    c_content.append("")
    c_content.append("        if (!id_str || !type_str) continue;")
    c_content.append("        if (source_json && strcmp(source_json->valuestring, \"external\") == 0) continue; // Skip externals")
    c_content.append("")
    c_content.append("        void *target_ptr = find_lvgl_ptr_by_id(id_str);")
    c_content.append("        if (!target_ptr) {")
    c_content.append("            // This might happen if constructor failed in pass 2")
    c_content.append("            // fprintf(stderr, \"Builder Warning: Cannot apply properties, LVGL object pointer not found for ID '%s'.\\n\", id_str);")
    c_content.append("            continue;")
    c_content.append("        }")
    c_content.append("")
    c_content.append("        cJSON *props_array = cJSON_GetObjectItemCaseSensitive(obj_json, \"props\");")
    c_content.append("        if (cJSON_IsArray(props_array)) {")
    c_content.append("            cJSON *prop_entry = NULL;")
    c_content.append("            cJSON_ArrayForEach(prop_entry, props_array) {")
    c_content.append("                if (!cJSON_IsObject(prop_entry)) continue;")
    c_content.append("                cJSON *prop_name_json = cJSON_GetObjectItemCaseSensitive(prop_entry, \"name\");")
    c_content.append("                cJSON *prop_value_json = cJSON_GetObjectItemCaseSensitive(prop_entry, \"value\");")
    c_content.append("                if (prop_name_json && cJSON_IsString(prop_name_json)) {")
    c_content.append("                    const char *prop_name_str = prop_name_json->valuestring;")
    c_content.append("                    if (!call_lvgl_setter(prop_name_str, prop_value_json, type_str, target_ptr)) {")
    c_content.append("                        // Error already printed by call_lvgl_setter")
    c_content.append("                        success = false;")
    c_content.append("                        // Decide whether to stop on first error or continue applying properties")
    c_content.append("                        // break; // Optional: Stop processing props for this object on error")
    c_content.append("                    }")
    c_content.append("                }")
    c_content.append("            }")
    c_content.append("        }")
    c_content.append("    }")
    c_content.append("")
    c_content.append("    // Cleanup")
    c_content.append("    cJSON_Delete(root);")
    c_content.append("    // Do NOT clear the ID registry here if we want to potentially update later")
    c_content.append("    // clear_id_to_ptr_registry();")
    c_content.append("")
    c_content.append("    return success;")
    c_content.append("}")

    return "\n".join(c_content)

# --- Main Script Logic for gen_ui_builder.py ---

def main_builder():
    parser = argparse.ArgumentParser(
        description="Generate C library for building LVGL UI from JSON.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument("json_api_file", help="Path to the LVGL API JSON description file.")
    parser.add_argument("-o", "--output-dir", default="generated_ui_builder", help="Directory to output the C header and source files.")
    # Use fixed names for builder library
    # parser.add_argument("-p", "--output-prefix", default="ui_builder", help="Prefix for the output C files.")

    # Use the *same* include/exclude lists as gen_wrapper to ensure consistency
    parser.add_argument("--include-funcs", nargs='+', default=["lv_"], help="Prefixes for functions to include.")
    parser.add_argument("--exclude-funcs", nargs='*', default=[
        "lv_log_", "lv_mem_", "lv_tick_", "lv_timer_handler", "lv_init", "lv_deinit", "lv_is_initialized",
        "lv_debug_", "lv_profiler_", "lv_assert_", "lv_memcpy", "lv_memset", "lv_memscpy",
        "lv_malloc", "lv_free", "lv_realloc",
        "lv_event_send", "lv_event_get_", "lv_event_register_id", "lv_event_dsc_get_",
        "lv_async_",
        "lv_anim_custom_get", "lv_anim_get_timer", "lv_anim_get_playtime", "lv_anim_path_",
        "lv_draw_",
        "lv_display_set_buffers", "lv_display_add_event", "lv_display_get_event", "lv_display_send_event", "lv_display_flush_", "lv_display_wait_",
        "lv_indev_read", "lv_indev_search", "lv_indev_get_read_timer", "lv_indev_read_timer_cb",
        "lv_obj_class_create_obj", "lv_obj_class_init_obj", "lv_obj_assign_spec_attr", "lv_obj_get_disp",
        "lv_obj_invalidate_area", "lv_obj_redraw",
        "lv_global_get",
        "lv_snapshot_",
        "lv_theme_apply",
        "lv_image_decoder_get_", "lv_image_decoder_built_in_", "lv_image_cache_",
        "lv_font_get_", "lv_font_load", "lv_font_free",
        "lv_fs_",
        "lv_task_", "lv_timer_exec",
        "lv_style_get_prop", "lv_style_prop_lookup_flags",
        "lv_rand", "lv_srand",
        "lv_timer_create", # Has callback
        "lv_obj_add_event_cb", "lv_obj_remove_event", "lv_obj_remove_event_cb", # Event callbacks
        "lv_anim_set_exec_cb", "lv_anim_set_custom_exec_cb", "lv_anim_set_start_cb", "lv_anim_set_completed_cb", "lv_anim_set_deleted_cb", "lv_anim_set_get_value_cb", # Anim callbacks
        "lv_observer_create_with_handler", # Observer callback
        "lv_subject_add_observer_with_handler", # Subject callback
        "lv_group_set_focus_cb", "lv_group_set_edge_cb", # Group callbacks
        "lv_display_set_flush_cb", "lv_display_set_flush_wait_cb", # Display callbacks
        "lv_indev_set_read_cb", # Input callback
        "lv_label_set_text_fmt", "lv_snprintf", "lv_subject_snprintf", # Varargs
        "lv_obj_set_style_local_", "lv_obj_get_style_", # Deprecated
        ], help="Prefixes for functions to exclude.")
    parser.add_argument("--include-enums", nargs='+', default=["lv_"], help="Prefixes for enums to include.")
    parser.add_argument("--exclude-enums", nargs='*', default=["_lv_"], help="Prefixes for enums to exclude.")
    parser.add_argument("--include-structs", nargs='+', default=["lv_"], help="Prefixes for structs to include.")
    parser.add_argument("--exclude-structs", nargs='*', default=[
        "_lv_", "lv_global_t", "lv_ll_t", "lv_rb_t", "lv_event_dsc_t", "lv_ts_calibration_t",
        "lv_draw_unit_t", "lv_draw_task_t", "lv_draw_buf_t",
        "lv_font_fmt_",
        "lv_anim_path_t",
        ], help="Prefixes for structs to exclude.")
    parser.add_argument("--include-unions", nargs='+', default=["lv_"], help="Prefixes for unions to include.")
    parser.add_argument("--exclude-unions", nargs='*', default=["_lv_"], help="Prefixes for unions to exclude.")
    parser.add_argument("--include-typedefs", nargs='+', default=["lv_"], help="Prefixes for typedefs to include.")
    parser.add_argument("--exclude-typedefs", nargs='*', default=[], help="Prefixes for typedefs to exclude.")
    parser.add_argument("--config", help="Path to the JSON config file generated by gen_wrapper.py.")
    # We don't need macros for the builder
    # parser.add_argument("--include-macros", ...)
    # parser.add_argument("--exclude-macros", ...)
    # Opaque types are determined by the wrapper, builder doesn't need this directly
    # parser.add_argument("--opaque-types", ...)

    args = parser.parse_args()

    # --- Load Wrapper Configuration ---
    print(f"Loading wrapper configuration from: {args.wrapper_config_file}")
    try:
        with open(args.wrapper_config_file, 'r', encoding='utf-8') as f_cfg:
            wrapper_config = json.load(f_cfg)
        # Validate basic structure (optional)
        if wrapper_config.get("generator") != "gen_wrapper.py":
             print("Warning: Configuration file might not be from gen_wrapper.py")
    except FileNotFoundError:
        print(f"Error: Wrapper config file not found at {args.wrapper_config_file}")
        exit(1)
    except json.JSONDecodeError as e:
        print(f"Error: Could not parse wrapper config file {args.wrapper_config_file}: {e}")
        exit(1)
    except Exception as e:
        print(f"An unexpected error occurred reading the wrapper config file: {e}")
        exit(1)

    # --- Load API Data ---
    try:
        with open(args.json_api_file, 'r', encoding='utf-8') as f:
            api_data = json.load(f)
    except FileNotFoundError:
        print(f"Error: API JSON file not found at {args.json_api_file}")
        exit(1)
    except json.JSONDecodeError as e:
        print(f"Error: Could not parse API JSON file {args.json_api_file}: {e}")
        exit(1)
    except Exception as e:
        print(f"An unexpected error occurred reading the JSON file: {e}")
        exit(1)

    # --- Filter API Data (for builder needs) ---
    # We mainly need functions (for signatures) and enums/structs (for unmarshaling)
    config = {
        "output_base_name": UI_BUILDER_OUTPUT_PREFIX, # Fixed prefix
        "filtered_functions": [],
        "filtered_enums": [],
        "filtered_structures": [],
        "filtered_unions": [],
        "filtered_typedefs": [],
        # No macros needed for builder usually
        "opaque_types": set(), # Builder determines based on ID presence in JSON
        "all_known_types": set()
    }

    print("Filtering API elements for UI Builder...")
    # Define categories and keys for filtering
    categories_to_filter = [
        ("functions", "name", args.include_funcs, args.exclude_funcs),
        ("enums", "name", args.include_enums, args.exclude_enums),
        ("structures", "name", args.include_structs, args.exclude_structs),
        ("unions", "name", args.include_unions, args.exclude_unions),
        ("typedefs", "name", args.include_typedefs, args.exclude_typedefs),
    ]
    for category, key, inc_list, exc_list in categories_to_filter:
        filtered_items = []
        original_count = len(api_data.get(category, []))
        for item in api_data.get(category, []):
            item_name = item.get(key)
            # Apply same filtering as wrapper for consistency
            if item_name and matches_prefix(item_name, inc_list) and not matches_prefix(item_name, exc_list):
                 skip_item = False
                 if category == "functions":
                      # Exclude functions with varargs (...)
                      if any(arg and arg.get("type", {}).get("json_type") == "special_type" and arg["type"].get("name") == "ellipsis" for arg in item.get("args", [])):
                          # print(f"  Excluding varargs function: {item_name}")
                          skip_item = True
                      # Exclude functions taking function pointers as arguments
                      elif any(arg and get_type_details(arg.get("type"), api_data) and get_type_details(arg.get("type"), api_data).get("json_type") == "function_pointer" for arg in item.get("args", [])):
                          # print(f"  Excluding function with function pointer arg: {item_name}")
                          skip_item = True
                      # Exclude functions with common callback typedef names in args
                      elif any( (t_name := arg and get_c_type_name(arg.get("type"), api_data, config, use_opaque_typedef=False)) and ("_cb_t" in t_name or "_f_t" in t_name) for arg in item.get("args",[])):
                          base_cb_name = get_base_type_name(arg.get("type")) if arg else None
                          if base_cb_name and not matches_prefix(base_cb_name, exc_list):
                              # print(f"  Excluding function with callback arg type: {item_name}")
                              skip_item = True
                 if not skip_item:
                     filtered_items.append(item)

        config[f"filtered_{category}"] = filtered_items
        print(f"  {category.capitalize()}: Kept {len(filtered_items)} out of {original_count}")

    # --- Generate Code ---
    print(f"Generating C header file ({UI_BUILDER_OUTPUT_PREFIX}.h)...")
    header_code = generate_builder_header(api_data, config)

    print(f"Generating C source file ({UI_BUILDER_OUTPUT_PREFIX}.c)...")
    source_code = generate_builder_source(api_data, config)

    # --- Write Output Files ---
    os.makedirs(args.output_dir, exist_ok=True)
    header_path = os.path.join(args.output_dir, f"{UI_BUILDER_OUTPUT_PREFIX}.h")
    source_path = os.path.join(args.output_dir, f"{UI_BUILDER_OUTPUT_PREFIX}.c")

    try:
        with open(header_path, 'w', encoding='utf-8') as f:
            f.write(header_code)
        print(f"Successfully wrote header file: {header_path}")
    except IOError as e:
        print(f"Error writing header file {header_path}: {e}")
        exit(1)

    try:
        with open(source_path, 'w', encoding='utf-8') as f:
            f.write(source_code)
        print(f"Successfully wrote source file: {source_path}")
    except IOError as e:
        print(f"Error writing source file {source_path}: {e}")
        exit(1)

    print("\nUI Builder generation complete.")
    print("You will also need the sample main_watcher.c (or adapt it).")


if __name__ == "__main__":
    main_builder()
