
#include "lvgl_json_renderer.h"
#include <string.h> // For strcmp, strchr, strncpy, strlen etc.
#include <stdio.h>  // For snprintf, logging
#include <stdlib.h> // For strtoul, strtol

// LVGL functions used internally (ensure they are linked)
// extern lv_obj_t * lv_screen_active(void); // Declared in lvgl.h
// extern void *lv_malloc(size_t size); // Declared in lv_mem.h / lv_conf.h
// extern void lv_free(void *ptr);     // Declared in lv_mem.h / lv_conf.h
// extern char *lv_strdup(const char *str); // Declared in lv_mem.h / lv_conf.h


// --- Logging Helper ---

// Convert cJSON node to a compact string for logging (caller must free result)
char* json_node_to_string(cJSON *node) {
    if (!node) {
        // Use standard malloc/strdup if lv_strdup isn't guaranteed
        char *null_str = (char*)malloc(5); // "NULL" + '\0'
        if (null_str) strcpy(null_str, "NULL");
        return null_str;
    }
    // PrintUnformatted is more compact for logs
    char *str = cJSON_PrintUnformatted(node);
    if (!str) {
        char *err_str = (char*)malloc(40); // "{"error":"Failed to print JSON"}" + '\0'
        if (err_str) strcpy(err_str, "{\"error\":\"Failed to print JSON\"}");
        return err_str;
    }
    // Optional: Truncate very long strings if needed for logs
    // const int max_len = 120;
    // if (str && strlen(str) > max_len) { str[max_len-3] = '.'; str[max_len-2] = '.'; str[max_len-1] = '.'; str[max_len] = '\0'; }
    return str; // cJSON_Print... allocates, caller must use cJSON_free
}

// --- Configuration ---
// Add any compile-time configuration here if needed

// --- Invocation Table ---
// --- Invocation Table ---

// Forward declaration of the invoker function signature type
struct invoke_table_entry_s;
typedef bool (*invoke_fn_t)(const struct invoke_table_entry_s *entry, void *target_obj_ptr, void *dest, cJSON *args_array);

// Structure for each entry in the invocation table
typedef struct invoke_table_entry_s {
    const char *name;           // LVGL function name (e.g., "lv_obj_set_width")
    invoke_fn_t invoke;       // Pointer to the C invocation wrapper function
    void *func_ptr;         // Pointer to the actual LVGL function
    const char *ret_type;       // Specific C return type string
    const char *arg_types[8]; // Specific C argument type strings
} invoke_table_entry_t;



// --- Pointer Registry Implementation ---
// --- Pointer Registry ---

#include <string.h>
#include <stdlib.h>

// Basic Hash Map Registry (Placeholder - requires implementation)
#define HASH_MAP_SIZE 256
typedef struct registry_entry {
    char *name;
    char *type_name; // Added for type safety
    void *ptr;
    struct registry_entry *next;
} registry_entry_t;

static registry_entry_t* g_registry_map[HASH_MAP_SIZE] = {0};

static unsigned int hash(const char *str) {
    unsigned long hash = 5381;
    int c;
    while ((c = *str++)) hash = ((hash << 5) + hash) + c; /* djb2 */
    return hash % HASH_MAP_SIZE;
}

void lvgl_json_register_ptr(const char *name, const char *type_name, void *ptr) {
    if (!name || !type_name || !ptr) return;
    unsigned int index = hash(name);
    // Check if name already exists (update or handle error?)
    registry_entry_t *entry = g_registry_map[index];
    while(entry) {
        if(strcmp(entry->name, name) == 0) {
             LOG_WARN("Registry Warning: Name '%s' already registered. Updating pointer and type.", name);
             LV_FREE(entry->type_name); // Free old type_name
             entry->type_name = lv_strdup(type_name); // Update type_name
             if (!entry->type_name) { LOG_ERR("Registry Error: Failed to duplicate type_name for update"); /* What to do? Original ptr is kept */ return; }
             entry->ptr = ptr; // Update existing entry
             return;
        }
        entry = entry->next;
    }
    // Add new entry
    registry_entry_t *new_entry = (registry_entry_t *)LV_MALLOC(sizeof(registry_entry_t));
    if (!new_entry) { LOG_ERR("Registry Error: Failed to allocate memory"); return; }
    new_entry->name = lv_strdup(name);
    if (!new_entry->name) { LV_FREE(new_entry); LOG_ERR("Registry Error: Failed to duplicate name"); return; }
    new_entry->type_name = lv_strdup(type_name);
    if (!new_entry->type_name) { LV_FREE(new_entry->name); LV_FREE(new_entry); LOG_ERR("Registry Error: Failed to duplicate type_name"); return; }
    new_entry->ptr = ptr;
    new_entry->next = g_registry_map[index];
    g_registry_map[index] = new_entry;
     LOG_INFO("Registered pointer '%s' with type '%s'", name, type_name);
}

void* lvgl_json_get_registered_ptr(const char *name, const char *expected_type_name) {
    if (!name) return NULL;
    unsigned int index = hash(name);
    registry_entry_t *entry = g_registry_map[index];
    while (entry != NULL) {
        if (strcmp(entry->name, name) == 0) {
            // Type check
            if (expected_type_name == NULL || entry->type_name == NULL) { // Wildcard or error in registration
                 if(expected_type_name != NULL && entry->type_name == NULL) LOG_WARN("Registry: Entry '%s' has no type_name.", name);
                 return entry->ptr; // No type check possible or requested
            }
            // Smart type comparison: if expected is 'type*', compare with 'type'
            size_t expected_len = strlen(expected_type_name);
            bool types_match = false;
            if (expected_len > 0 && expected_type_name[expected_len - 1] == '*') {
                 // Expected a pointer type like 'lv_style_t *', compare base 'lv_style_t'
                 // Need to be careful with 'const char **' vs 'const char *'
                 // Simple check: compare entry->type_name with expected_type_name minus the last '*'
                 // This assumes stored type_name is always the base type (e.g., "lv_style_t")
                 char base_expected_type[256]; // Assume type names are not excessively long
                 if (expected_len -1 < sizeof(base_expected_type)) {
                    strncpy(base_expected_type, expected_type_name, expected_len -1);
                    base_expected_type[expected_len -1] = '\0';
                    // Trim trailing space if it was 'lv_style_t *'
                    if(expected_len > 1 && base_expected_type[expected_len - 2] == ' ') base_expected_type[expected_len - 2] = '\0';
                    types_match = (strcmp(entry->type_name, base_expected_type) == 0);
                 }
            } else {
                 // Expected a non-pointer type or already a base type, direct compare
                 types_match = (strcmp(entry->type_name, expected_type_name) == 0);
            }

            if (types_match) {
                 return entry->ptr;
            } else {
                 LOG_WARN("Registry: Found entry '%s', but type mismatch. Expected compatible with '%s', got '%s'.", name, expected_type_name, entry->type_name);
                 return NULL; // Type mismatch for the found name
            }
        }
        entry = entry->next;
    }
    return NULL;
}

void lvgl_json_registry_clear() {
    for(int i = 0; i < HASH_MAP_SIZE; ++i) {
        registry_entry_t *entry = g_registry_map[i];
        while(entry) {
             registry_entry_t *next = entry->next;
             LV_FREE(entry->type_name);
             LV_FREE(entry->name);
             LV_FREE(entry);
             entry = next;
        }
        g_registry_map[i] = NULL;
    }
     LOG_INFO("Pointer registry cleared.");
}



// --- Enum Unmarshaling ---
// --- Enum Unmarshaling (Hybrid Hashed Approach) ---

static uint32_t djb2_hash_c(const char *str) {
    uint32_t hash = 5381;
    unsigned char c;
    while ((c = (unsigned char)*str++)) {
        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
    }
    return hash;
}

// User-defined enum mappings (runtime configurable)
typedef struct {
    const char *name; // Copied string, user responsible for lifetime if not literal
    uint32_t hash;
    int value;
} user_enum_entry_t;

static user_enum_entry_t g_user_enum_table[64];
static size_t g_num_user_enums = 0;

// Function to add user-defined enum mappings (exposed via lvgl_json_renderer.h if needed)
// For now, keep it static. If exposing, ensure thread safety if applicable.
bool lvgl_json_add_user_enum_mapping(const char* name, int value) {
    if (g_num_user_enums >= 64) {
        LOG_ERR("User enum table full. Cannot add '%s'.", name);
        return false;
    }
    // Consider if 'name' should be strdup'd if not a literal. For now, assume it's persistent.
    g_user_enum_table[g_num_user_enums].name = name; 
    g_user_enum_table[g_num_user_enums].hash = djb2_hash_c(name);
    g_user_enum_table[g_num_user_enums].value = value;
    g_num_user_enums++;
    return true;
}

void lvgl_json_clear_user_enum_mappings() {
    // If names were strdup'd, free them here.
    g_num_user_enums = 0;
}

// Generated enum table (sorted by hash, then name)
typedef struct {
    uint32_t hash;
    const char *original_name; // For collision resolution
    int c_value;
    // const char *original_type_name; // Optional: for type checking, adds to size
} generated_enum_entry_t;

static const generated_enum_entry_t g_generated_enum_table[] = {
    {0x00cfc914, "LV_STYLE_LAYOUT", 0x16 }, // Type: UNKNOWN_TYPE
    {0x00fd8677, "LV_ALIGN_OUT_TOP_RIGHT", 0x0c }, // Type: lv_align_t
    {0x011200b8, "LV_STYLE_LENGTH", 0x03 }, // Type: UNKNOWN_TYPE
    {0x01efa188, "LV_STYLE_MARGIN_BOTTOM", 0x19 }, // Type: UNKNOWN_TYPE
    {0x03fea8f4, "LV_STYLE_OUTLINE_COLOR", 0x39 }, // Type: UNKNOWN_TYPE
    {0x041f5906, "LV_SCROLLBAR_MODE_AUTO", 0x03 }, // Type: lv_scrollbar_mode_t
    {0x043dbc47, "LV_ALIGN_RIGHT_MID", 0x08 }, // Type: lv_align_t
    {0x0487f306, "LV_PART_KNOB", 0x30000 }, // Type: lv_style_parts_t
    {0x0488d3c1, "LV_PART_MAIN", 0x00 }, // Type: lv_style_parts_t
    {0x04fb2cb1, "LV_STYLE_TEXT_FONT", 0x5a }, // Type: UNKNOWN_TYPE
    {0x05652755, "LV_STYLE_OUTLINE_WIDTH", 0x38 }, // Type: UNKNOWN_TYPE
    {0x0567548a, "LV_STYLE_GRID_ROW_DSC_ARRAY", 0x81 }, // Type: UNKNOWN_TYPE
    {0x069ea8b4, "LV_STYLE_LINE_DASH_GAP", 0x4a }, // Type: UNKNOWN_TYPE
    {0x0784fec8, "LV_STR_SYMBOL_DIRECTORY", 0x22 }, // Type: UNKNOWN_TYPE
    {0x07e8bb1a, "LV_STYLE_TEXT_OPA", 0x59 }, // Type: UNKNOWN_TYPE
    {0x082c6744, "LV_TREE_WALK_POST_ORDER", 0x01 }, // Type: UNKNOWN_TYPE
    {0x087177a6, "LV_ALIGN_OUT_LEFT_BOTTOM", 0x12 }, // Type: lv_align_t
    {0x0a84396d, "LV_STYLE_IMAGE_RECOLOR_OPA", 0x46 }, // Type: UNKNOWN_TYPE
    {0x0db371ba, "LV_BUTTONMATRIX_CTRL_NONE", 0x00 }, // Type: lv_buttonmatrix_ctrl_t
    {0x0ec31f5e, "LV_STYLE_RADIUS", 0x0c }, // Type: UNKNOWN_TYPE
    {0x0ed249cf, "LV_SCALE_MODE_HORIZONTAL_BOTTOM", 0x01 }, // Type: lv_scale_mode_t
    {0x0f1e6bc3, "LV_GRID_FR_10", 0x1fffffa5 }, // Type: MACRO_FROM_STRING_VALUES
    {0x10b0ead1, "LV_STYLE_MARGIN_RIGHT", 0x1b }, // Type: UNKNOWN_TYPE
    {0x112d1946, "LV_STYLE_MARGIN_TOP", 0x18 }, // Type: UNKNOWN_TYPE
    {0x12434c36, "LV_GRID_ALIGN_CENTER", 0x01 }, // Type: lv_grid_align_t
    {0x12fbf1da, "LV_STYLE_BG_GRAD_DIR", 0x20 }, // Type: UNKNOWN_TYPE
    {0x12fc217b, "LV_STYLE_BG_GRAD_OPA", 0x25 }, // Type: UNKNOWN_TYPE
    {0x1406fca7, "LV_STR_SYMBOL_EYE_OPEN", 0x1b }, // Type: UNKNOWN_TYPE
    {0x1453e5bd, "LV_STYLE_BG_COLOR", 0x1c }, // Type: UNKNOWN_TYPE
    {0x16ce98d5, "LV_STYLE_OUTLINE_OPA", 0x3a }, // Type: UNKNOWN_TYPE
    {0x16ce9b2a, "LV_STYLE_OUTLINE_PAD", 0x3b }, // Type: UNKNOWN_TYPE
    {0x174ac271, "LV_ALIGN_CENTER", 0x09 }, // Type: lv_align_t
    {0x18592ec2, "LV_COORD_MAX", 0x1fffffff }, // Type: MACRO_FROM_STRING_VALUES
    {0x18592fc0, "LV_COORD_MIN", -0x1fffffff }, // Type: MACRO_FROM_STRING_VALUES
    {0x1881fee0, "LV_STYLE_ANIM_DURATION", 0x67 }, // Type: UNKNOWN_TYPE
    {0x1999fc1b, "LV_STYLE_ANIM", 0x66 }, // Type: UNKNOWN_TYPE
    {0x1b6d1aff, "LV_RADIUS_CIRCLE", 0x7fff }, // Type: MACRO_FROM_STRING_VALUES
    {0x1bc72f1b, "LV_STR_SYMBOL_BULLET", 0x00 }, // Type: UNKNOWN_TYPE
    {0x1d2b2abd, "LV_STR_SYMBOL_CHARGE", 0x2a }, // Type: UNKNOWN_TYPE
    {0x1d7d9e75, "LV_GRIDNAV_CTRL_VERTICAL_MOVE_ONLY", 0x08 }, // Type: lv_gridnav_ctrl_t
    {0x1d7d9e75, "LV_GRIDNAV_CTRL_VERTICAL_MOVE_ONLY", 0x08 }, // Type: _lvimage_flags_t
    {0x1d7d9e75, "LV_GRIDNAV_CTRL_VERTICAL_MOVE_ONLY", 0x08 }, // Type: _lvimage_flags_t
    {0x1d7d9e75, "LV_GRIDNAV_CTRL_VERTICAL_MOVE_ONLY", 0x08 }, // Type: _lvimage_flags_t
    {0x1d7d9e75, "LV_GRIDNAV_CTRL_VERTICAL_MOVE_ONLY", 0x08 }, // Type: _lvimage_flags_t
    {0x1d7d9e75, "LV_GRIDNAV_CTRL_VERTICAL_MOVE_ONLY", 0x08 }, // Type: _lvimage_flags_t
    {0x1d7d9e75, "LV_GRIDNAV_CTRL_VERTICAL_MOVE_ONLY", 0x08 }, // Type: _lvimage_flags_t
    {0x1d7d9e75, "LV_GRIDNAV_CTRL_VERTICAL_MOVE_ONLY", 0x08 }, // Type: _lvimage_flags_t
    {0x1d7d9e75, "LV_GRIDNAV_CTRL_VERTICAL_MOVE_ONLY", 0x08 }, // Type: _lvimage_flags_t
    {0x1d7d9e75, "LV_GRIDNAV_CTRL_VERTICAL_MOVE_ONLY", 0x08 }, // Type: _lvimage_flags_t
    {0x1d7d9e75, "LV_GRIDNAV_CTRL_VERTICAL_MOVE_ONLY", 0x08 }, // Type: _lvimage_flags_t
    {0x1d7d9e75, "LV_GRIDNAV_CTRL_VERTICAL_MOVE_ONLY", 0x08 }, // Type: _lvimage_flags_t
    {0x1d7d9e75, "LV_GRIDNAV_CTRL_VERTICAL_MOVE_ONLY", 0x08 }, // Type: _lvimage_flags_t
    {0x1d7d9e75, "LV_GRIDNAV_CTRL_VERTICAL_MOVE_ONLY", 0x08 }, // Type: _lvimage_flags_t
    {0x1d7d9e75, "LV_GRIDNAV_CTRL_VERTICAL_MOVE_ONLY", 0x08 }, // Type: _lvimage_flags_t
    {0x1d7d9e75, "LV_GRIDNAV_CTRL_VERTICAL_MOVE_ONLY", 0x08 }, // Type: _lvimage_flags_t
    {0x1e46e344, "LV_STR_SYMBOL_SETTINGS", 0x07 }, // Type: UNKNOWN_TYPE
    {0x1e605647, "LV_BUTTONMATRIX_CTRL_NO_REPEAT", 0x20 }, // Type: lv_buttonmatrix_ctrl_t
    {0x1fe9ffc1, "LV_STYLE_ROTARY_SENSITIVITY", 0x76 }, // Type: UNKNOWN_TYPE
    {0x201e5db5, "LV_SLIDER_MODE_NORMAL", 0x00 }, // Type: lv_slider_mode_t
    {0x20c7dbc6, "LV_TEXT_DECOR_NONE", 0x00 }, // Type: lv_text_decor_t
    {0x20e1150f, "LV_ALIGN_BOTTOM_LEFT", 0x04 }, // Type: lv_align_t
    {0x23587712, "LV_STYLE_BG_IMAGE_TILED", 0x2c }, // Type: UNKNOWN_TYPE
    {0x2381bd4a, "LV_BUTTONMATRIX_CTRL_WIDTH_10", 0x0a }, // Type: lv_buttonmatrix_ctrl_t
    {0x2381bd4b, "LV_BUTTONMATRIX_CTRL_WIDTH_11", 0x0b }, // Type: lv_buttonmatrix_ctrl_t
    {0x2381bd4c, "LV_BUTTONMATRIX_CTRL_WIDTH_12", 0x0c }, // Type: lv_buttonmatrix_ctrl_t
    {0x2381bd4d, "LV_BUTTONMATRIX_CTRL_WIDTH_13", 0x0d }, // Type: lv_buttonmatrix_ctrl_t
    {0x2381bd4e, "LV_BUTTONMATRIX_CTRL_WIDTH_14", 0x0e }, // Type: lv_buttonmatrix_ctrl_t
    {0x2381bd4f, "LV_BUTTONMATRIX_CTRL_WIDTH_15", 0x0f }, // Type: lv_buttonmatrix_ctrl_t
    {0x243c2f5e, "LV_FLEX_FLOW_ROW_REVERSE", 0x08 }, // Type: lv_flex_flow_t
    {0x2540e730, "LV_CHART_POINT_NONE", 0x7fffffff }, // Type: MACRO_FROM_STRING_VALUES
    {0x264290ca, "LV_STYLE_ARC_COLOR", 0x52 }, // Type: UNKNOWN_TYPE
    {0x2769a0dc, "LV_STYLE_BG_GRAD", 0x26 }, // Type: UNKNOWN_TYPE
    {0x27a90f2b, "LV_STYLE_ARC_WIDTH", 0x50 }, // Type: UNKNOWN_TYPE
    {0x27cd06e9, "LV_ARC_MODE_SYMMETRICAL", 0x01 }, // Type: lv_arc_mode_t
    {0x2880e9a3, "LV_GRID_ALIGN_START", 0x00 }, // Type: lv_grid_align_t
    {0x28bf6ae8, "LV_BAR_MODE_SYMMETRICAL", 0x01 }, // Type: lv_bar_mode_t
    {0x2a1168dc, "LV_STYLE_LINE_DASH_WIDTH", 0x49 }, // Type: UNKNOWN_TYPE
    {0x2a4f71fe, "LV_STYLE_PROP_ANY", 0xff }, // Type: UNKNOWN_TYPE
    {0x2a4f9403, "LV_STYLE_PROP_INV", 0x00 }, // Type: UNKNOWN_TYPE
    {0x2aa565ef, "LV_STYLE_BASE_DIR", 0x27 }, // Type: UNKNOWN_TYPE
    {0x2c90dc45, "LV_GRIDNAV_CTRL_HORIZONTAL_MOVE_ONLY", 0x04 }, // Type: lv_gridnav_ctrl_t
    {0x2dd3e235, "LV_TEXT_ALIGN_CENTER", 0x02 }, // Type: lv_text_align_t
    {0x2e9760f5, "LV_STYLE_BG_IMAGE_RECOLOR_OPA", 0x2b }, // Type: UNKNOWN_TYPE
    {0x2eabd768, "LV_SCROLLBAR_MODE_OFF", 0x00 }, // Type: lv_scrollbar_mode_t
    {0x308f8fce, "LV_STYLE_IMAGE_RECOLOR", 0x45 }, // Type: UNKNOWN_TYPE
    {0x323efbdc, "LV_STYLE_GRID_CELL_X_ALIGN", 0x85 }, // Type: UNKNOWN_TYPE
    {0x32fd0e6e, "LV_STYLE_NUM_BUILT_IN_PROPS", 0x8a }, // Type: UNKNOWN_TYPE
    {0x335d9a63, "LV_FLEX_FLOW_ROW", 0x00 }, // Type: lv_flex_flow_t
    {0x33811d65, "LV_TREE_WALK_PRE_ORDER", 0x00 }, // Type: UNKNOWN_TYPE
    {0x338cfd95, "LV_ALIGN_OUT_BOTTOM_MID", 0x0e }, // Type: lv_align_t
    {0x33994615, "LV_STYLE_ARC_IMAGE_SRC", 0x54 }, // Type: UNKNOWN_TYPE
    {0x341c9766, "LV_OPA_10", 0x19 }, // Type: lv_opa_enum_t
    {0x341c9787, "LV_OPA_20", 0x33 }, // Type: lv_opa_enum_t
    {0x341c97a8, "LV_OPA_30", 0x4c }, // Type: lv_opa_enum_t
    {0x341c97c9, "LV_OPA_40", 0x66 }, // Type: lv_opa_enum_t
    {0x341c97ea, "LV_OPA_50", 0x7f }, // Type: lv_opa_enum_t
    {0x341c980b, "LV_OPA_60", 0x99 }, // Type: lv_opa_enum_t
    {0x341c982c, "LV_OPA_70", 0xb2 }, // Type: lv_opa_enum_t
    {0x341c984d, "LV_OPA_80", 0xcc }, // Type: lv_opa_enum_t
    {0x341c986e, "LV_OPA_90", 0xe5 }, // Type: lv_opa_enum_t
    {0x34282afa, "LV_PART_CURSOR", 0x60000 }, // Type: lv_style_parts_t
    {0x34bf09fc, "LV_ALIGN_TOP_MID", 0x02 }, // Type: lv_align_t
    {0x3501c9bf, "LV_STYLE_LAST_BUILT_IN_PROP", 0x89 }, // Type: UNKNOWN_TYPE
    {0x36cbb37e, "LV_STYLE_MARGIN_LEFT", 0x1a }, // Type: UNKNOWN_TYPE
    {0x373372cd, "LV_SLIDER_ORIENTATION_VERTICAL", 0x02 }, // Type: lv_slider_orientation_t
    {0x383fcb90, "LV_STYLE_TEXT_OUTLINE_STROKE_OPA", 0x60 }, // Type: UNKNOWN_TYPE
    {0x387ab232, "LV_STYLE_MIN_HEIGHT", 0x06 }, // Type: UNKNOWN_TYPE
    {0x39e5ca96, "LV_BUTTONMATRIX_CTRL_HIDDEN", 0x10 }, // Type: lv_buttonmatrix_ctrl_t
    {0x3a1253e0, "LV_STR_SYMBOL_BATTERY_FULL", 0x31 }, // Type: UNKNOWN_TYPE
    {0x3d727e82, "LV_ALIGN_BOTTOM_RIGHT", 0x06 }, // Type: lv_align_t
    {0x3da6341b, "LV_STYLE_MAX_WIDTH", 0x05 }, // Type: UNKNOWN_TYPE
    {0x3e327fc4, "LV_PART_ANY", 0xf0000 }, // Type: lv_style_parts_t
    {0x3e950be2, "LV_STR_SYMBOL_REFRESH", 0x0b }, // Type: UNKNOWN_TYPE
    {0x40a7aa63, "LV_STYLE_GRID_CELL_ROW_POS", 0x86 }, // Type: UNKNOWN_TYPE
    {0x41343214, "LV_GRIDNAV_CTRL_NONE", 0x00 }, // Type: lv_gridnav_ctrl_t
    {0x42287616, "LV_SLIDER_MODE_SYMMETRICAL", 0x01 }, // Type: lv_slider_mode_t
    {0x4475985c, "LV_STYLE_ARC_ROUNDED", 0x51 }, // Type: UNKNOWN_TYPE
    {0x44f9f359, "LV_STYLE_SHADOW_OFFSET_X", 0x40 }, // Type: UNKNOWN_TYPE
    {0x44f9f35a, "LV_STYLE_SHADOW_OFFSET_Y", 0x41 }, // Type: UNKNOWN_TYPE
    {0x4687766f, "LV_STYLE_TEXT_OUTLINE_STROKE_COLOR", 0x61 }, // Type: UNKNOWN_TYPE
    {0x4696b705, "LV_STR_SYMBOL_AUDIO", 0x01 }, // Type: UNKNOWN_TYPE
    {0x46b628a9, "LV_STR_SYMBOL_CLOSE", 0x05 }, // Type: UNKNOWN_TYPE
    {0x46cb724d, "LV_STR_SYMBOL_DRIVE", 0x0a }, // Type: UNKNOWN_TYPE
    {0x46cd275f, "LV_STR_SYMBOL_DUMMY", 0x3d }, // Type: UNKNOWN_TYPE
    {0x46d9145e, "LV_STR_SYMBOL_EJECT", 0x16 }, // Type: UNKNOWN_TYPE
    {0x47230af6, "LV_STR_SYMBOL_IMAGE", 0x0f }, // Type: UNKNOWN_TYPE
    {0x4769749f, "LV_STR_SYMBOL_MINUS", 0x1a }, // Type: UNKNOWN_TYPE
    {0x479b7030, "LV_STR_SYMBOL_PASTE", 0x2b }, // Type: UNKNOWN_TYPE
    {0x479b7891, "LV_STR_SYMBOL_PAUSE", 0x13 }, // Type: UNKNOWN_TYPE
    {0x47a32ca0, "LV_STR_SYMBOL_POWER", 0x06 }, // Type: UNKNOWN_TYPE
    {0x47bec4b8, "LV_STR_SYMBOL_UPLOAD", 0x23 }, // Type: UNKNOWN_TYPE
    {0x47c3cfb1, "LV_STR_SYMBOL_RIGHT", 0x18 }, // Type: UNKNOWN_TYPE
    {0x47ecd7f5, "LV_STR_SYMBOL_TRASH", 0x38 }, // Type: UNKNOWN_TYPE
    {0x47edf4d0, "LV_STYLE_TEXT_OUTLINE_STROKE_WIDTH", 0x5f }, // Type: UNKNOWN_TYPE
    {0x480c248a, "LV_STR_SYMBOL_VIDEO", 0x02 }, // Type: UNKNOWN_TYPE
    {0x48f1f330, "LV_STR_SYMBOL_BACKSPACE", 0x3a }, // Type: UNKNOWN_TYPE
    {0x4a11507f, "LV_FLEX_ALIGN_CENTER", 0x02 }, // Type: lv_flex_align_t
    {0x4b1d47b9, "LV_ALIGN_OUT_BOTTOM_RIGHT", 0x0f }, // Type: lv_align_t
    {0x4be33b98, "LV_TABLE_CELL_CTRL_TEXT_CROP", 0x02 }, // Type: lv_table_cell_ctrl_t
    {0x4cd86641, "LV_STYLE_ALIGN", 0x0a }, // Type: UNKNOWN_TYPE
    {0x4d0261b5, "LV_ALIGN_DEFAULT", 0x00 }, // Type: lv_align_t
    {0x4d3e9502, "LV_STYLE_PAD_ROW", 0x14 }, // Type: UNKNOWN_TYPE
    {0x4d3e9d7d, "LV_STYLE_PAD_TOP", 0x10 }, // Type: UNKNOWN_TYPE
    {0x4d8e66f2, "LV_GRID_ALIGN_STRETCH", 0x03 }, // Type: lv_grid_align_t
    {0x4e64c896, "LV_STYLE_WIDTH", 0x01 }, // Type: UNKNOWN_TYPE
    {0x4ec6590b, "LV_STR_SYMBOL_DOWNLOAD", 0x09 }, // Type: UNKNOWN_TYPE
    {0x4ef51ff2, "LV_SPAN_OVERFLOW_CLIP", 0x00 }, // Type: lv_span_overflow_t
    {0x4ef9e1de, "LV_SPAN_OVERFLOW_LAST", 0x02 }, // Type: lv_span_overflow_t
    {0x50ba8fd4, "LV_ALIGN_LEFT_MID", 0x07 }, // Type: lv_align_t
    {0x50ed6c2a, "LV_STYLE_TRANSFORM_HEIGHT", 0x6b }, // Type: UNKNOWN_TYPE
    {0x52d3fe19, "LV_ALIGN_OUT_RIGHT_BOTTOM", 0x15 }, // Type: lv_align_t
    {0x52d680d9, "LV_STYLE_GRID_CELL_COLUMN_SPAN", 0x84 }, // Type: UNKNOWN_TYPE
    {0x538bfef3, "LV_STYLE_BORDER_OPA", 0x32 }, // Type: UNKNOWN_TYPE
    {0x559e9e23, "LV_STYLE_GRID_CELL_ROW_SPAN", 0x87 }, // Type: UNKNOWN_TYPE
    {0x583355b0, "LV_STR_SYMBOL_VOLUME_MAX", 0x0e }, // Type: UNKNOWN_TYPE
    {0x583356a4, "LV_STR_SYMBOL_VOLUME_MID", 0x0d }, // Type: UNKNOWN_TYPE
    {0x58e0ce5f, "LV_STYLE_PAD_BOTTOM", 0x11 }, // Type: UNKNOWN_TYPE
    {0x58ecc18b, "LV_STYLE_RECOLOR_OPA", 0x79 }, // Type: UNKNOWN_TYPE
    {0x5b19abb8, "LV_STYLE_IMAGE_OPA", 0x44 }, // Type: UNKNOWN_TYPE
    {0x5b3197f8, "LV_STYLE_PAD_COLUMN", 0x15 }, // Type: UNKNOWN_TYPE
    {0x5c044eed, "LV_SCALE_MODE_HORIZONTAL_TOP", 0x00 }, // Type: lv_scale_mode_t
    {0x5c520420, "LV_PART_SCROLLBAR", 0x10000 }, // Type: lv_style_parts_t
    {0x5c6cad8d, "LV_TEXT_ALIGN_AUTO", 0x00 }, // Type: lv_text_align_t
    {0x5c726fdf, "LV_TEXT_ALIGN_LEFT", 0x01 }, // Type: lv_text_align_t
    {0x5eab8875, "LV_OPA_0", 0x00 }, // Type: lv_opa_enum_t
    {0x5f06e2a9, "LV_GRID_ALIGN_SPACE_AROUND", 0x05 }, // Type: lv_grid_align_t
    {0x5f754928, "LV_SCALE_MODE_VERTICAL_RIGHT", 0x03 }, // Type: lv_scale_mode_t
    {0x6088f854, "LV_SCALE_MODE_ROUND_INNER", 0x04 }, // Type: lv_scale_mode_t
    {0x60cf07ef, "LV_SPAN_MODE_LAST", 0x03 }, // Type: lv_span_mode_t
    {0x60f97b87, "LV_SCALE_MODE_ROUND_OUTER", 0x05 }, // Type: lv_scale_mode_t
    {0x610409e0, "LV_ALIGN_TOP_RIGHT", 0x03 }, // Type: lv_align_t
    {0x615a2cc6, "LV_GRID_CONTENT", 0x1fffff9a }, // Type: MACRO_FROM_STRING_VALUES
    {0x62f95584, "LV_OPA_COVER", 0xff }, // Type: lv_opa_enum_t
    {0x64461015, "LV_FLEX_ALIGN_END", 0x01 }, // Type: lv_flex_align_t
    {0x65ae0e92, "LV_STYLE_BORDER_COLOR", 0x31 }, // Type: UNKNOWN_TYPE
    {0x67148cf3, "LV_STYLE_BORDER_WIDTH", 0x30 }, // Type: UNKNOWN_TYPE
    {0x674c1132, "LV_STYLE_FLEX_CROSS_PLACE", 0x7c }, // Type: UNKNOWN_TYPE
    {0x689e4d73, "LV_GRID_ALIGN_SPACE_EVENLY", 0x04 }, // Type: lv_grid_align_t
    {0x6b00d3a2, "LV_STYLE_TRANSFORM_SKEW_X", 0x73 }, // Type: UNKNOWN_TYPE
    {0x6b00d3a3, "LV_STYLE_TRANSFORM_SKEW_Y", 0x74 }, // Type: UNKNOWN_TYPE
    {0x6b25fd61, "LV_STYLE_TRANSITION", 0x68 }, // Type: UNKNOWN_TYPE
    {0x6d18e635, "LV_BUTTONMATRIX_CTRL_CUSTOM_1", 0x4000 }, // Type: lv_buttonmatrix_ctrl_t
    {0x6d18e636, "LV_BUTTONMATRIX_CTRL_CUSTOM_2", 0x8000 }, // Type: lv_buttonmatrix_ctrl_t
    {0x6df7bf6e, "LV_STYLE_LINE_ROUNDED", 0x4b }, // Type: UNKNOWN_TYPE
    {0x6ebbe45c, "LV_STYLE_FLEX_FLOW", 0x7a }, // Type: UNKNOWN_TYPE
    {0x6ebc8a43, "LV_STYLE_FLEX_GROW", 0x7e }, // Type: UNKNOWN_TYPE
    {0x6ee5d1ca, "LV_GRID_ALIGN_SPACE_BETWEEN", 0x06 }, // Type: lv_grid_align_t
    {0x6f04e840, "LV_BUTTONMATRIX_CTRL_RECOLOR", 0x800 }, // Type: lv_buttonmatrix_ctrl_t
    {0x72829581, "LV_STYLE_BG_GRAD_STOP", 0x22 }, // Type: UNKNOWN_TYPE
    {0x749b558b, "LV_ALIGN_OUT_LEFT_MID", 0x11 }, // Type: lv_align_t
    {0x749b7424, "LV_ALIGN_OUT_LEFT_TOP", 0x10 }, // Type: lv_align_t
    {0x77102a9a, "LV_STYLE_SHADOW_COLOR", 0x3d }, // Type: UNKNOWN_TYPE
    {0x7876a8fb, "LV_STYLE_SHADOW_WIDTH", 0x3c }, // Type: UNKNOWN_TYPE
    {0x790d09f3, "LV_FLEX_ALIGN_SPACE_BETWEEN", 0x05 }, // Type: lv_flex_align_t
    {0x799294fe, "LV_STR_SYMBOL_BATTERY_1", 0x34 }, // Type: UNKNOWN_TYPE
    {0x799294ff, "LV_STR_SYMBOL_BATTERY_2", 0x33 }, // Type: UNKNOWN_TYPE
    {0x79929500, "LV_STR_SYMBOL_BATTERY_3", 0x32 }, // Type: UNKNOWN_TYPE
    {0x7a042580, "LV_SPAN_MODE_BREAK", 0x02 }, // Type: lv_span_mode_t
    {0x7a47e96b, "LV_SPAN_MODE_FIXED", 0x00 }, // Type: lv_span_mode_t
    {0x7c4666bc, "LV_STR_SYMBOL_BATTERY_EMPTY", 0x35 }, // Type: UNKNOWN_TYPE
    {0x7d2d0ab7, "LV_STYLE_PAD_RADIAL", 0x0e }, // Type: UNKNOWN_TYPE
    {0x7e7d3e3a, "LV_STYLE_SHADOW_SPREAD", 0x42 }, // Type: UNKNOWN_TYPE
    {0x7f39389d, "LV_STYLE_GRID_CELL_Y_ALIGN", 0x88 }, // Type: UNKNOWN_TYPE
    {0x806f0d49, "LV_TEXT_DECOR_STRIKETHROUGH", 0x02 }, // Type: lv_text_decor_t
    {0x832b151c, "LV_PART_TEXTAREA_PLACEHOLDER", 0x80000 }, // Type: UNKNOWN_TYPE
    {0x83e3adb9, "LV_FLEX_FLOW_COLUMN", 0x01 }, // Type: lv_flex_flow_t
    {0x86c222f5, "LV_SCALE_MODE_VERTICAL_LEFT", 0x02 }, // Type: lv_scale_mode_t
    {0x8813eb49, "LV_SCROLLBAR_MODE_ACTIVE", 0x02 }, // Type: lv_scrollbar_mode_t
    {0x88c5d304, "LV_STR_SYMBOL_NEW_LINE", 0x3c }, // Type: UNKNOWN_TYPE
    {0x89729d85, "LV_SCALE_MODE_LAST", 0x06 }, // Type: lv_scale_mode_t
    {0x8af639c3, "LV_STR_SYMBOL_SD_CARD", 0x3b }, // Type: UNKNOWN_TYPE
    {0x8f00602d, "LV_STYLE_TEXT_LINE_SPACE", 0x5c }, // Type: UNKNOWN_TYPE
    {0x8f0b08cc, "LV_FLEX_ALIGN_START", 0x00 }, // Type: lv_flex_align_t
    {0x90ad9ada, "LV_BUTTONMATRIX_CTRL_RESERVED_1", 0x1000 }, // Type: lv_buttonmatrix_ctrl_t
    {0x90ad9adb, "LV_BUTTONMATRIX_CTRL_RESERVED_2", 0x2000 }, // Type: lv_buttonmatrix_ctrl_t
    {0x918d5ea8, "LV_ARC_MODE_NORMAL", 0x00 }, // Type: lv_arc_mode_t
    {0x93475002, "LV_STYLE_BG_MAIN_OPA", 0x24 }, // Type: UNKNOWN_TYPE
    {0x9397a0e0, "LV_STR_SYMBOL_SHUFFLE", 0x1e }, // Type: UNKNOWN_TYPE
    {0x940b656b, "LV_STR_SYMBOL_EYE_CLOSE", 0x1c }, // Type: UNKNOWN_TYPE
    {0x9463ee1e, "LV_ALIGN_BOTTOM_MID", 0x05 }, // Type: lv_align_t
    {0x9565443e, "LV_PART_ITEMS", 0x50000 }, // Type: lv_style_parts_t
    {0x95a339b2, "LV_FLEX_ALIGN_SPACE_AROUND", 0x04 }, // Type: lv_flex_align_t
    {0x970b3c6d, "LV_STYLE_FLEX_MAIN_PLACE", 0x7b }, // Type: UNKNOWN_TYPE
    {0x973458c8, "LV_STYLE_PAD_RIGHT", 0x13 }, // Type: UNKNOWN_TYPE
    {0x97946b21, "LV_STYLE_TRANSFORM_ROTATION", 0x70 }, // Type: UNKNOWN_TYPE
    {0x988bcb5c, "LV_STYLE_LINE_COLOR", 0x4c }, // Type: UNKNOWN_TYPE
    {0x99f249bd, "LV_STYLE_LINE_WIDTH", 0x48 }, // Type: UNKNOWN_TYPE
    {0x9dee7b99, "LV_STYLE_MIN_WIDTH", 0x04 }, // Type: UNKNOWN_TYPE
    {0x9f3aa47c, "LV_FLEX_ALIGN_SPACE_EVENLY", 0x03 }, // Type: lv_flex_align_t
    {0x9f469945, "LV_BUTTONMATRIX_CTRL_CLICK_TRIG", 0x200 }, // Type: lv_buttonmatrix_ctrl_t
    {0xa225ad25, "LV_STYLE_BITMAP_MASK_SRC", 0x75 }, // Type: UNKNOWN_TYPE
    {0xa280fe9f, "LV_STR_SYMBOL_CUT", 0x25 }, // Type: UNKNOWN_TYPE
    {0xa2810efd, "LV_STR_SYMBOL_GPS", 0x2e }, // Type: UNKNOWN_TYPE
    {0xa2814add, "LV_STR_SYMBOL_USB", 0x36 }, // Type: UNKNOWN_TYPE
    {0xa4048c85, "LV_STYLE_TEXT_ALIGN", 0x5e }, // Type: UNKNOWN_TYPE
    {0xa41bd11c, "LV_TEXT_DECOR_UNDERLINE", 0x01 }, // Type: lv_text_decor_t
    {0xa42a7079, "LV_STYLE_TEXT_COLOR", 0x58 }, // Type: UNKNOWN_TYPE
    {0xa436e6e7, "LV_STYLE_TEXT_DECOR", 0x5d }, // Type: UNKNOWN_TYPE
    {0xa43738de, "LV_ALIGN_OUT_RIGHT_MID", 0x14 }, // Type: lv_align_t
    {0xa4375777, "LV_ALIGN_OUT_RIGHT_TOP", 0x13 }, // Type: lv_align_t
    {0xa52c1366, "LV_ALIGN_OUT_BOTTOM_LEFT", 0x0d }, // Type: lv_align_t
    {0xa62f26af, "LV_BAR_ORIENTATION_HORIZONTAL", 0x01 }, // Type: lv_bar_orientation_t
    {0xa7024a7a, "LV_GRID_TEMPLATE_LAST", 0x1fffffff }, // Type: MACRO_FROM_STRING_VALUES
    {0xaa3274d3, "LV_ALIGN_OUT_TOP_MID", 0x0b }, // Type: lv_align_t
    {0xaa85609e, "LV_BAR_ORIENTATION_AUTO", 0x00 }, // Type: lv_bar_orientation_t
    {0xabe47739, "LV_SLIDER_MODE_RANGE", 0x02 }, // Type: lv_slider_mode_t
    {0xacaa5bb2, "LV_FLEX_FLOW_COLUMN_WRAP", 0x05 }, // Type: lv_flex_flow_t
    {0xafdb2960, "LV_STYLE_GRID_COLUMN_DSC_ARRAY", 0x82 }, // Type: UNKNOWN_TYPE
    {0xb037867b, "LV_STYLE_OPA_LAYERED", 0x63 }, // Type: UNKNOWN_TYPE
    {0xb1f2e319, "LV_PART_INDICATOR", 0x20000 }, // Type: lv_style_parts_t
    {0xb33769fc, "LV_BUTTONMATRIX_CTRL_CHECKABLE", 0x80 }, // Type: lv_buttonmatrix_ctrl_t
    {0xb447d83d, "LV_STYLE_GRID_ROW_ALIGN", 0x80 }, // Type: UNKNOWN_TYPE
    {0xb54a61a0, "LV_ANIM_REPEAT_INFINITE", 0xffffffff }, // Type: MACRO_FROM_STRING_VALUES
    {0xb5b0423b, "LV_SIZE_CONTENT", 0x3fffffff }, // Type: MACRO_FROM_STRING_VALUES
    {0xb6fa9e09, "LV_STR_SYMBOL_WARNING", 0x1d }, // Type: UNKNOWN_TYPE
    {0xb76c3356, "LV_STYLE_BG_IMAGE_RECOLOR", 0x2a }, // Type: UNKNOWN_TYPE
    {0xb7af8456, "LV_OPA_100", 0xff }, // Type: lv_opa_enum_t
    {0xb7b6b85d, "LV_STYLE_FLEX_TRACK_PLACE", 0x7d }, // Type: UNKNOWN_TYPE
    {0xb8232b50, "LV_STYLE_TRANSFORM_SCALE_X", 0x6e }, // Type: UNKNOWN_TYPE
    {0xb8232b51, "LV_STYLE_TRANSFORM_SCALE_Y", 0x6f }, // Type: UNKNOWN_TYPE
    {0xb9280ba4, "LV_ANIM_PLAYTIME_INFINITE", 0xffffffff }, // Type: MACRO_FROM_STRING_VALUES
    {0xbc40e802, "LV_BUTTONMATRIX_CTRL_DISABLED", 0x40 }, // Type: lv_buttonmatrix_ctrl_t
    {0xc160013d, "LV_STYLE_LINE_OPA", 0x4d }, // Type: UNKNOWN_TYPE
    {0xc1b0f31a, "LV_STYLE_BG_GRAD_COLOR", 0x23 }, // Type: UNKNOWN_TYPE
    {0xc1faeb3b, "LV_SPAN_MODE_EXPAND", 0x01 }, // Type: lv_span_mode_t
    {0xc265c533, "LV_GRID_FR_1", 0x1fffff9c }, // Type: MACRO_FROM_STRING_VALUES
    {0xc265c534, "LV_GRID_FR_2", 0x1fffff9d }, // Type: MACRO_FROM_STRING_VALUES
    {0xc265c535, "LV_GRID_FR_3", 0x1fffff9e }, // Type: MACRO_FROM_STRING_VALUES
    {0xc265c536, "LV_GRID_FR_4", 0x1fffff9f }, // Type: MACRO_FROM_STRING_VALUES
    {0xc265c537, "LV_GRID_FR_5", 0x1fffffa0 }, // Type: MACRO_FROM_STRING_VALUES
    {0xc361cb40, "LV_STYLE_BG_IMAGE_OPA", 0x29 }, // Type: UNKNOWN_TYPE
    {0xc361dc88, "LV_STYLE_BG_IMAGE_SRC", 0x28 }, // Type: UNKNOWN_TYPE
    {0xc3ee6bcc, "LV_SLIDER_ORIENTATION_AUTO", 0x00 }, // Type: lv_slider_orientation_t
    {0xc45585c5, "LV_PART_SELECTED", 0x40000 }, // Type: lv_style_parts_t
    {0xc4730e59, "LV_STYLE_GRID_CELL_COLUMN_POS", 0x83 }, // Type: UNKNOWN_TYPE
    {0xc50c6819, "LV_STYLE_BORDER_POST", 0x35 }, // Type: UNKNOWN_TYPE
    {0xc50df1b8, "LV_STYLE_BORDER_SIDE", 0x34 }, // Type: UNKNOWN_TYPE
    {0xc575d691, "LV_STYLE_TRANSFORM_WIDTH", 0x6a }, // Type: UNKNOWN_TYPE
    {0xc69f62a4, "LV_STR_SYMBOL_KEYBOARD", 0x2d }, // Type: UNKNOWN_TYPE
    {0xc6d9075e, "LV_PART_CUSTOM_FIRST", 0x80000 }, // Type: lv_style_parts_t
    {0xc6fc809f, "LV_BAR_ORIENTATION_VERTICAL", 0x02 }, // Type: lv_bar_orientation_t
    {0xc7008097, "LV_FLEX_FLOW_ROW_WRAP_REVERSE", 0x0c }, // Type: lv_flex_flow_t
    {0xca01bd93, "LV_STYLE_COLOR_FILTER_DSC", 0x64 }, // Type: UNKNOWN_TYPE
    {0xca01ebf9, "LV_STYLE_COLOR_FILTER_OPA", 0x65 }, // Type: UNKNOWN_TYPE
    {0xcb1c7aea, "LV_SCROLLBAR_MODE_ON", 0x01 }, // Type: lv_scrollbar_mode_t
    {0xcb713489, "LV_STR_SYMBOL_BLUETOOTH", 0x37 }, // Type: UNKNOWN_TYPE
    {0xcc9facad, "LV_ALIGN_TOP_LEFT", 0x01 }, // Type: lv_align_t
    {0xcef97b1a, "LV_GRIDNAV_CTRL_SCROLL_FIRST", 0x02 }, // Type: lv_gridnav_ctrl_t
    {0xcf297af4, "LV_STYLE_MAX_HEIGHT", 0x07 }, // Type: UNKNOWN_TYPE
    {0xd02778fb, "LV_STYLE_SHADOW_OPA", 0x3e }, // Type: UNKNOWN_TYPE
    {0xd44fcf2c, "LV_GRID_ALIGN_END", 0x02 }, // Type: lv_grid_align_t
    {0xd59331fb, "LV_STYLE_TRANSLATE_X", 0x6c }, // Type: UNKNOWN_TYPE
    {0xd59331fc, "LV_STYLE_TRANSLATE_Y", 0x6d }, // Type: UNKNOWN_TYPE
    {0xd67874d0, "LV_STYLE_TRANSLATE_RADIAL", 0x77 }, // Type: UNKNOWN_TYPE
    {0xd762d932, "LV_LAYOUT_FLEX", 0x01 }, // Type: lv_layout_t
    {0xd7637f89, "LV_LAYOUT_GRID", 0x02 }, // Type: lv_layout_t
    {0xd765f677, "LV_LAYOUT_LAST", 0x03 }, // Type: lv_layout_t
    {0xd7674a13, "LV_LAYOUT_NONE", 0x00 }, // Type: lv_layout_t
    {0xe012d8db, "LV_ARC_MODE_REVERSE", 0x02 }, // Type: lv_arc_mode_t
    {0xe0b1505a, "LV_STYLE_TRANSFORM_PIVOT_X", 0x71 }, // Type: UNKNOWN_TYPE
    {0xe0b1505b, "LV_STYLE_TRANSFORM_PIVOT_Y", 0x72 }, // Type: UNKNOWN_TYPE
    {0xe1b7f66d, "LV_TABLE_CELL_CTRL_MERGE_RIGHT", 0x01 }, // Type: lv_table_cell_ctrl_t
    {0xe1d6b213, "LV_STYLE_GRID_COLUMN_ALIGN", 0x7f }, // Type: UNKNOWN_TYPE
    {0xe2b98a2f, "LV_SPAN_OVERFLOW_ELLIPSIS", 0x01 }, // Type: lv_span_overflow_t
    {0xe41126d0, "LV_TABLE_CELL_CTRL_NONE", 0x00 }, // Type: lv_table_cell_ctrl_t
    {0xe5e4e26d, "LV_STR_SYMBOL_OK", 0x04 }, // Type: UNKNOWN_TYPE
    {0xe5e4e338, "LV_STR_SYMBOL_UP", 0x1f }, // Type: UNKNOWN_TYPE
    {0xe64bc046, "LV_STYLE_CLIP_CORNER", 0x2d }, // Type: UNKNOWN_TYPE
    {0xe860b68b, "LV_BAR_MODE_RANGE", 0x02 }, // Type: lv_bar_mode_t
    {0xe9ec0f5e, "LV_STYLE_BG_OPA", 0x1d }, // Type: UNKNOWN_TYPE
    {0xe9f6a4fd, "LV_OPA_TRANSP", 0x00 }, // Type: lv_opa_enum_t
    {0xeb15edf1, "LV_STR_SYMBOL_ENVELOPE", 0x29 }, // Type: UNKNOWN_TYPE
    {0xeb2f3352, "LV_TEXT_ALIGN_RIGHT", 0x03 }, // Type: lv_text_align_t
    {0xec228747, "LV_BAR_MODE_NORMAL", 0x00 }, // Type: lv_bar_mode_t
    {0xed0f58c9, "LV_STYLE_RADIAL_OFFSET", 0x0d }, // Type: UNKNOWN_TYPE
    {0xed20cfad, "LV_FLEX_FLOW_COLUMN_WRAP_REVERSE", 0x0d }, // Type: lv_flex_flow_t
    {0xed4f6cd5, "LV_BUTTONMATRIX_CTRL_POPOVER", 0x400 }, // Type: lv_buttonmatrix_ctrl_t
    {0xf06cb8ec, "LV_STYLE_RECOLOR", 0x78 }, // Type: UNKNOWN_TYPE
    {0xf0807264, "LV_ALIGN_OUT_TOP_LEFT", 0x0a }, // Type: lv_align_t
    {0xf142f5d6, "LV_STYLE_OPA", 0x62 }, // Type: UNKNOWN_TYPE
    {0xf22a932b, "LV_STYLE_ARC_OPA", 0x53 }, // Type: UNKNOWN_TYPE
    {0xf26f92d9, "LV_GRIDNAV_CTRL_ROLLOVER", 0x01 }, // Type: lv_gridnav_ctrl_t
    {0xf29ff11b, "LV_STR_SYMBOL_BARS", 0x28 }, // Type: UNKNOWN_TYPE
    {0xf2a00152, "LV_STR_SYMBOL_BELL", 0x2c }, // Type: UNKNOWN_TYPE
    {0xf2a07caf, "LV_STR_SYMBOL_CALL", 0x24 }, // Type: UNKNOWN_TYPE
    {0xf2a0b8ce, "LV_STR_SYMBOL_COPY", 0x26 }, // Type: UNKNOWN_TYPE
    {0xf2a1460b, "LV_STR_SYMBOL_DOWN", 0x20 }, // Type: UNKNOWN_TYPE
    {0xf2a1a1d9, "LV_STR_SYMBOL_EDIT", 0x39 }, // Type: UNKNOWN_TYPE
    {0xf2a243d3, "LV_STR_SYMBOL_FILE", 0x2f }, // Type: UNKNOWN_TYPE
    {0xf2a3763c, "LV_STR_SYMBOL_HOME", 0x08 }, // Type: UNKNOWN_TYPE
    {0xf2a57c5e, "LV_STR_SYMBOL_LEFT", 0x17 }, // Type: UNKNOWN_TYPE
    {0xf2a58f0f, "LV_STR_SYMBOL_LIST", 0x03 }, // Type: UNKNOWN_TYPE
    {0xf2a5a80d, "LV_STR_SYMBOL_LOOP", 0x21 }, // Type: UNKNOWN_TYPE
    {0xf2a64e8e, "LV_STR_SYMBOL_MUTE", 0x0c }, // Type: UNKNOWN_TYPE
    {0xf2a69772, "LV_STR_SYMBOL_NEXT", 0x15 }, // Type: UNKNOWN_TYPE
    {0xf2a7cb09, "LV_STR_SYMBOL_PLAY", 0x12 }, // Type: UNKNOWN_TYPE
    {0xf2a7cd97, "LV_STR_SYMBOL_PLUS", 0x19 }, // Type: UNKNOWN_TYPE
    {0xf2a7e510, "LV_STR_SYMBOL_PREV", 0x11 }, // Type: UNKNOWN_TYPE
    {0xf2a94402, "LV_STR_SYMBOL_SAVE", 0x27 }, // Type: UNKNOWN_TYPE
    {0xf2a993f9, "LV_STR_SYMBOL_STOP", 0x14 }, // Type: UNKNOWN_TYPE
    {0xf2a9f172, "LV_STR_SYMBOL_TINT", 0x10 }, // Type: UNKNOWN_TYPE
    {0xf2ab9582, "LV_STR_SYMBOL_WIFI", 0x30 }, // Type: UNKNOWN_TYPE
    {0xf37869b1, "LV_BUTTONMATRIX_CTRL_CHECKED", 0x100 }, // Type: lv_buttonmatrix_ctrl_t
    {0xf50dbe95, "LV_STYLE_PAD_LEFT", 0x12 }, // Type: UNKNOWN_TYPE
    {0xf695560e, "LV_STYLE_X", 0x08 }, // Type: UNKNOWN_TYPE
    {0xf695560f, "LV_STYLE_Y", 0x09 }, // Type: UNKNOWN_TYPE
    {0xf6d7364b, "LV_TABLE_CELL_CTRL_CUSTOM_1", 0x10 }, // Type: lv_table_cell_ctrl_t
    {0xf6d7364c, "LV_TABLE_CELL_CTRL_CUSTOM_2", 0x20 }, // Type: lv_table_cell_ctrl_t
    {0xf6d7364d, "LV_TABLE_CELL_CTRL_CUSTOM_3", 0x40 }, // Type: lv_table_cell_ctrl_t
    {0xf6d7364e, "LV_TABLE_CELL_CTRL_CUSTOM_4", 0x80 }, // Type: lv_table_cell_ctrl_t
    {0xf711719f, "LV_STYLE_BLEND_MODE", 0x69 }, // Type: UNKNOWN_TYPE
    {0xf7ba9ecf, "LV_STYLE_HEIGHT", 0x02 }, // Type: UNKNOWN_TYPE
    {0xf8f338b4, "LV_FLEX_FLOW_COLUMN_REVERSE", 0x09 }, // Type: lv_flex_flow_t
    {0xf95181da, "LV_BUTTONMATRIX_CTRL_WIDTH_1", 0x01 }, // Type: lv_buttonmatrix_ctrl_t
    {0xf95181db, "LV_BUTTONMATRIX_CTRL_WIDTH_2", 0x02 }, // Type: lv_buttonmatrix_ctrl_t
    {0xf95181dc, "LV_BUTTONMATRIX_CTRL_WIDTH_3", 0x03 }, // Type: lv_buttonmatrix_ctrl_t
    {0xf95181dd, "LV_BUTTONMATRIX_CTRL_WIDTH_4", 0x04 }, // Type: lv_buttonmatrix_ctrl_t
    {0xf95181de, "LV_BUTTONMATRIX_CTRL_WIDTH_5", 0x05 }, // Type: lv_buttonmatrix_ctrl_t
    {0xf95181df, "LV_BUTTONMATRIX_CTRL_WIDTH_6", 0x06 }, // Type: lv_buttonmatrix_ctrl_t
    {0xf95181e0, "LV_BUTTONMATRIX_CTRL_WIDTH_7", 0x07 }, // Type: lv_buttonmatrix_ctrl_t
    {0xf95181e1, "LV_BUTTONMATRIX_CTRL_WIDTH_8", 0x08 }, // Type: lv_buttonmatrix_ctrl_t
    {0xf95181e2, "LV_BUTTONMATRIX_CTRL_WIDTH_9", 0x09 }, // Type: lv_buttonmatrix_ctrl_t
    {0xfc18831d, "LV_STYLE_PROP_CONST", 0xff }, // Type: UNKNOWN_TYPE
    {0xfc3394e8, "LV_STYLE_BG_MAIN_STOP", 0x21 }, // Type: UNKNOWN_TYPE
    {0xfdc4c29c, "LV_FLEX_FLOW_ROW_WRAP", 0x04 }, // Type: lv_flex_flow_t
    {0xff50a7f5, "LV_STYLE_TEXT_LETTER_SPACE", 0x5b }, // Type: UNKNOWN_TYPE
    {0xffeb5c5d, "LV_SLIDER_ORIENTATION_HORIZONTAL", 0x01 }, // Type: lv_slider_orientation_t
};
#define G_GENERATED_ENUM_TABLE_SIZE (sizeof(g_generated_enum_table) / sizeof(g_generated_enum_table[0]))

// Comparator for bsearch on g_generated_enum_table (compares only hash for initial range find)
static int compare_generated_enum_hash(const void *key_hash_ptr, const void *element_ptr) {
    uint32_t key_hash = *(const uint32_t*)key_hash_ptr;
    const generated_enum_entry_t *element = (const generated_enum_entry_t *)element_ptr;
    if (key_hash < element->hash) return -1;
    if (key_hash > element->hash) return 1;
    return 0; // Hashes match
}

// Main enum unmarshaling function
static bool unmarshal_enum_value(cJSON *json_value, const char *expected_enum_type_name, int *dest) {
    if (!json_value || !dest) return false;

    // Allow integer values directly for enums
    if(cJSON_IsNumber(json_value)) {
        *dest = (int)json_value->valuedouble;
        return true;
    }

    if (!cJSON_IsString(json_value) || !json_value->valuestring) {
       LOG_ERR_JSON(json_value, "Enum Unmarshal Error: Expected string or number for enum type '%s', got type %d", expected_enum_type_name ? expected_enum_type_name : "unknown", json_value->type);
       return false;
    }
    const char *str_value = json_value->valuestring;
    uint32_t input_hash = djb2_hash_c(str_value);

    // 1. Search user-defined table first (allows overriding generated)
    for (size_t i = 0; i < g_num_user_enums; ++i) {
        if (g_user_enum_table[i].hash == input_hash) {
            if (strcmp(g_user_enum_table[i].name, str_value) == 0) {
                *dest = g_user_enum_table[i].value;
                return true;
            }
        }
    }

    // 2. Search generated table using bsearch + strcmp for collisions
    if (G_GENERATED_ENUM_TABLE_SIZE > 0) { // Only search if table is not empty
        const generated_enum_entry_t *found_any_hash_match = (const generated_enum_entry_t *)bsearch(
            &input_hash,
            g_generated_enum_table,
            G_GENERATED_ENUM_TABLE_SIZE,
            sizeof(generated_enum_entry_t),
            compare_generated_enum_hash);

        if (found_any_hash_match) {
            // bsearch found an element with matching hash. Now check original_name for exact match.
            // Since table is sorted by hash then name, all collisions are contiguous.
            // Iterate backwards from found_any_hash_match.
            const generated_enum_entry_t *current_entry = found_any_hash_match;
            while (current_entry >= g_generated_enum_table && current_entry->hash == input_hash) {
                if (strcmp(current_entry->original_name, str_value) == 0) {
                    // Optional: Check if current_entry->original_type_name matches expected_enum_type_name if type safety is critical
                    *dest = current_entry->c_value;
                    return true;
                }
                // Optimization: if original_name is already "lesser" than str_value (and table is sorted by name within hash groups), we can stop early for this direction
                // but simple iteration is fine.
                if (current_entry == g_generated_enum_table) break; // Boundary condition for first element
                current_entry--;
            }

            // Iterate forwards from found_any_hash_match + 1 (found_any_hash_match itself was checked or was part of backward scan if it was the first match)
            current_entry = found_any_hash_match + 1;
            while (current_entry < (g_generated_enum_table + G_GENERATED_ENUM_TABLE_SIZE) && current_entry->hash == input_hash) {
                if (strcmp(current_entry->original_name, str_value) == 0) {
                    *dest = current_entry->c_value;
                    return true;
                }
                current_entry++;
            }
        }
    }

    LOG_ERR_JSON(json_value, "Enum Unmarshal Error: Unknown string value '%s' for enum type '%s' (hash 0x%08x)", str_value, expected_enum_type_name ? expected_enum_type_name : "unknown", input_hash);
    return false;
}



// --- Macro Values JSON Exporter ---

// Helper to check if a name is a known generated enum member
static bool is_name_an_enum(const char *name_to_check) {
    if (!name_to_check) return false;
    // Ensure djb2_hash_c and compare_generated_enum_hash are available (defined earlier as static)
    uint32_t input_hash = djb2_hash_c(name_to_check);

    if (G_GENERATED_ENUM_TABLE_SIZE == 0) return false; // No enums to check against

    const generated_enum_entry_t *entry_ptr = (const generated_enum_entry_t *)bsearch(
        &input_hash,
        g_generated_enum_table,
        G_GENERATED_ENUM_TABLE_SIZE,
        sizeof(generated_enum_entry_t),
        compare_generated_enum_hash);

    if (!entry_ptr) return false; // No matching hash

    // Hash matches, now check name. Collisions are contiguous.
    // Go to the start of the hash collision block
    while (entry_ptr > g_generated_enum_table && (entry_ptr - 1)->hash == input_hash) {
        entry_ptr--;
    }
    // Iterate through all entries with the same hash
    while (entry_ptr < (g_generated_enum_table + G_GENERATED_ENUM_TABLE_SIZE) && entry_ptr->hash == input_hash) {
        if (strcmp(entry_ptr->original_name, name_to_check) == 0) {
            return true; // Exact name match
        }
        entry_ptr++;
    }
    return false; // Hash matched, but no exact name match in collision group
}


char* lvgl_json_generate_values_json(void) {
    cJSON *json_root = cJSON_CreateObject();
    if (!json_root) {
        LOG_ERR("Failed to create cJSON root for macro values.");
        return NULL;
    }

    #ifdef LV_SIZE_CONTENT
    if (!is_name_an_enum("LV_SIZE_CONTENT")) {
        cJSON_AddNumberToObject(json_root, "LV_SIZE_CONTENT", (double)(LV_SIZE_CONTENT));
    }
    #else
    // LOG_DEBUG("Macro LV_SIZE_CONTENT not defined, skipped for JSON output.");
    #endif // LV_SIZE_CONTENT

    #ifdef LV_COORD_MAX
    if (!is_name_an_enum("LV_COORD_MAX")) {
        cJSON_AddNumberToObject(json_root, "LV_COORD_MAX", (double)(LV_COORD_MAX));
    }
    #else
    // LOG_DEBUG("Macro LV_COORD_MAX not defined, skipped for JSON output.");
    #endif // LV_COORD_MAX

    #ifdef LV_COORD_MIN
    if (!is_name_an_enum("LV_COORD_MIN")) {
        cJSON_AddNumberToObject(json_root, "LV_COORD_MIN", (double)(LV_COORD_MIN));
    }
    #else
    // LOG_DEBUG("Macro LV_COORD_MIN not defined, skipped for JSON output.");
    #endif // LV_COORD_MIN

    #ifdef LV_GRID_CONTENT
    if (!is_name_an_enum("LV_GRID_CONTENT")) {
        cJSON_AddNumberToObject(json_root, "LV_GRID_CONTENT", (double)(LV_GRID_CONTENT));
    }
    #else
    // LOG_DEBUG("Macro LV_GRID_CONTENT not defined, skipped for JSON output.");
    #endif // LV_GRID_CONTENT

    #ifdef LV_FLEX_CONTENT
    if (!is_name_an_enum("LV_FLEX_CONTENT")) {
        cJSON_AddNumberToObject(json_root, "LV_FLEX_CONTENT", (double)(LV_FLEX_CONTENT));
    }
    #else
    // LOG_DEBUG("Macro LV_FLEX_CONTENT not defined, skipped for JSON output.");
    #endif // LV_FLEX_CONTENT

    #ifdef LV_CHART_POINT_NONE
    if (!is_name_an_enum("LV_CHART_POINT_NONE")) {
        cJSON_AddNumberToObject(json_root, "LV_CHART_POINT_NONE", (double)(LV_CHART_POINT_NONE));
    }
    #else
    // LOG_DEBUG("Macro LV_CHART_POINT_NONE not defined, skipped for JSON output.");
    #endif // LV_CHART_POINT_NONE

    #ifdef LV_RADIUS_CIRCLE
    if (!is_name_an_enum("LV_RADIUS_CIRCLE")) {
        cJSON_AddNumberToObject(json_root, "LV_RADIUS_CIRCLE", (double)(LV_RADIUS_CIRCLE));
    }
    #else
    // LOG_DEBUG("Macro LV_RADIUS_CIRCLE not defined, skipped for JSON output.");
    #endif // LV_RADIUS_CIRCLE

    #ifdef LV_IMG_ZOOM_NONE
    if (!is_name_an_enum("LV_IMG_ZOOM_NONE")) {
        cJSON_AddNumberToObject(json_root, "LV_IMG_ZOOM_NONE", (double)(LV_IMG_ZOOM_NONE));
    }
    #else
    // LOG_DEBUG("Macro LV_IMG_ZOOM_NONE not defined, skipped for JSON output.");
    #endif // LV_IMG_ZOOM_NONE

    #ifdef LV_BTNMATRIX_BTN_ID_NONE
    if (!is_name_an_enum("LV_BTNMATRIX_BTN_ID_NONE")) {
        cJSON_AddNumberToObject(json_root, "LV_BTNMATRIX_BTN_ID_NONE", (double)(LV_BTNMATRIX_BTN_ID_NONE));
    }
    #else
    // LOG_DEBUG("Macro LV_BTNMATRIX_BTN_ID_NONE not defined, skipped for JSON output.");
    #endif // LV_BTNMATRIX_BTN_ID_NONE

    #ifdef LV_ANIM_REPEAT_INFINITE
    if (!is_name_an_enum("LV_ANIM_REPEAT_INFINITE")) {
        cJSON_AddNumberToObject(json_root, "LV_ANIM_REPEAT_INFINITE", (double)(LV_ANIM_REPEAT_INFINITE));
    }
    #else
    // LOG_DEBUG("Macro LV_ANIM_REPEAT_INFINITE not defined, skipped for JSON output.");
    #endif // LV_ANIM_REPEAT_INFINITE

    #ifdef LV_ANIM_PLAYTIME_INFINITE
    if (!is_name_an_enum("LV_ANIM_PLAYTIME_INFINITE")) {
        cJSON_AddNumberToObject(json_root, "LV_ANIM_PLAYTIME_INFINITE", (double)(LV_ANIM_PLAYTIME_INFINITE));
    }
    #else
    // LOG_DEBUG("Macro LV_ANIM_PLAYTIME_INFINITE not defined, skipped for JSON output.");
    #endif // LV_ANIM_PLAYTIME_INFINITE

    #ifdef LV_OPA_TRANSP
    if (!is_name_an_enum("LV_OPA_TRANSP")) {
        cJSON_AddNumberToObject(json_root, "LV_OPA_TRANSP", (double)(LV_OPA_TRANSP));
    }
    #else
    // LOG_DEBUG("Macro LV_OPA_TRANSP not defined, skipped for JSON output.");
    #endif // LV_OPA_TRANSP

    #ifdef LV_OPA_COVER
    if (!is_name_an_enum("LV_OPA_COVER")) {
        cJSON_AddNumberToObject(json_root, "LV_OPA_COVER", (double)(LV_OPA_COVER));
    }
    #else
    // LOG_DEBUG("Macro LV_OPA_COVER not defined, skipped for JSON output.");
    #endif // LV_OPA_COVER

    #ifdef LV_ALIGN_DEFAULT
    if (!is_name_an_enum("LV_ALIGN_DEFAULT")) {
        cJSON_AddNumberToObject(json_root, "LV_ALIGN_DEFAULT", (double)(LV_ALIGN_DEFAULT));
    }
    #else
    // LOG_DEBUG("Macro LV_ALIGN_DEFAULT not defined, skipped for JSON output.");
    #endif // LV_ALIGN_DEFAULT

    #ifdef LV_ALIGN_CENTER
    if (!is_name_an_enum("LV_ALIGN_CENTER")) {
        cJSON_AddNumberToObject(json_root, "LV_ALIGN_CENTER", (double)(LV_ALIGN_CENTER));
    }
    #else
    // LOG_DEBUG("Macro LV_ALIGN_CENTER not defined, skipped for JSON output.");
    #endif // LV_ALIGN_CENTER

    #ifdef LV_ALIGN_OUT_TOP_LEFT
    if (!is_name_an_enum("LV_ALIGN_OUT_TOP_LEFT")) {
        cJSON_AddNumberToObject(json_root, "LV_ALIGN_OUT_TOP_LEFT", (double)(LV_ALIGN_OUT_TOP_LEFT));
    }
    #else
    // LOG_DEBUG("Macro LV_ALIGN_OUT_TOP_LEFT not defined, skipped for JSON output.");
    #endif // LV_ALIGN_OUT_TOP_LEFT

    #ifdef LV_STATE_DEFAULT
    if (!is_name_an_enum("LV_STATE_DEFAULT")) {
        cJSON_AddNumberToObject(json_root, "LV_STATE_DEFAULT", (double)(LV_STATE_DEFAULT));
    }
    #else
    // LOG_DEBUG("Macro LV_STATE_DEFAULT not defined, skipped for JSON output.");
    #endif // LV_STATE_DEFAULT

    #ifdef LV_STATE_FOCUSED
    if (!is_name_an_enum("LV_STATE_FOCUSED")) {
        cJSON_AddNumberToObject(json_root, "LV_STATE_FOCUSED", (double)(LV_STATE_FOCUSED));
    }
    #else
    // LOG_DEBUG("Macro LV_STATE_FOCUSED not defined, skipped for JSON output.");
    #endif // LV_STATE_FOCUSED

    #ifdef LV_STATE_ANY
    if (!is_name_an_enum("LV_STATE_ANY")) {
        cJSON_AddNumberToObject(json_root, "LV_STATE_ANY", (double)(LV_STATE_ANY));
    }
    #else
    // LOG_DEBUG("Macro LV_STATE_ANY not defined, skipped for JSON output.");
    #endif // LV_STATE_ANY

    #ifdef LV_PART_MAIN
    if (!is_name_an_enum("LV_PART_MAIN")) {
        cJSON_AddNumberToObject(json_root, "LV_PART_MAIN", (double)(LV_PART_MAIN));
    }
    #else
    // LOG_DEBUG("Macro LV_PART_MAIN not defined, skipped for JSON output.");
    #endif // LV_PART_MAIN

    #ifdef LV_PART_ANY
    if (!is_name_an_enum("LV_PART_ANY")) {
        cJSON_AddNumberToObject(json_root, "LV_PART_ANY", (double)(LV_PART_ANY));
    }
    #else
    // LOG_DEBUG("Macro LV_PART_ANY not defined, skipped for JSON output.");
    #endif // LV_PART_ANY

    #ifdef LV_GRID_TEMPLATE_LAST
    if (!is_name_an_enum("LV_GRID_TEMPLATE_LAST")) {
        cJSON_AddNumberToObject(json_root, "LV_GRID_TEMPLATE_LAST", (double)(LV_GRID_TEMPLATE_LAST));
    }
    #else
    // LOG_DEBUG("Macro LV_GRID_TEMPLATE_LAST not defined, skipped for JSON output.");
    #endif // LV_GRID_TEMPLATE_LAST

    #ifdef LV_GRID_FR_1
    if (!is_name_an_enum("LV_GRID_FR_1")) {
        cJSON_AddNumberToObject(json_root, "LV_GRID_FR_1", (double)(LV_GRID_FR_1));
    }
    #else
    // LOG_DEBUG("Macro LV_GRID_FR_1 not defined, skipped for JSON output.");
    #endif // LV_GRID_FR_1

    #ifdef LV_GRID_FR_2
    if (!is_name_an_enum("LV_GRID_FR_2")) {
        cJSON_AddNumberToObject(json_root, "LV_GRID_FR_2", (double)(LV_GRID_FR_2));
    }
    #else
    // LOG_DEBUG("Macro LV_GRID_FR_2 not defined, skipped for JSON output.");
    #endif // LV_GRID_FR_2

    #ifdef LV_GRID_FR_3
    if (!is_name_an_enum("LV_GRID_FR_3")) {
        cJSON_AddNumberToObject(json_root, "LV_GRID_FR_3", (double)(LV_GRID_FR_3));
    }
    #else
    // LOG_DEBUG("Macro LV_GRID_FR_3 not defined, skipped for JSON output.");
    #endif // LV_GRID_FR_3

    #ifdef LV_GRID_FR_4
    if (!is_name_an_enum("LV_GRID_FR_4")) {
        cJSON_AddNumberToObject(json_root, "LV_GRID_FR_4", (double)(LV_GRID_FR_4));
    }
    #else
    // LOG_DEBUG("Macro LV_GRID_FR_4 not defined, skipped for JSON output.");
    #endif // LV_GRID_FR_4

    #ifdef LV_GRID_FR_5
    if (!is_name_an_enum("LV_GRID_FR_5")) {
        cJSON_AddNumberToObject(json_root, "LV_GRID_FR_5", (double)(LV_GRID_FR_5));
    }
    #else
    // LOG_DEBUG("Macro LV_GRID_FR_5 not defined, skipped for JSON output.");
    #endif // LV_GRID_FR_5

    #ifdef LV_GRID_FR_10
    if (!is_name_an_enum("LV_GRID_FR_10")) {
        cJSON_AddNumberToObject(json_root, "LV_GRID_FR_10", (double)(LV_GRID_FR_10));
    }
    #else
    // LOG_DEBUG("Macro LV_GRID_FR_10 not defined, skipped for JSON output.");
    #endif // LV_GRID_FR_10

    char *json_string = cJSON_PrintUnformatted(json_root);
    cJSON_Delete(json_root);

    if (!json_string) {
        LOG_ERR("Failed to print cJSON object for macro values.");
        char *err_str = (char*)LV_MALLOC(30); // Use LV_MALLOC
        if(err_str) snprintf(err_str, 30, "{{\"error\":\"print_failed\"}}");
        else { /* Malloc failed, cannot report error string */ }
        return err_str; // Caller still uses cJSON_free or lv_free
    }
    return json_string; // Caller must cJSON_free() this (or lv_free if cJSON uses lv_mem).
}

// --- Primitive Unmarshalers ---
// --- Primitive Unmarshalers ---

static bool unmarshal_int(cJSON *node, int *dest) {
    if (!cJSON_IsNumber(node)) { LOG_ERR_JSON(node, "Expected number for int"); return false; }
    *dest = (int)node->valuedouble;
    // TODO: Add range check for int?
    return true;
}

static bool unmarshal_int8(cJSON *node, int8_t *dest) {
    if (!cJSON_IsNumber(node)) { LOG_ERR_JSON(node, "Expected number for int8_t"); return false; }
    *dest = (int8_t)node->valuedouble;
    // TODO: Add range check for int8_t?
    return true;
}

static bool unmarshal_uint8(cJSON *node, uint8_t *dest) {
    if (!cJSON_IsNumber(node)) { LOG_ERR_JSON(node, "Expected number for uint8_t"); return false; }
    *dest = (uint8_t)node->valuedouble;
    // TODO: Add range check for uint8_t?
    return true;
}

static bool unmarshal_int16(cJSON *node, int16_t *dest) {
    if (!cJSON_IsNumber(node)) { LOG_ERR_JSON(node, "Expected number for int16_t"); return false; }
    *dest = (int16_t)node->valuedouble;
    // TODO: Add range check for int16_t?
    return true;
}

static bool unmarshal_uint16(cJSON *node, uint16_t *dest) {
    if (!cJSON_IsNumber(node)) { LOG_ERR_JSON(node, "Expected number for uint16_t"); return false; }
    *dest = (uint16_t)node->valuedouble;
    // TODO: Add range check for uint16_t?
    return true;
}

static bool unmarshal_int32(cJSON *node, int32_t *dest) {
    if (!cJSON_IsNumber(node)) { LOG_ERR_JSON(node, "Expected number for int32_t"); return false; }
    *dest = (int32_t)node->valuedouble;
    // TODO: Add range check for int32_t?
    return true;
}

static bool unmarshal_uint32(cJSON *node, uint32_t *dest) {
    if (!cJSON_IsNumber(node)) { LOG_ERR_JSON(node, "Expected number for uint32_t"); return false; }
    *dest = (uint32_t)node->valuedouble;
    // TODO: Add range check for uint32_t?
    return true;
}

static bool unmarshal_int64(cJSON *node, int64_t *dest) {
    if (!cJSON_IsNumber(node)) { LOG_ERR_JSON(node, "Expected number for int64_t"); return false; }
    *dest = (int64_t)node->valuedouble;
    // TODO: Add range check for int64_t?
    return true;
}

static bool unmarshal_uint64(cJSON *node, uint64_t *dest) {
    if (!cJSON_IsNumber(node)) { LOG_ERR_JSON(node, "Expected number for uint64_t"); return false; }
    *dest = (uint64_t)node->valuedouble;
    // TODO: Add range check for uint64_t?
    return true;
}

static bool unmarshal_size_t(cJSON *node, size_t *dest) {
    if (!cJSON_IsNumber(node)) { LOG_ERR_JSON(node, "Expected number for size_t"); return false; }
    *dest = (size_t)node->valuedouble;
    // TODO: Add range check for size_t?
    return true;
}

static bool unmarshal_opa(cJSON *node, lv_opa_t *dest) {
    if (!cJSON_IsNumber(node)) { LOG_ERR_JSON(node, "Expected number for lv_opa_t"); return false; }
    *dest = (lv_opa_t)node->valuedouble;
    // TODO: Add range check for lv_opa_t?
    return true;
}

static bool unmarshal_float(cJSON *node, float *dest) {
    if (!cJSON_IsNumber(node)) { LOG_ERR_JSON(node, "Expected number for float"); return false; }
    *dest = (float)node->valuedouble;
    return true;
}

static bool unmarshal_double(cJSON *node, double *dest) {
    if (!cJSON_IsNumber(node)) { LOG_ERR_JSON(node, "Expected number for double"); return false; }
    *dest = (double)node->valuedouble;
    return true;
}

static bool unmarshal_bool(cJSON *node, bool *dest) {
    if (!cJSON_IsBool(node)) { LOG_ERR_JSON(node, "Expected boolean"); return false; }
    *dest = cJSON_IsTrue(node);
    return true;
}

static bool unmarshal_string_ptr(cJSON *node, const char **dest) {
    if (!cJSON_IsString(node)) { LOG_ERR_JSON(node, "Expected string"); return false; }
    *dest = node->valuestring;
    return true;
}

static bool unmarshal_char(cJSON *node, char *dest) {
    if (cJSON_IsString(node) && node->valuestring && node->valuestring[0] != '\0') { *dest = node->valuestring[0]; return true; }
    if (cJSON_IsNumber(node)) { *dest = (char)node->valuedouble; return true; }
    LOG_ERR_JSON(node, "Expected single-character string or number for char");
    return false;
}



// --- Coordinate (lv_coord_t) Unmarshaler ---
// --- Coordinate (lv_coord_t) Unmarshaler ---

// We assume lv_pct(int32_t) returns lv_coord_t (or compatible)
extern lv_coord_t lv_pct(int32_t v);

static bool unmarshal_coord(cJSON *node, lv_coord_t *dest) {
    if (!node || !dest) return false;

    // Try as number first
    if (cJSON_IsNumber(node)) {
        *dest = (lv_coord_t)node->valuedouble;
        // TODO: Add range check for lv_coord_t?
        return true;
    }

    // Try as percentage string "N%"
    if (cJSON_IsString(node) && node->valuestring) {
        const char *str = node->valuestring;
        size_t len = strlen(str);
        if (len > 2 && str[len - 1] == '%') {
            // Found '%', try parsing the number part
            // Create a temporary null-terminated string for the number part
            char num_part[32]; // Should be large enough for typical percentages
            size_t num_len = len - 1;
            if (num_len >= sizeof(num_part)) num_len = sizeof(num_part) - 1;
            strncpy(num_part, str, num_len);
            num_part[num_len] = '\0';

            // Parse the number (long is safe enough for int32_t)
            char *endptr;
            long val = strtol(num_part, &endptr, 10);

            // Check if parsing was successful (endptr should point to the null terminator)
            if (*endptr == '\0') {
                *dest = lv_pct((int32_t)val);
                return true;
            } else {
                LOG_ERR_JSON(node, "Coord Unmarshal Error: Invalid number format in percentage string '%s'", str);
                return false;
            }
        }
    }

    // If not a number or valid percentage string
    LOG_ERR_JSON(node, "Coord Unmarshal Error: Expected number or percentage string ('N%%') for lv_coord_t, got type %d", node->type);
    return false;
}



// --- Custom Unmarshalers (#color, @ptr) ---
// --- Custom Unmarshalers ---

static bool unmarshal_color(cJSON *node, lv_color_t *dest) {
    if (!cJSON_IsString(node) || !node->valuestring || node->valuestring[0] != '#') { LOG_ERR_JSON(node, "Expected color string starting with #"); return false; }
    const char *hex_str = node->valuestring + 1;
    uint32_t hex_val = (uint32_t)strtoul(hex_str, NULL, 16);
    // Assuming lv_color_hex handles 6-digit (RRGGBB) correctly.
    // LVGL's lv_color_hex might ignore alpha if present.
    if (strlen(hex_str) == 6 || strlen(hex_str) == 8) { // Accept RRGGBB or AARRGGBB
       *dest = lv_color_hex(hex_val & 0xFFFFFF); // Mask out potential alpha for lv_color_hex
       return true;
    } else if (strlen(hex_str) == 3) { // Handle #RGB shorthand -> #RRGGBB
        unsigned int r = (hex_val >> 8) & 0xF;
        unsigned int g = (hex_val >> 4) & 0xF;
        unsigned int b = hex_val & 0xF;
        *dest = lv_color_hex( (r << 20 | r << 16) | (g << 12 | g << 8) | (b << 4 | b) );
        return true;
    }
    LOG_ERR_JSON(node, "Color Unmarshal Error: Invalid hex format '%s'. Expected #RGB, #RRGGBB.", node->valuestring);
    return false;
}

// Forward declaration
extern void* lvgl_json_get_registered_ptr(const char *name, const char *expected_type_name);

static bool unmarshal_registered_ptr(cJSON *node, const char *expected_ptr_type, void **dest) {
    if (!cJSON_IsString(node) || !node->valuestring || node->valuestring[0] != '@') { LOG_ERR_JSON(node, "Expected pointer string starting with @"); return false; }
    const char *name = node->valuestring + 1;
    *dest = lvgl_json_get_registered_ptr(name, expected_ptr_type);
    if (!(*dest)) {
       return false;
    }
    return true;
}



// --- Forward declaration needed by invocation helpers ---
static const invoke_table_entry_t* find_invoke_entry(const char *name);
static bool unmarshal_value(cJSON *json_value, const char *expected_c_type, void *dest);

// --- Invocation Helper Functions ---
// Forward declaration for the main unmarshaler
static bool unmarshal_value(cJSON *json_value, const char *expected_c_type, void *dest);

struct invoke_table_entry_s;
typedef struct invoke_table_entry_s invoke_table_entry_t;

// --- Invocation Helper Functions ---
// Specific Invoker for functions like lv_widget_create(lv_obj_t *parent)
// Signature: expects target_obj_ptr = parent, dest = lv_obj_t**, args_array = NULL
static bool invoke_widget_create(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr) { LOG_ERR("Invoke Error: NULL entry or func_ptr for invoke_widget_create"); return false; }
    if (!dest) { LOG_ERR("Invoke Error: dest is NULL for invoke_widget_create (needed for result)"); return false; }
    // Although args_array should be NULL, add a warning if it's not.
    if (args_array != NULL && cJSON_GetArraySize(args_array) > 0) {
       LOG_WARN_JSON(args_array, "Invoke Warning: invoke_widget_create expected 0 JSON args, got %d for func '%s'. Ignoring JSON args.", cJSON_GetArraySize(args_array), entry->name);
    }

    lv_obj_t* parent = (lv_obj_t*)target_obj_ptr;
    // Define the specific function pointer type (always lv_obj_t*(lv_obj_t*) for this invoker)
    typedef lv_obj_t* (*specific_lv_create_func_type)(lv_obj_t*);
    specific_lv_create_func_type target_func = (specific_lv_create_func_type)entry->func_ptr;

    // Call the target LVGL create function
    lv_obj_t* result = target_func(parent);

    // Store result widget pointer into *dest
    *(lv_obj_t**)dest = result;

    if (!result) {
        LOG_WARN("Invoke Warning: Create function '%s' returned NULL.", entry->name);
        // Return true because the invoker itself succeeded.
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL',)
// Handles 2 functions like 'lv_is_initialized'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t result_buf;

    // Expecting 0 arguments from JSON array for function '{'name': 'lv_is_initialized', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': None, 'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg', 'quals': []}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': []}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_BOOL", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func();

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'INT')
// Handles 2 functions like 'lv_color_format_has_alpha'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    int64_t result_buf;

    // Expecting 1 arguments from JSON array for function '{'name': 'lv_color_format_has_alpha', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'src_cf', 'type': {'name': 'lv_color_format_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_color_format_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_BOOL_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_INT)", specific_type_str0, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'INT', 'INT')
// Handles 2 functions like 'lv_color32_eq'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    int64_t arg_buf1;
    int64_t result_buf;

    // Expecting 2 arguments from JSON array for function '{'name': 'lv_color32_eq', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'c1', 'type': {'name': 'lv_color32_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'c2', 'type': {'name': 'lv_color32_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_color32_t', 0, False), ('lv_color32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_BOOL_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_INT_INT)", specific_type_str0, entry->name);
        return false;
    }
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_BOOL_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg1, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_BOOL_INT_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'const char *', 'const char *')
// Handles 1 functions like 'lv_streq'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_const_char_p_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_const_char_p_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_streq', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 's1', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 's2', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('char', 1, False), ('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_const_char_p_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_BOOL_const_char_p_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_const_char_p_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_const_char_p_const_char_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_array_t *')
// Handles 2 functions like 'lv_array_is_empty'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_array_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_array_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_array_is_empty', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'array', 'type': {'type': {'name': 'lv_array_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_array_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_array_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_BOOL_lv_array_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_array_t *', 'INT')
// Handles 1 functions like 'lv_array_resize'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_array_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_array_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_array_resize', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'array', 'type': {'type': {'name': 'lv_array_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'new_capacity', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_array_t', 1, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_array_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_BOOL_lv_array_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_array_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_array_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_circle_buf_t *')
// Handles 2 functions like 'lv_circle_buf_is_empty'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_circle_buf_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_circle_buf_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_circle_buf_is_empty', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'circle_buf', 'type': {'type': {'name': 'lv_circle_buf_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_circle_buf_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_circle_buf_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_BOOL_lv_circle_buf_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_color_t', 'lv_color_t')
// Handles 1 functions like 'lv_color_eq'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_color_t_lv_color_t(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_color_t_lv_color_t (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    int64_t arg_buf1;
    int64_t result_buf;

    // Expecting 2 arguments from JSON array for function '{'name': 'lv_color_eq', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'c1', 'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'c2', 'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_color_t', 0, False), ('lv_color_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_color_t_lv_color_t (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_BOOL_lv_color_t_lv_color_t", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_color_t_lv_color_t)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_color_t_lv_color_t)", specific_type_str0, entry->name);
        return false;
    }
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_BOOL_lv_color_t_lv_color_t)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg1, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_BOOL_lv_color_t_lv_color_t)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_font_info_t *', 'lv_font_info_t *')
// Handles 1 functions like 'lv_font_info_is_equal'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_font_info_t_p_lv_font_info_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_font_info_t_p_lv_font_info_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_font_info_is_equal', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'ft_info_1', 'type': {'type': {'name': 'lv_font_info_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'ft_info_2', 'type': {'type': {'name': 'lv_font_info_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_font_info_t', 1, False), ('lv_font_info_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_font_info_t_p_lv_font_info_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_BOOL_lv_font_info_t_p_lv_font_info_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_font_info_t_p_lv_font_info_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_font_info_t_p_lv_font_info_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_font_t *', 'lv_font_glyph_dsc_t *', 'INT', 'INT')
// Handles 2 functions like 'lv_font_get_glyph_dsc'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_font_t_p_lv_font_glyph_dsc_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_font_t_p_lv_font_glyph_dsc_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_font_get_glyph_dsc', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'font', 'type': {'type': {'name': 'lv_font_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'dsc_out', 'type': {'type': {'name': 'lv_font_glyph_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'letter', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'letter_next', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_font_t', 1, False), ('lv_font_glyph_dsc_t', 1, False), ('uint32_t', 0, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_font_t_p_lv_font_glyph_dsc_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_BOOL_lv_font_t_p_lv_font_glyph_dsc_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_font_t_p_lv_font_glyph_dsc_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_font_t_p_lv_font_glyph_dsc_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_BOOL_lv_font_t_p_lv_font_glyph_dsc_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_BOOL_lv_font_t_p_lv_font_glyph_dsc_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_BOOL_lv_font_t_p_lv_font_glyph_dsc_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_BOOL_lv_font_t_p_lv_font_glyph_dsc_t_p_INT_INT)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_ll_t *')
// Handles 1 functions like 'lv_ll_is_empty'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_ll_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_ll_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_ll_is_empty', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'll_p', 'type': {'type': {'name': 'lv_ll_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_ll_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_ll_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_BOOL_lv_ll_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_obj_t *')
// Handles 26 functions like 'lv_obj_refr_size'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_obj_refr_size', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_BOOL_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_obj_t *', 'INT')
// Handles 9 functions like 'lv_obj_get_style_bg_image_tiled'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_obj_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_obj_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_get_style_bg_image_tiled', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'part', 'type': {'name': 'lv_part_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_part_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_obj_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_BOOL_lv_obj_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_obj_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_obj_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_obj_t *', 'INT', 'INT')
// Handles 3 functions like 'lv_obj_has_style_prop'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_obj_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_obj_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_has_style_prop', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'selector', 'type': {'name': 'lv_style_selector_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'prop', 'type': {'name': 'lv_style_prop_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_style_selector_t', 0, False), ('lv_style_prop_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_obj_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_BOOL_lv_obj_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_obj_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_obj_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_BOOL_lv_obj_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_BOOL_lv_obj_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_obj_t *', 'INT', 'INT', 'INT')
// Handles 1 functions like 'lv_table_has_cell_ctrl'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_obj_t_p_INT_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_obj_t_p_INT_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_table_has_cell_ctrl', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'row', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'col', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'ctrl', 'type': {'name': 'lv_table_cell_ctrl_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('uint32_t', 0, False), ('uint32_t', 0, False), ('lv_table_cell_ctrl_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_obj_t_p_INT_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_BOOL_lv_obj_t_p_INT_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_obj_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_obj_t_p_INT_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_BOOL_lv_obj_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_BOOL_lv_obj_t_p_INT_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_BOOL_lv_obj_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_BOOL_lv_obj_t_p_INT_INT_INT)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_obj_t *', 'const char *', 'INT')
// Handles 1 functions like 'lv_roller_set_selected_str'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_obj_t_p_const_char_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_obj_t_p_const_char_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_roller_set_selected_str', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'sel_opt', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'anim', 'type': {'name': 'lv_anim_enable_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('char', 1, False), ('lv_anim_enable_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_obj_t_p_const_char_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_BOOL_lv_obj_t_p_const_char_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_obj_t_p_const_char_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_obj_t_p_const_char_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_BOOL_lv_obj_t_p_const_char_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_BOOL_lv_obj_t_p_const_char_p_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_obj_t *', 'lv_area_t *')
// Handles 1 functions like 'lv_obj_area_is_visible'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_obj_t_p_lv_area_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_obj_t_p_lv_area_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_area_is_visible', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'area', 'type': {'type': {'name': 'lv_area_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_area_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_obj_t_p_lv_area_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_BOOL_lv_obj_t_p_lv_area_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_obj_t_p_lv_area_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_obj_t_p_lv_area_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_obj_t *', 'lv_event_dsc_t *')
// Handles 1 functions like 'lv_obj_remove_event_dsc'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_obj_t_p_lv_event_dsc_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_obj_t_p_lv_event_dsc_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_remove_event_dsc', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'dsc', 'type': {'type': {'name': 'lv_event_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_event_dsc_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_obj_t_p_lv_event_dsc_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_BOOL_lv_obj_t_p_lv_event_dsc_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_obj_t_p_lv_event_dsc_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_obj_t_p_lv_event_dsc_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_obj_t *', 'lv_obj_class_t *')
// Handles 2 functions like 'lv_obj_check_type'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_obj_t_p_lv_obj_class_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_obj_t_p_lv_obj_class_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_check_type', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'class_p', 'type': {'type': {'name': 'lv_obj_class_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_obj_class_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_obj_t_p_lv_obj_class_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_BOOL_lv_obj_t_p_lv_obj_class_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_obj_t_p_lv_obj_class_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_obj_t_p_lv_obj_class_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_obj_t *', 'lv_obj_t *')
// Handles 1 functions like 'lv_menu_back_button_is_root'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_obj_t_p_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_obj_t_p_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_menu_back_button_is_root', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'menu', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_obj_t_p_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_BOOL_lv_obj_t_p_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_obj_t_p_lv_obj_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_obj_t_p_lv_obj_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_obj_t *', 'lv_point_t *')
// Handles 2 functions like 'lv_obj_hit_test'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_obj_t_p_lv_point_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_obj_t_p_lv_point_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_hit_test', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'point', 'type': {'type': {'name': 'lv_point_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_point_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_obj_t_p_lv_point_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_BOOL_lv_obj_t_p_lv_point_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_obj_t_p_lv_point_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_obj_t_p_lv_point_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_obj_t *', 'lv_style_t *', 'lv_style_t *', 'INT')
// Handles 1 functions like 'lv_obj_replace_style'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_obj_t_p_lv_style_t_p_lv_style_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_obj_t_p_lv_style_t_p_lv_style_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;
    int64_t arg_buf3;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_obj_replace_style', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'old_style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'new_style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'selector', 'type': {'name': 'lv_style_selector_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_style_t', 1, False), ('lv_style_t', 1, False), ('lv_style_selector_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_obj_t_p_lv_style_t_p_lv_style_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_BOOL_lv_obj_t_p_lv_style_t_p_lv_style_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_obj_t_p_lv_style_t_p_lv_style_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_obj_t_p_lv_style_t_p_lv_style_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_BOOL_lv_obj_t_p_lv_style_t_p_lv_style_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_BOOL_lv_obj_t_p_lv_style_t_p_lv_style_t_p_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_BOOL_lv_obj_t_p_lv_style_t_p_lv_style_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_BOOL_lv_obj_t_p_lv_style_t_p_lv_style_t_p_INT)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_rb_t *', 'INT', 'INT')
// Handles 1 functions like 'lv_rb_init'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_rb_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_rb_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_rb_init', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'tree', 'type': {'type': {'name': 'lv_rb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'compare', 'type': {'name': 'lv_rb_compare_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'node_size', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_rb_t', 1, False), ('lv_rb_compare_t', 0, False), ('size_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_rb_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_BOOL_lv_rb_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_rb_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_rb_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_BOOL_lv_rb_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_BOOL_lv_rb_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_rb_t *', 'POINTER')
// Handles 1 functions like 'lv_rb_drop'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_rb_t_p_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_rb_t_p_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_rb_drop', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'tree', 'type': {'type': {'name': 'lv_rb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'key', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_rb_t', 1, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_rb_t_p_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_BOOL_lv_rb_t_p_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_rb_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_rb_t_p_POINTER)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_rb_t *', 'lv_rb_node_t *')
// Handles 1 functions like 'lv_rb_drop_node'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_rb_t_p_lv_rb_node_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_rb_t_p_lv_rb_node_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_rb_drop_node', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'tree', 'type': {'type': {'name': 'lv_rb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'node', 'type': {'type': {'name': 'lv_rb_node_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_rb_t', 1, False), ('lv_rb_node_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_rb_t_p_lv_rb_node_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_BOOL_lv_rb_t_p_lv_rb_node_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_rb_t_p_lv_rb_node_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_rb_t_p_lv_rb_node_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_style_t *')
// Handles 2 functions like 'lv_style_is_const'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_style_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_style_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_style_is_const', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_style_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_style_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_BOOL_lv_style_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_style_t *', 'INT')
// Handles 1 functions like 'lv_style_remove_prop'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_style_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_style_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_style_remove_prop', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'prop', 'type': {'name': 'lv_style_prop_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_style_t', 1, False), ('lv_style_prop_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_style_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_BOOL_lv_style_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_style_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_style_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_text_cmd_state_t *', 'INT')
// Handles 1 functions like 'lv_text_is_cmd'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_text_cmd_state_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_text_cmd_state_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_text_is_cmd', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'state', 'type': {'type': {'name': 'lv_text_cmd_state_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'c', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_text_cmd_state_t', 1, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_text_cmd_state_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_BOOL_lv_text_cmd_state_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_text_cmd_state_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_text_cmd_state_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('BOOL', 'lv_tree_node_t *', 'INT', 'INT', 'INT', 'INT', 'POINTER')
// Handles 1 functions like 'lv_tree_walk'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_BOOL_lv_tree_node_t_p_INT_INT_INT_INT_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_BOOL_lv_tree_node_t_p_INT_INT_INT_INT_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;
    int64_t arg_buf4;
    void* arg_buf5;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 5 arguments from JSON array for function '{'name': 'lv_tree_walk', 'type': {'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'node', 'type': {'type': {'name': 'lv_tree_node_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'mode', 'type': {'name': 'lv_tree_walk_mode_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'cb', 'type': {'name': 'lv_tree_traverse_cb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'bcb', 'type': {'name': 'lv_tree_before_cb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'acb', 'type': {'name': 'lv_tree_after_cb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'user_data', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('bool', 0, False), '_resolved_arg_types': [('lv_tree_node_t', 1, False), ('lv_tree_walk_mode_t', 0, False), ('lv_tree_traverse_cb_t', 0, False), ('lv_tree_before_cb_t', 0, False), ('lv_tree_after_cb_t', 0, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (5 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_BOOL_lv_tree_node_t_p_INT_INT_INT_INT_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 5) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 5 JSON args for func '%s', got %d for invoke_BOOL_lv_tree_node_t_p_INT_INT_INT_INT_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_BOOL_lv_tree_node_t_p_INT_INT_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_BOOL_lv_tree_node_t_p_INT_INT_INT_INT_POINTER)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_BOOL_lv_tree_node_t_p_INT_INT_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_BOOL_lv_tree_node_t_p_INT_INT_INT_INT_POINTER)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_BOOL_lv_tree_node_t_p_INT_INT_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_BOOL_lv_tree_node_t_p_INT_INT_INT_INT_POINTER)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_BOOL_lv_tree_node_t_p_INT_INT_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg3, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_BOOL_lv_tree_node_t_p_INT_INT_INT_INT_POINTER)", specific_type_str4, entry->name);
        return false;
    }
    const char* specific_type_str5 = entry->arg_types[5];
    if (!specific_type_str5) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 5 of '%s'", entry->name); return false; }
    cJSON *json_arg4 = cJSON_GetArrayItem(args_array, 4);
    if (!json_arg4) { LOG_ERR("Invoke Error: Failed to get JSON arg 4 for func '%s' (invoke_BOOL_lv_tree_node_t_p_INT_INT_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 4 into C arg buffer 5 (using specific type 'specific_type_str5')
    if (!(unmarshal_value(json_arg4, specific_type_str5, (void*)&arg_buf5))) {
        LOG_ERR_JSON(json_arg4, "Invoke Error: Failed to unmarshal JSON arg 4 as type '%s' for func '%s' (invoke_BOOL_lv_tree_node_t_p_INT_INT_INT_INT_POINTER)", specific_type_str5, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t, int64_t, int64_t, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4, arg_buf5);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'BOOL')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT',)
// Handles 9 functions like 'lv_mem_test_core'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t result_buf;

    // Expecting 0 arguments from JSON array for function '{'name': 'lv_mem_test_core', 'type': {'type': {'name': 'lv_result_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': None, 'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg', 'quals': []}], '_resolved_ret_type': ('lv_result_t', 0, False), '_resolved_arg_types': []}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func();

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'INT')
// Handles 19 functions like 'lv_tick_elaps'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    int64_t result_buf;

    // Expecting 1 arguments from JSON array for function '{'name': 'lv_tick_elaps', 'type': {'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'prev_tick', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('uint32_t', 0, False), '_resolved_arg_types': [('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_INT)", specific_type_str0, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'INT', 'INT')
// Handles 7 functions like 'lv_atan2'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    int64_t arg_buf1;
    int64_t result_buf;

    // Expecting 2 arguments from JSON array for function '{'name': 'lv_atan2', 'type': {'type': {'name': 'uint16_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'x', 'type': {'name': 'int', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'y', 'type': {'name': 'int', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('uint16_t', 0, False), '_resolved_arg_types': [('int', 0, False), ('int', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_INT_INT)", specific_type_str0, entry->name);
        return false;
    }
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg1, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_INT_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'INT', 'INT', 'INT')
// Handles 2 functions like 'lv_color_16_16_mix'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_INT_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_INT_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t result_buf;

    // Expecting 3 arguments from JSON array for function '{'name': 'lv_color_16_16_mix', 'type': {'type': {'name': 'uint16_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'c1', 'type': {'name': 'uint16_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'c2', 'type': {'name': 'uint16_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'mix', 'type': {'name': 'uint8_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('uint16_t', 0, False), '_resolved_arg_types': [('uint16_t', 0, False), ('uint16_t', 0, False), ('uint8_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_INT_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_INT_INT_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_INT_INT_INT)", specific_type_str0, entry->name);
        return false;
    }
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg1, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_INT_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg2, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_INT_INT_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(int64_t, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'INT', 'INT', 'INT', 'INT')
// Handles 4 functions like 'lv_color32_make'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_INT_INT_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_INT_INT_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;
    int64_t result_buf;

    // Expecting 4 arguments from JSON array for function '{'name': 'lv_color32_make', 'type': {'type': {'name': 'lv_color32_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'r', 'type': {'name': 'uint8_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'g', 'type': {'name': 'uint8_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'b', 'type': {'name': 'uint8_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'a', 'type': {'name': 'uint8_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_color32_t', 0, False), '_resolved_arg_types': [('uint8_t', 0, False), ('uint8_t', 0, False), ('uint8_t', 0, False), ('uint8_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (4 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_INT_INT_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 4) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 4 JSON args for func '%s', got %d for invoke_INT_INT_INT_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_INT_INT_INT_INT)", specific_type_str0, entry->name);
        return false;
    }
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg1, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_INT_INT_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_INT_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg2, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_INT_INT_INT_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_INT_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg3, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_INT_INT_INT_INT_INT)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(int64_t, int64_t, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'INT', 'INT', 'INT', 'INT', 'INT')
// Handles 3 functions like 'lv_cubic_bezier'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_INT_INT_INT_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_INT_INT_INT_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;
    int64_t arg_buf4;
    int64_t result_buf;

    // Expecting 5 arguments from JSON array for function '{'name': 'lv_cubic_bezier', 'type': {'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'x', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'x1', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'y1', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'x2', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'y2', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('int32_t', 0, False), '_resolved_arg_types': [('int32_t', 0, False), ('int32_t', 0, False), ('int32_t', 0, False), ('int32_t', 0, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (5 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_INT_INT_INT_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 5) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 5 JSON args for func '%s', got %d for invoke_INT_INT_INT_INT_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_INT_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_INT_INT_INT_INT_INT)", specific_type_str0, entry->name);
        return false;
    }
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_INT_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg1, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_INT_INT_INT_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_INT_INT_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg2, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_INT_INT_INT_INT_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_INT_INT_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg3, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_INT_INT_INT_INT_INT_INT)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg4 = cJSON_GetArrayItem(args_array, 4);
    if (!json_arg4) { LOG_ERR("Invoke Error: Failed to get JSON arg 4 for func '%s' (invoke_INT_INT_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 4 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg4, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg4, "Invoke Error: Failed to unmarshal JSON arg 4 as type '%s' for func '%s' (invoke_INT_INT_INT_INT_INT_INT)", specific_type_str4, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(int64_t, int64_t, int64_t, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'INT', 'POINTER')
// Handles 3 functions like 'lv_async_call'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_INT_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_INT_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    // Expecting 2 arguments from JSON array for function '{'name': 'lv_async_call', 'type': {'type': {'name': 'lv_result_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'async_xcb', 'type': {'name': 'lv_async_cb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'user_data', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_result_t', 0, False), '_resolved_arg_types': [('lv_async_cb_t', 0, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_INT_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_INT_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_INT_POINTER)", specific_type_str0, entry->name);
        return false;
    }
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg1, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_INT_POINTER)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'POINTER')
// Handles 1 functions like 'lv_color24_luminance'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_color24_luminance', 'type': {'type': {'name': 'uint8_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'c', 'type': {'type': {'name': 'uint8_t', 'json_type': 'stdlib_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('uint8_t', 0, False), '_resolved_arg_types': [('uint8_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_INT_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'POINTER', 'INT')
// Handles 1 functions like 'lv_mem_add_pool'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_POINTER_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_POINTER_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_mem_add_pool', 'type': {'type': {'name': 'lv_mem_pool_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'mem', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'bytes', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_mem_pool_t', 0, False), '_resolved_arg_types': [('void', 1, False), ('size_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_POINTER_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_POINTER_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_POINTER_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'POINTER', 'POINTER', 'INT')
// Handles 1 functions like 'lv_memcmp'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_POINTER_POINTER_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_POINTER_POINTER_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_memcmp', 'type': {'type': {'name': 'int', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'p1', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'p2', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'len', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('int', 0, False), '_resolved_arg_types': [('void', 1, False), ('void', 1, False), ('size_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_POINTER_POINTER_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_POINTER_POINTER_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_POINTER_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_POINTER_POINTER_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_POINTER_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_POINTER_POINTER_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'POINTER', 'lv_image_header_t *')
// Handles 1 functions like 'lv_image_decoder_get_info'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_POINTER_lv_image_header_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_POINTER_lv_image_header_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_image_decoder_get_info', 'type': {'type': {'name': 'lv_result_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'src', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'header', 'type': {'type': {'name': 'lv_image_header_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_result_t', 0, False), '_resolved_arg_types': [('void', 1, False), ('lv_image_header_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_POINTER_lv_image_header_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_POINTER_lv_image_header_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_POINTER_lv_image_header_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_POINTER_lv_image_header_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'const char *')
// Handles 1 functions like 'lv_strlen'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_strlen', 'type': {'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'str', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('size_t', 0, False), '_resolved_arg_types': [('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_INT_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'const char *', 'INT')
// Handles 1 functions like 'lv_strnlen'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_const_char_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_const_char_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_strnlen', 'type': {'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'str', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'max_len', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('size_t', 0, False), '_resolved_arg_types': [('char', 1, False), ('size_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_const_char_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_const_char_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_const_char_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_const_char_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'const char *', 'INT', 'const char *', 'UNKNOWN')
// Handles 1 functions like 'lv_vsnprintf'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_const_char_p_INT_const_char_p_UNKNOWN(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_const_char_p_INT_const_char_p_UNKNOWN (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;
    void* arg_buf3;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_vsnprintf', 'type': {'type': {'name': 'int', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'buffer', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'count', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'format', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'va', 'type': {'name': 'va_list', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('int', 0, False), '_resolved_arg_types': [('char', 1, False), ('size_t', 0, False), ('char', 1, False), ('va_list', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_const_char_p_INT_const_char_p_UNKNOWN (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_INT_const_char_p_INT_const_char_p_UNKNOWN", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_const_char_p_INT_const_char_p_UNKNOWN)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_const_char_p_INT_const_char_p_UNKNOWN)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_const_char_p_INT_const_char_p_UNKNOWN)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_const_char_p_INT_const_char_p_UNKNOWN)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_INT_const_char_p_INT_const_char_p_UNKNOWN)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_INT_const_char_p_INT_const_char_p_UNKNOWN)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'const char *', 'INT', 'lv_font_t *', 'INT')
// Handles 1 functions like 'lv_text_get_width'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_const_char_p_INT_lv_font_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_const_char_p_INT_lv_font_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;
    int64_t arg_buf3;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_text_get_width', 'type': {'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'txt', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'length', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'font', 'type': {'type': {'name': 'lv_font_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'letter_space', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('int32_t', 0, False), '_resolved_arg_types': [('char', 1, False), ('uint32_t', 0, False), ('lv_font_t', 1, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_const_char_p_INT_lv_font_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_INT_const_char_p_INT_lv_font_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_const_char_p_INT_lv_font_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_const_char_p_INT_lv_font_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_const_char_p_INT_lv_font_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_const_char_p_INT_lv_font_t_p_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_INT_const_char_p_INT_lv_font_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_INT_const_char_p_INT_lv_font_t_p_INT)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'const char *', 'INT', 'lv_font_t *', 'INT', 'INT')
// Handles 1 functions like 'lv_text_get_width_with_flags'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_const_char_p_INT_lv_font_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_const_char_p_INT_lv_font_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;
    int64_t arg_buf3;
    int64_t arg_buf4;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 4 arguments from JSON array for function '{'name': 'lv_text_get_width_with_flags', 'type': {'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'txt', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'length', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'font', 'type': {'type': {'name': 'lv_font_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'letter_space', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'flags', 'type': {'name': 'lv_text_flag_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('int32_t', 0, False), '_resolved_arg_types': [('char', 1, False), ('uint32_t', 0, False), ('lv_font_t', 1, False), ('int32_t', 0, False), ('lv_text_flag_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (4 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_const_char_p_INT_lv_font_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 4) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 4 JSON args for func '%s', got %d for invoke_INT_const_char_p_INT_lv_font_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_const_char_p_INT_lv_font_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_const_char_p_INT_lv_font_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_const_char_p_INT_lv_font_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_const_char_p_INT_lv_font_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_INT_const_char_p_INT_lv_font_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_INT_const_char_p_INT_lv_font_t_p_INT_INT)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_INT_const_char_p_INT_lv_font_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg3, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_INT_const_char_p_INT_lv_font_t_p_INT_INT)", specific_type_str4, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t, void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'const char *', 'const char *')
// Handles 1 functions like 'lv_strcmp'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_const_char_p_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_const_char_p_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_strcmp', 'type': {'type': {'name': 'int', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 's1', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 's2', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('int', 0, False), '_resolved_arg_types': [('char', 1, False), ('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_const_char_p_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_const_char_p_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_const_char_p_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_const_char_p_const_char_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'const char *', 'const char *', 'INT')
// Handles 2 functions like 'lv_strlcpy'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_const_char_p_const_char_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_const_char_p_const_char_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_strlcpy', 'type': {'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'dst', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'src', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'dst_size', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('size_t', 0, False), '_resolved_arg_types': [('char', 1, False), ('char', 1, False), ('size_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_const_char_p_const_char_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_const_char_p_const_char_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_const_char_p_const_char_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_const_char_p_const_char_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_const_char_p_const_char_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_const_char_p_const_char_p_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_area_t *')
// Handles 3 functions like 'lv_area_get_width'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_area_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_area_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_area_get_width', 'type': {'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'area_p', 'type': {'type': {'name': 'lv_area_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('int32_t', 0, False), '_resolved_arg_types': [('lv_area_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_area_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_INT_lv_area_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_array_t *')
// Handles 2 functions like 'lv_array_size'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_array_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_array_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_array_size', 'type': {'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'array', 'type': {'type': {'name': 'lv_array_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('uint32_t', 0, False), '_resolved_arg_types': [('lv_array_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_array_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_INT_lv_array_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_array_t *', 'INT')
// Handles 1 functions like 'lv_array_remove'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_array_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_array_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_array_remove', 'type': {'type': {'name': 'lv_result_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'array', 'type': {'type': {'name': 'lv_array_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'index', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_result_t', 0, False), '_resolved_arg_types': [('lv_array_t', 1, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_array_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_lv_array_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_array_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_array_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_array_t *', 'INT', 'INT')
// Handles 1 functions like 'lv_array_erase'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_array_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_array_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_array_erase', 'type': {'type': {'name': 'lv_result_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'array', 'type': {'type': {'name': 'lv_array_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'start', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'end', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_result_t', 0, False), '_resolved_arg_types': [('lv_array_t', 1, False), ('uint32_t', 0, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_array_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_lv_array_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_array_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_array_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_array_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_array_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_array_t *', 'INT', 'POINTER')
// Handles 1 functions like 'lv_array_assign'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_array_t_p_INT_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_array_t_p_INT_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_array_assign', 'type': {'type': {'name': 'lv_result_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'array', 'type': {'type': {'name': 'lv_array_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'index', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_result_t', 0, False), '_resolved_arg_types': [('lv_array_t', 1, False), ('uint32_t', 0, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_array_t_p_INT_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_lv_array_t_p_INT_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_array_t_p_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_array_t_p_INT_POINTER)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_array_t_p_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_array_t_p_INT_POINTER)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_array_t *', 'POINTER')
// Handles 1 functions like 'lv_array_push_back'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_array_t_p_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_array_t_p_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_array_push_back', 'type': {'type': {'name': 'lv_result_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'array', 'type': {'type': {'name': 'lv_array_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'element', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_result_t', 0, False), '_resolved_arg_types': [('lv_array_t', 1, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_array_t_p_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_lv_array_t_p_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_array_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_array_t_p_POINTER)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_array_t *', 'lv_array_t *')
// Handles 1 functions like 'lv_array_concat'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_array_t_p_lv_array_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_array_t_p_lv_array_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_array_concat', 'type': {'type': {'name': 'lv_result_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'array', 'type': {'type': {'name': 'lv_array_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'other', 'type': {'type': {'name': 'lv_array_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_result_t', 0, False), '_resolved_arg_types': [('lv_array_t', 1, False), ('lv_array_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_array_t_p_lv_array_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_lv_array_t_p_lv_array_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_array_t_p_lv_array_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_array_t_p_lv_array_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_circle_buf_t *')
// Handles 4 functions like 'lv_circle_buf_size'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_circle_buf_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_circle_buf_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_circle_buf_size', 'type': {'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'circle_buf', 'type': {'type': {'name': 'lv_circle_buf_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('uint32_t', 0, False), '_resolved_arg_types': [('lv_circle_buf_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_circle_buf_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_INT_lv_circle_buf_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_circle_buf_t *', 'INT')
// Handles 1 functions like 'lv_circle_buf_resize'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_circle_buf_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_circle_buf_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_circle_buf_resize', 'type': {'type': {'name': 'lv_result_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'circle_buf', 'type': {'type': {'name': 'lv_circle_buf_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'capacity', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_result_t', 0, False), '_resolved_arg_types': [('lv_circle_buf_t', 1, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_circle_buf_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_lv_circle_buf_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_circle_buf_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_circle_buf_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_circle_buf_t *', 'INT', 'INT', 'POINTER')
// Handles 1 functions like 'lv_circle_buf_fill'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_circle_buf_t_p_INT_INT_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_circle_buf_t_p_INT_INT_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    void* arg_buf3;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_circle_buf_fill', 'type': {'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'circle_buf', 'type': {'type': {'name': 'lv_circle_buf_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'count', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'fill_cb', 'type': {'name': 'lv_circle_buf_fill_cb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'user_data', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('uint32_t', 0, False), '_resolved_arg_types': [('lv_circle_buf_t', 1, False), ('uint32_t', 0, False), ('lv_circle_buf_fill_cb_t', 0, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_circle_buf_t_p_INT_INT_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_INT_lv_circle_buf_t_p_INT_INT_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_circle_buf_t_p_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_circle_buf_t_p_INT_INT_POINTER)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_circle_buf_t_p_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_circle_buf_t_p_INT_INT_POINTER)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_INT_lv_circle_buf_t_p_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_INT_lv_circle_buf_t_p_INT_INT_POINTER)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_circle_buf_t *', 'INT', 'POINTER')
// Handles 1 functions like 'lv_circle_buf_peek_at'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_circle_buf_t_p_INT_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_circle_buf_t_p_INT_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_circle_buf_peek_at', 'type': {'type': {'name': 'lv_result_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'circle_buf', 'type': {'type': {'name': 'lv_circle_buf_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'index', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'data', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_result_t', 0, False), '_resolved_arg_types': [('lv_circle_buf_t', 1, False), ('uint32_t', 0, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_circle_buf_t_p_INT_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_lv_circle_buf_t_p_INT_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_circle_buf_t_p_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_circle_buf_t_p_INT_POINTER)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_circle_buf_t_p_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_circle_buf_t_p_INT_POINTER)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_circle_buf_t *', 'POINTER')
// Handles 3 functions like 'lv_circle_buf_read'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_circle_buf_t_p_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_circle_buf_t_p_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_circle_buf_read', 'type': {'type': {'name': 'lv_result_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'circle_buf', 'type': {'type': {'name': 'lv_circle_buf_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'data', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_result_t', 0, False), '_resolved_arg_types': [('lv_circle_buf_t', 1, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_circle_buf_t_p_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_lv_circle_buf_t_p_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_circle_buf_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_circle_buf_t_p_POINTER)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_color_t')
// Handles 5 functions like 'lv_color_to_int'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_color_t(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_color_t (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    int64_t result_buf;

    // Expecting 1 arguments from JSON array for function '{'name': 'lv_color_to_int', 'type': {'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'c', 'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('uint32_t', 0, False), '_resolved_arg_types': [('lv_color_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_color_t (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_lv_color_t", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_color_t)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_color_t)", specific_type_str0, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_color_t', 'INT')
// Handles 1 functions like 'lv_color_to_32'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_color_t_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_color_t_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    int64_t arg_buf1;
    int64_t result_buf;

    // Expecting 2 arguments from JSON array for function '{'name': 'lv_color_to_32', 'type': {'type': {'name': 'lv_color32_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'color', 'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'opa', 'type': {'name': 'lv_opa_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_color32_t', 0, False), '_resolved_arg_types': [('lv_color_t', 0, False), ('lv_opa_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_color_t_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_lv_color_t_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_color_t_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_color_t_INT)", specific_type_str0, entry->name);
        return false;
    }
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_color_t_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg1, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_color_t_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_font_t *')
// Handles 1 functions like 'lv_font_get_line_height'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_font_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_font_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_font_get_line_height', 'type': {'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'font', 'type': {'type': {'name': 'lv_font_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('int32_t', 0, False), '_resolved_arg_types': [('lv_font_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_font_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_INT_lv_font_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_font_t *', 'INT', 'INT')
// Handles 1 functions like 'lv_font_get_glyph_width'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_font_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_font_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_font_get_glyph_width', 'type': {'type': {'name': 'uint16_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'font', 'type': {'type': {'name': 'lv_font_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'letter', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'letter_next', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('uint16_t', 0, False), '_resolved_arg_types': [('lv_font_t', 1, False), ('uint32_t', 0, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_font_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_lv_font_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_font_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_font_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_font_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_font_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_fs_dir_t *')
// Handles 1 functions like 'lv_fs_dir_close'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_fs_dir_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_fs_dir_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_fs_dir_close', 'type': {'type': {'name': 'lv_fs_res_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'rddir_p', 'type': {'type': {'name': 'lv_fs_dir_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_fs_res_t', 0, False), '_resolved_arg_types': [('lv_fs_dir_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_fs_dir_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_INT_lv_fs_dir_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_fs_dir_t *', 'const char *')
// Handles 1 functions like 'lv_fs_dir_open'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_fs_dir_t_p_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_fs_dir_t_p_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_fs_dir_open', 'type': {'type': {'name': 'lv_fs_res_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'rddir_p', 'type': {'type': {'name': 'lv_fs_dir_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'path', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_fs_res_t', 0, False), '_resolved_arg_types': [('lv_fs_dir_t', 1, False), ('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_fs_dir_t_p_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_lv_fs_dir_t_p_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_fs_dir_t_p_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_fs_dir_t_p_const_char_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_fs_dir_t *', 'const char *', 'INT')
// Handles 1 functions like 'lv_fs_dir_read'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_fs_dir_t_p_const_char_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_fs_dir_t_p_const_char_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_fs_dir_read', 'type': {'type': {'name': 'lv_fs_res_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'rddir_p', 'type': {'type': {'name': 'lv_fs_dir_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'fn', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'fn_len', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_fs_res_t', 0, False), '_resolved_arg_types': [('lv_fs_dir_t', 1, False), ('char', 1, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_fs_dir_t_p_const_char_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_lv_fs_dir_t_p_const_char_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_fs_dir_t_p_const_char_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_fs_dir_t_p_const_char_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_fs_dir_t_p_const_char_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_fs_dir_t_p_const_char_p_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_fs_file_t *')
// Handles 1 functions like 'lv_fs_close'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_fs_file_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_fs_file_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_fs_close', 'type': {'type': {'name': 'lv_fs_res_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'file_p', 'type': {'type': {'name': 'lv_fs_file_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_fs_res_t', 0, False), '_resolved_arg_types': [('lv_fs_file_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_fs_file_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_INT_lv_fs_file_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_fs_file_t *', 'INT', 'INT')
// Handles 1 functions like 'lv_fs_seek'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_fs_file_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_fs_file_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_fs_seek', 'type': {'type': {'name': 'lv_fs_res_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'file_p', 'type': {'type': {'name': 'lv_fs_file_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'pos', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'whence', 'type': {'name': 'lv_fs_whence_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_fs_res_t', 0, False), '_resolved_arg_types': [('lv_fs_file_t', 1, False), ('uint32_t', 0, False), ('lv_fs_whence_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_fs_file_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_lv_fs_file_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_fs_file_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_fs_file_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_fs_file_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_fs_file_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_fs_file_t *', 'POINTER')
// Handles 1 functions like 'lv_fs_tell'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_fs_file_t_p_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_fs_file_t_p_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_fs_tell', 'type': {'type': {'name': 'lv_fs_res_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'file_p', 'type': {'type': {'name': 'lv_fs_file_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'pos', 'type': {'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_fs_res_t', 0, False), '_resolved_arg_types': [('lv_fs_file_t', 1, False), ('uint32_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_fs_file_t_p_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_lv_fs_file_t_p_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_fs_file_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_fs_file_t_p_POINTER)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_fs_file_t *', 'POINTER', 'INT', 'POINTER')
// Handles 2 functions like 'lv_fs_read'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_fs_file_t_p_POINTER_INT_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_fs_file_t_p_POINTER_INT_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    void* arg_buf3;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_fs_read', 'type': {'type': {'name': 'lv_fs_res_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'file_p', 'type': {'type': {'name': 'lv_fs_file_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'buf', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'btr', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'br', 'type': {'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_fs_res_t', 0, False), '_resolved_arg_types': [('lv_fs_file_t', 1, False), ('void', 1, False), ('uint32_t', 0, False), ('uint32_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_fs_file_t_p_POINTER_INT_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_INT_lv_fs_file_t_p_POINTER_INT_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_fs_file_t_p_POINTER_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_fs_file_t_p_POINTER_INT_POINTER)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_fs_file_t_p_POINTER_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_fs_file_t_p_POINTER_INT_POINTER)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_INT_lv_fs_file_t_p_POINTER_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_INT_lv_fs_file_t_p_POINTER_INT_POINTER)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_fs_file_t *', 'const char *', 'INT')
// Handles 1 functions like 'lv_fs_open'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_fs_file_t_p_const_char_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_fs_file_t_p_const_char_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_fs_open', 'type': {'type': {'name': 'lv_fs_res_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'file_p', 'type': {'type': {'name': 'lv_fs_file_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'path', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'mode', 'type': {'name': 'lv_fs_mode_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_fs_res_t', 0, False), '_resolved_arg_types': [('lv_fs_file_t', 1, False), ('char', 1, False), ('lv_fs_mode_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_fs_file_t_p_const_char_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_lv_fs_file_t_p_const_char_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_fs_file_t_p_const_char_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_fs_file_t_p_const_char_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_fs_file_t_p_const_char_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_fs_file_t_p_const_char_p_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_image_decoder_dsc_t *', 'POINTER', 'lv_image_decoder_args_t *')
// Handles 1 functions like 'lv_image_decoder_open'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_image_decoder_dsc_t_p_POINTER_lv_image_decoder_args_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_image_decoder_dsc_t_p_POINTER_lv_image_decoder_args_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_image_decoder_open', 'type': {'type': {'name': 'lv_result_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'dsc', 'type': {'type': {'name': 'lv_image_decoder_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'src', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'args', 'type': {'type': {'name': 'lv_image_decoder_args_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_result_t', 0, False), '_resolved_arg_types': [('lv_image_decoder_dsc_t', 1, False), ('void', 1, False), ('lv_image_decoder_args_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_image_decoder_dsc_t_p_POINTER_lv_image_decoder_args_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_lv_image_decoder_dsc_t_p_POINTER_lv_image_decoder_args_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_image_decoder_dsc_t_p_POINTER_lv_image_decoder_args_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_image_decoder_dsc_t_p_POINTER_lv_image_decoder_args_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_image_decoder_dsc_t_p_POINTER_lv_image_decoder_args_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_image_decoder_dsc_t_p_POINTER_lv_image_decoder_args_t_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_image_decoder_dsc_t *', 'lv_area_t *', 'lv_area_t *')
// Handles 1 functions like 'lv_image_decoder_get_area'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_image_decoder_get_area', 'type': {'type': {'name': 'lv_result_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'dsc', 'type': {'type': {'name': 'lv_image_decoder_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'full_area', 'type': {'type': {'name': 'lv_area_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'decoded_area', 'type': {'type': {'name': 'lv_area_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_result_t', 0, False), '_resolved_arg_types': [('lv_image_decoder_dsc_t', 1, False), ('lv_area_t', 1, False), ('lv_area_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_image_decoder_t *', 'lv_image_decoder_dsc_t *')
// Handles 1 functions like 'lv_bin_decoder_open'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_bin_decoder_open', 'type': {'type': {'name': 'lv_result_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'decoder', 'type': {'type': {'name': 'lv_image_decoder_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'dsc', 'type': {'type': {'name': 'lv_image_decoder_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_result_t', 0, False), '_resolved_arg_types': [('lv_image_decoder_t', 1, False), ('lv_image_decoder_dsc_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_image_decoder_t *', 'lv_image_decoder_dsc_t *', 'lv_area_t *', 'lv_area_t *')
// Handles 1 functions like 'lv_bin_decoder_get_area'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;
    void* arg_buf3;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_bin_decoder_get_area', 'type': {'type': {'name': 'lv_result_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'decoder', 'type': {'type': {'name': 'lv_image_decoder_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'dsc', 'type': {'type': {'name': 'lv_image_decoder_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'full_area', 'type': {'type': {'name': 'lv_area_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'decoded_area', 'type': {'type': {'name': 'lv_area_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_result_t', 0, False), '_resolved_arg_types': [('lv_image_decoder_t', 1, False), ('lv_image_decoder_dsc_t', 1, False), ('lv_area_t', 1, False), ('lv_area_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_image_decoder_t *', 'lv_image_decoder_dsc_t *', 'lv_image_header_t *')
// Handles 1 functions like 'lv_bin_decoder_info'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_image_header_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_image_header_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_bin_decoder_info', 'type': {'type': {'name': 'lv_result_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'decoder', 'type': {'type': {'name': 'lv_image_decoder_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'dsc', 'type': {'type': {'name': 'lv_image_decoder_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'header', 'type': {'type': {'name': 'lv_image_header_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_result_t', 0, False), '_resolved_arg_types': [('lv_image_decoder_t', 1, False), ('lv_image_decoder_dsc_t', 1, False), ('lv_image_header_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_image_header_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_image_header_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_image_header_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_image_header_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_image_header_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_image_header_t_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_ll_t *')
// Handles 1 functions like 'lv_ll_get_len'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_ll_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_ll_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_ll_get_len', 'type': {'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'll_p', 'type': {'type': {'name': 'lv_ll_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('uint32_t', 0, False), '_resolved_arg_types': [('lv_ll_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_ll_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_INT_lv_ll_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_obj_class_t *', 'lv_event_t *')
// Handles 1 functions like 'lv_obj_event_base'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_obj_class_t_p_lv_event_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_obj_class_t_p_lv_event_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_event_base', 'type': {'type': {'name': 'lv_result_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'class_p', 'type': {'type': {'name': 'lv_obj_class_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'e', 'type': {'type': {'name': 'lv_event_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_result_t', 0, False), '_resolved_arg_types': [('lv_obj_class_t', 1, False), ('lv_event_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_obj_class_t_p_lv_event_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_lv_obj_class_t_p_lv_event_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_obj_class_t_p_lv_event_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_obj_class_t_p_lv_event_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_obj_t *')
// Handles 101 functions like 'lv_obj_get_child_count'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_obj_get_child_count', 'type': {'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('uint32_t', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_INT_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_obj_t *', 'INT')
// Handles 104 functions like 'lv_obj_get_style_width'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_obj_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_obj_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_get_style_width', 'type': {'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'part', 'type': {'name': 'lv_part_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('int32_t', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_part_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_obj_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_lv_obj_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_obj_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_obj_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_obj_t *', 'INT', 'INT')
// Handles 4 functions like 'lv_obj_get_style_prop'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_obj_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_obj_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_get_style_prop', 'type': {'type': {'name': 'lv_style_value_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'part', 'type': {'name': 'lv_part_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'prop', 'type': {'name': 'lv_style_prop_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_style_value_t', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_part_t', 0, False), ('lv_style_prop_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_obj_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_lv_obj_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_obj_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_obj_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_obj_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_obj_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_obj_t *', 'INT', 'POINTER')
// Handles 2 functions like 'lv_obj_send_event'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_obj_t_p_INT_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_obj_t_p_INT_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_send_event', 'type': {'type': {'name': 'lv_result_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'event_code', 'type': {'name': 'lv_event_code_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'param', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_result_t', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_event_code_t', 0, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_obj_t_p_INT_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_lv_obj_t_p_INT_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_obj_t_p_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_obj_t_p_INT_POINTER)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_obj_t_p_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_obj_t_p_INT_POINTER)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_obj_t *', 'INT', 'const char *')
// Handles 1 functions like 'lv_obj_calculate_style_text_align'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_obj_t_p_INT_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_obj_t_p_INT_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_calculate_style_text_align', 'type': {'type': {'name': 'lv_text_align_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'part', 'type': {'name': 'lv_part_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'txt', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_text_align_t', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_part_t', 0, False), ('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_obj_t_p_INT_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_lv_obj_t_p_INT_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_obj_t_p_INT_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_obj_t_p_INT_const_char_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_obj_t_p_INT_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_obj_t_p_INT_const_char_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_obj_t *', 'INT', 'lv_style_value_t *', 'INT')
// Handles 1 functions like 'lv_obj_get_local_style_prop'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_obj_t_p_INT_lv_style_value_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_obj_t_p_INT_lv_style_value_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;
    int64_t arg_buf3;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_obj_get_local_style_prop', 'type': {'type': {'name': 'lv_style_res_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'prop', 'type': {'name': 'lv_style_prop_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'type': {'name': 'lv_style_value_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'selector', 'type': {'name': 'lv_style_selector_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_style_res_t', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_style_prop_t', 0, False), ('lv_style_value_t', 1, False), ('lv_style_selector_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_obj_t_p_INT_lv_style_value_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_INT_lv_obj_t_p_INT_lv_style_value_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_obj_t_p_INT_lv_style_value_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_obj_t_p_INT_lv_style_value_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_obj_t_p_INT_lv_style_value_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_obj_t_p_INT_lv_style_value_t_p_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_INT_lv_obj_t_p_INT_lv_style_value_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_INT_lv_obj_t_p_INT_lv_style_value_t_p_INT)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_obj_t *', 'const char *')
// Handles 1 functions like 'lv_dropdown_get_option_index'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_obj_t_p_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_obj_t_p_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_dropdown_get_option_index', 'type': {'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'option', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('int32_t', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_obj_t_p_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_lv_obj_t_p_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_obj_t_p_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_obj_t_p_const_char_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_obj_t *', 'lv_chart_cursor_t *')
// Handles 1 functions like 'lv_chart_get_cursor_point'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_obj_t_p_lv_chart_cursor_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_obj_t_p_lv_chart_cursor_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_chart_get_cursor_point', 'type': {'type': {'name': 'lv_point_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'chart', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'cursor', 'type': {'type': {'name': 'lv_chart_cursor_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_point_t', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_chart_cursor_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_obj_t_p_lv_chart_cursor_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_lv_obj_t_p_lv_chart_cursor_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_obj_t_p_lv_chart_cursor_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_obj_t_p_lv_chart_cursor_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_obj_t *', 'lv_chart_series_t *')
// Handles 1 functions like 'lv_chart_get_x_start_point'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_obj_t_p_lv_chart_series_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_obj_t_p_lv_chart_series_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_chart_get_x_start_point', 'type': {'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'ser', 'type': {'type': {'name': 'lv_chart_series_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('uint32_t', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_chart_series_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_obj_t_p_lv_chart_series_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_lv_obj_t_p_lv_chart_series_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_obj_t_p_lv_chart_series_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_obj_t_p_lv_chart_series_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_obj_t *', 'lv_obj_class_t *')
// Handles 2 functions like 'lv_obj_get_child_count_by_type'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_obj_t_p_lv_obj_class_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_obj_t_p_lv_obj_class_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_get_child_count_by_type', 'type': {'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'class_p', 'type': {'type': {'name': 'lv_obj_class_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('uint32_t', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_obj_class_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_obj_t_p_lv_obj_class_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_lv_obj_t_p_lv_obj_class_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_obj_t_p_lv_obj_class_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_obj_t_p_lv_obj_class_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_obj_t *', 'lv_point_t *', 'BOOL')
// Handles 1 functions like 'lv_label_get_letter_on'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_obj_t_p_lv_point_t_p_BOOL(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_obj_t_p_lv_point_t_p_BOOL (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_label_get_letter_on', 'type': {'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'pos_in', 'type': {'type': {'name': 'lv_point_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'bidi', 'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('uint32_t', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_point_t', 1, False), ('bool', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_obj_t_p_lv_point_t_p_BOOL (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_lv_obj_t_p_lv_point_t_p_BOOL", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_obj_t_p_lv_point_t_p_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_obj_t_p_lv_point_t_p_BOOL)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_obj_t_p_lv_point_t_p_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_obj_t_p_lv_point_t_p_BOOL)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_obj_t *', 'lv_span_t *')
// Handles 1 functions like 'lv_spangroup_get_span_coords'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_obj_t_p_lv_span_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_obj_t_p_lv_span_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_spangroup_get_span_coords', 'type': {'type': {'name': 'lv_span_coords_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'span', 'type': {'type': {'name': 'lv_span_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_span_coords_t', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_span_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_obj_t_p_lv_span_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_INT_lv_obj_t_p_lv_span_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_obj_t_p_lv_span_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_obj_t_p_lv_span_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_point_precise_t *')
// Handles 1 functions like 'lv_point_from_precise'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_point_precise_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_point_precise_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_point_from_precise', 'type': {'type': {'name': 'lv_point_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'p', 'type': {'type': {'name': 'lv_point_precise_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_point_t', 0, False), '_resolved_arg_types': [('lv_point_precise_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_point_precise_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_INT_lv_point_precise_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_point_t *')
// Handles 1 functions like 'lv_point_to_precise'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_point_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_point_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_point_to_precise', 'type': {'type': {'name': 'lv_point_precise_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'p', 'type': {'type': {'name': 'lv_point_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_point_precise_t', 0, False), '_resolved_arg_types': [('lv_point_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_point_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_INT_lv_point_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_style_t *', 'INT', 'lv_style_value_t *')
// Handles 2 functions like 'lv_style_get_prop'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_style_t_p_INT_lv_style_value_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_style_t_p_INT_lv_style_value_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_style_get_prop', 'type': {'type': {'name': 'lv_style_res_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'prop', 'type': {'name': 'lv_style_prop_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'type': {'name': 'lv_style_value_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_style_res_t', 0, False), '_resolved_arg_types': [('lv_style_t', 1, False), ('lv_style_prop_t', 0, False), ('lv_style_value_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_style_t_p_INT_lv_style_value_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_INT_lv_style_t_p_INT_lv_style_value_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_INT_lv_style_t_p_INT_lv_style_value_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_INT_lv_style_t_p_INT_lv_style_value_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_INT_lv_style_t_p_INT_lv_style_value_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_INT_lv_style_t_p_INT_lv_style_value_t_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('INT', 'lv_subject_t *')
// Handles 2 functions like 'lv_subject_get_int'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_INT_lv_subject_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_INT_lv_subject_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_subject_get_int', 'type': {'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'subject', 'type': {'type': {'name': 'lv_subject_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('int32_t', 0, False), '_resolved_arg_types': [('lv_subject_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_INT_lv_subject_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_INT_lv_subject_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'INT')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('POINTER', 'INT')
// Handles 4 functions like 'lv_malloc'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_POINTER_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_POINTER_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    void* result_buf;

    // Expecting 1 arguments from JSON array for function '{'name': 'lv_malloc', 'type': {'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'size', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 1, False), '_resolved_arg_types': [('size_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_POINTER_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_POINTER_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_POINTER_INT)", specific_type_str0, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'POINTER')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('POINTER', 'INT', 'INT')
// Handles 1 functions like 'lv_calloc'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_POINTER_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_POINTER_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    int64_t arg_buf1;
    void* result_buf;

    // Expecting 2 arguments from JSON array for function '{'name': 'lv_calloc', 'type': {'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'num', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'size', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 1, False), '_resolved_arg_types': [('size_t', 0, False), ('size_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_POINTER_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_POINTER_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_POINTER_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_POINTER_INT_INT)", specific_type_str0, entry->name);
        return false;
    }
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_POINTER_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg1, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_POINTER_INT_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'POINTER')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('POINTER', 'POINTER', 'INT')
// Handles 3 functions like 'lv_realloc'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_POINTER_POINTER_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_POINTER_POINTER_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_realloc', 'type': {'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'data_p', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'new_size', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 1, False), '_resolved_arg_types': [('void', 1, False), ('size_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_POINTER_POINTER_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_POINTER_POINTER_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_POINTER_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_POINTER_POINTER_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'POINTER')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('POINTER', 'POINTER', 'POINTER', 'INT')
// Handles 2 functions like 'lv_memcpy'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_POINTER_POINTER_POINTER_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_POINTER_POINTER_POINTER_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_memcpy', 'type': {'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'dst', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'src', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'len', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 1, False), '_resolved_arg_types': [('void', 1, False), ('void', 1, False), ('size_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_POINTER_POINTER_POINTER_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_POINTER_POINTER_POINTER_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_POINTER_POINTER_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_POINTER_POINTER_POINTER_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_POINTER_POINTER_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_POINTER_POINTER_POINTER_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'POINTER')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('POINTER', 'POINTER', 'POINTER', 'INT', 'INT', 'INT')
// Handles 1 functions like 'lv_utils_bsearch'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_POINTER_POINTER_POINTER_INT_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_POINTER_POINTER_POINTER_INT_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;
    int64_t arg_buf4;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 4 arguments from JSON array for function '{'name': 'lv_utils_bsearch', 'type': {'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'key', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'base', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'n', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'size', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'cmp', 'type': {'name': 'cmp', 'type': {'type': {'name': 'int', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function_pointer', 'args': [{'name': 'pRef', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'pElement', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 1, False), '_resolved_arg_types': [('void', 1, False), ('void', 1, False), ('size_t', 0, False), ('size_t', 0, False), ('int', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (4 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_POINTER_POINTER_POINTER_INT_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 4) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 4 JSON args for func '%s', got %d for invoke_POINTER_POINTER_POINTER_INT_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_POINTER_POINTER_POINTER_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_POINTER_POINTER_POINTER_INT_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_POINTER_POINTER_POINTER_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_POINTER_POINTER_POINTER_INT_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_POINTER_POINTER_POINTER_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_POINTER_POINTER_POINTER_INT_INT_INT)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_POINTER_POINTER_POINTER_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg3, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_POINTER_POINTER_POINTER_INT_INT_INT)", specific_type_str4, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*, int64_t, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'POINTER')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('POINTER', 'lv_array_t *')
// Handles 2 functions like 'lv_array_front'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_POINTER_lv_array_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_POINTER_lv_array_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_array_front', 'type': {'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'array', 'type': {'type': {'name': 'lv_array_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 1, False), '_resolved_arg_types': [('lv_array_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_POINTER_lv_array_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_POINTER_lv_array_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'POINTER')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('POINTER', 'lv_array_t *', 'INT')
// Handles 1 functions like 'lv_array_at'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_POINTER_lv_array_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_POINTER_lv_array_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_array_at', 'type': {'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'array', 'type': {'type': {'name': 'lv_array_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'index', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 1, False), '_resolved_arg_types': [('lv_array_t', 1, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_POINTER_lv_array_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_POINTER_lv_array_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_POINTER_lv_array_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_POINTER_lv_array_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'POINTER')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('POINTER', 'lv_circle_buf_t *')
// Handles 2 functions like 'lv_circle_buf_head'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_POINTER_lv_circle_buf_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_POINTER_lv_circle_buf_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_circle_buf_head', 'type': {'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'circle_buf', 'type': {'type': {'name': 'lv_circle_buf_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 1, False), '_resolved_arg_types': [('lv_circle_buf_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_POINTER_lv_circle_buf_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_POINTER_lv_circle_buf_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'POINTER')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('POINTER', 'lv_font_glyph_dsc_t *', 'lv_draw_buf_t *')
// Handles 2 functions like 'lv_font_get_glyph_bitmap'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_POINTER_lv_font_glyph_dsc_t_p_lv_draw_buf_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_POINTER_lv_font_glyph_dsc_t_p_lv_draw_buf_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_font_get_glyph_bitmap', 'type': {'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'g_dsc', 'type': {'type': {'name': 'lv_font_glyph_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'draw_buf', 'type': {'type': {'name': 'lv_draw_buf_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 1, False), '_resolved_arg_types': [('lv_font_glyph_dsc_t', 1, False), ('lv_draw_buf_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_POINTER_lv_font_glyph_dsc_t_p_lv_draw_buf_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_POINTER_lv_font_glyph_dsc_t_p_lv_draw_buf_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_POINTER_lv_font_glyph_dsc_t_p_lv_draw_buf_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_POINTER_lv_font_glyph_dsc_t_p_lv_draw_buf_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'POINTER')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('POINTER', 'lv_ll_t *')
// Handles 4 functions like 'lv_ll_ins_head'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_POINTER_lv_ll_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_POINTER_lv_ll_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_ll_ins_head', 'type': {'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'll_p', 'type': {'type': {'name': 'lv_ll_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 1, False), '_resolved_arg_types': [('lv_ll_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_POINTER_lv_ll_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_POINTER_lv_ll_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'POINTER')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('POINTER', 'lv_ll_t *', 'POINTER')
// Handles 3 functions like 'lv_ll_ins_prev'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_POINTER_lv_ll_t_p_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_POINTER_lv_ll_t_p_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_ll_ins_prev', 'type': {'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'll_p', 'type': {'type': {'name': 'lv_ll_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'n_act', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 1, False), '_resolved_arg_types': [('lv_ll_t', 1, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_POINTER_lv_ll_t_p_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_POINTER_lv_ll_t_p_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_POINTER_lv_ll_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_POINTER_lv_ll_t_p_POINTER)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'POINTER')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('POINTER', 'lv_obj_t *')
// Handles 5 functions like 'lv_obj_get_user_data'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_POINTER_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_POINTER_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_obj_get_user_data', 'type': {'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_POINTER_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_POINTER_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'POINTER')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('POINTER', 'lv_obj_t *', 'INT')
// Handles 8 functions like 'lv_obj_get_style_bg_image_src'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_POINTER_lv_obj_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_POINTER_lv_obj_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_get_style_bg_image_src', 'type': {'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'part', 'type': {'name': 'lv_part_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_part_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_POINTER_lv_obj_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_POINTER_lv_obj_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_POINTER_lv_obj_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_POINTER_lv_obj_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'POINTER')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('POINTER', 'lv_obj_t *', 'INT', 'INT')
// Handles 1 functions like 'lv_table_get_cell_user_data'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_POINTER_lv_obj_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_POINTER_lv_obj_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_table_get_cell_user_data', 'type': {'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'row', 'type': {'name': 'uint16_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'col', 'type': {'name': 'uint16_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('uint16_t', 0, False), ('uint16_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_POINTER_lv_obj_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_POINTER_lv_obj_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_POINTER_lv_obj_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_POINTER_lv_obj_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_POINTER_lv_obj_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_POINTER_lv_obj_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'POINTER')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('POINTER', 'lv_obj_t *', 'lv_chart_series_t *')
// Handles 2 functions like 'lv_chart_get_series_y_array'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_POINTER_lv_obj_t_p_lv_chart_series_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_POINTER_lv_obj_t_p_lv_chart_series_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_chart_get_series_y_array', 'type': {'type': {'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'ser', 'type': {'type': {'name': 'lv_chart_series_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('int32_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_chart_series_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_POINTER_lv_obj_t_p_lv_chart_series_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_POINTER_lv_obj_t_p_lv_chart_series_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_POINTER_lv_obj_t_p_lv_chart_series_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_POINTER_lv_obj_t_p_lv_chart_series_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'POINTER')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('POINTER', 'lv_observer_t *')
// Handles 2 functions like 'lv_observer_get_target'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_POINTER_lv_observer_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_POINTER_lv_observer_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_observer_get_target', 'type': {'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'observer', 'type': {'type': {'name': 'lv_observer_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 1, False), '_resolved_arg_types': [('lv_observer_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_POINTER_lv_observer_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_POINTER_lv_observer_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'POINTER')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('POINTER', 'lv_rb_t *', 'POINTER')
// Handles 1 functions like 'lv_rb_remove'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_POINTER_lv_rb_t_p_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_POINTER_lv_rb_t_p_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_rb_remove', 'type': {'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'tree', 'type': {'type': {'name': 'lv_rb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'key', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 1, False), '_resolved_arg_types': [('lv_rb_t', 1, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_POINTER_lv_rb_t_p_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_POINTER_lv_rb_t_p_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_POINTER_lv_rb_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_POINTER_lv_rb_t_p_POINTER)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'POINTER')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('POINTER', 'lv_rb_t *', 'lv_rb_node_t *')
// Handles 1 functions like 'lv_rb_remove_node'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_POINTER_lv_rb_t_p_lv_rb_node_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_POINTER_lv_rb_t_p_lv_rb_node_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_rb_remove_node', 'type': {'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'tree', 'type': {'type': {'name': 'lv_rb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'node', 'type': {'type': {'name': 'lv_rb_node_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 1, False), '_resolved_arg_types': [('lv_rb_t', 1, False), ('lv_rb_node_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_POINTER_lv_rb_t_p_lv_rb_node_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_POINTER_lv_rb_t_p_lv_rb_node_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_POINTER_lv_rb_t_p_lv_rb_node_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_POINTER_lv_rb_t_p_lv_rb_node_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'POINTER')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('POINTER', 'lv_subject_t *')
// Handles 2 functions like 'lv_subject_get_pointer'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_POINTER_lv_subject_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_POINTER_lv_subject_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_subject_get_pointer', 'type': {'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'subject', 'type': {'type': {'name': 'lv_subject_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 1, False), '_resolved_arg_types': [('lv_subject_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_POINTER_lv_subject_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_POINTER_lv_subject_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'POINTER')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('const char *',)
// Handles 1 functions like 'lv_version_info'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* result_buf;

    // Expecting 0 arguments from JSON array for function '{'name': 'lv_version_info', 'type': {'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': None, 'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg', 'quals': []}], '_resolved_ret_type': ('char', 1, False), '_resolved_arg_types': []}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func();

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'const char *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('const char *', 'const char *')
// Handles 5 functions like 'lv_strdup'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_const_char_p_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_const_char_p_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_strdup', 'type': {'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'src', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('char', 1, False), '_resolved_arg_types': [('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_const_char_p_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_const_char_p_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'const char *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('const char *', 'const char *', 'INT')
// Handles 2 functions like 'lv_strndup'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_const_char_p_const_char_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_const_char_p_const_char_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_strndup', 'type': {'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'src', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'max_len', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('char', 1, False), '_resolved_arg_types': [('char', 1, False), ('size_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_const_char_p_const_char_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_const_char_p_const_char_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_const_char_p_const_char_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_const_char_p_const_char_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'const char *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('const char *', 'const char *', 'const char *')
// Handles 2 functions like 'lv_strcpy'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_const_char_p_const_char_p_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_const_char_p_const_char_p_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_strcpy', 'type': {'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'dst', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'src', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('char', 1, False), '_resolved_arg_types': [('char', 1, False), ('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_const_char_p_const_char_p_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_const_char_p_const_char_p_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_const_char_p_const_char_p_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_const_char_p_const_char_p_const_char_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'const char *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('const char *', 'const char *', 'const char *', 'INT')
// Handles 2 functions like 'lv_strncpy'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_const_char_p_const_char_p_const_char_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_const_char_p_const_char_p_const_char_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_strncpy', 'type': {'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'dst', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'src', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'dest_size', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('char', 1, False), '_resolved_arg_types': [('char', 1, False), ('char', 1, False), ('size_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_const_char_p_const_char_p_const_char_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_const_char_p_const_char_p_const_char_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_const_char_p_const_char_p_const_char_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_const_char_p_const_char_p_const_char_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_const_char_p_const_char_p_const_char_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_const_char_p_const_char_p_const_char_p_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'const char *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('const char *', 'lv_obj_t *')
// Handles 10 functions like 'lv_label_get_text'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_const_char_p_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_const_char_p_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_label_get_text', 'type': {'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('char', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_const_char_p_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_const_char_p_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'const char *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('const char *', 'lv_obj_t *', 'INT')
// Handles 2 functions like 'lv_buttonmatrix_get_button_text'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_const_char_p_lv_obj_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_const_char_p_lv_obj_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_buttonmatrix_get_button_text', 'type': {'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'btn_id', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('char', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_const_char_p_lv_obj_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_const_char_p_lv_obj_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_const_char_p_lv_obj_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_const_char_p_lv_obj_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'const char *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('const char *', 'lv_obj_t *', 'INT', 'INT')
// Handles 1 functions like 'lv_table_get_cell_value'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_const_char_p_lv_obj_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_const_char_p_lv_obj_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_table_get_cell_value', 'type': {'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'row', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'col', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('char', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('uint32_t', 0, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_const_char_p_lv_obj_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_const_char_p_lv_obj_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_const_char_p_lv_obj_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_const_char_p_lv_obj_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_const_char_p_lv_obj_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_const_char_p_lv_obj_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'const char *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('const char *', 'lv_obj_t *', 'lv_obj_t *')
// Handles 1 functions like 'lv_list_get_button_text'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_const_char_p_lv_obj_t_p_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_const_char_p_lv_obj_t_p_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_list_get_button_text', 'type': {'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'list', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'btn', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('char', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_const_char_p_lv_obj_t_p_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_const_char_p_lv_obj_t_p_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_const_char_p_lv_obj_t_p_lv_obj_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_const_char_p_lv_obj_t_p_lv_obj_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'const char *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('const char *', 'lv_span_t *')
// Handles 1 functions like 'lv_span_get_text'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_const_char_p_lv_span_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_const_char_p_lv_span_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_span_get_text', 'type': {'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'span', 'type': {'type': {'name': 'lv_span_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('char', 1, False), '_resolved_arg_types': [('lv_span_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_const_char_p_lv_span_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_const_char_p_lv_span_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'const char *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('const char *', 'lv_subject_t *')
// Handles 2 functions like 'lv_subject_get_string'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_const_char_p_lv_subject_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_const_char_p_lv_subject_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_subject_get_string', 'type': {'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'subject', 'type': {'type': {'name': 'lv_subject_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('char', 1, False), '_resolved_arg_types': [('lv_subject_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_const_char_p_lv_subject_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_const_char_p_lv_subject_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'const char *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_anim_t *', 'lv_obj_t *', 'INT')
// Handles 1 functions like 'lv_obj_get_style_anim'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_anim_t_p_lv_obj_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_anim_t_p_lv_obj_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_get_style_anim', 'type': {'type': {'type': {'name': 'lv_anim_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'part', 'type': {'name': 'lv_part_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_anim_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_part_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_anim_t_p_lv_obj_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_anim_t_p_lv_obj_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_anim_t_p_lv_obj_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_anim_t_p_lv_obj_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_anim_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_cache_entry_t *', 'lv_image_decoder_t *', 'lv_image_cache_data_t *', 'lv_draw_buf_t *', 'POINTER')
// Handles 1 functions like 'lv_image_decoder_add_to_cache'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_cache_entry_t_p_lv_image_decoder_t_p_lv_image_cache_data_t_p_lv_draw_buf_t_p_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_cache_entry_t_p_lv_image_decoder_t_p_lv_image_cache_data_t_p_lv_draw_buf_t_p_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;
    void* arg_buf3;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_image_decoder_add_to_cache', 'type': {'type': {'type': {'name': 'lv_cache_entry_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'decoder', 'type': {'type': {'name': 'lv_image_decoder_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'search_key', 'type': {'type': {'name': 'lv_image_cache_data_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'decoded', 'type': {'type': {'name': 'lv_draw_buf_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'user_data', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_cache_entry_t', 1, False), '_resolved_arg_types': [('lv_image_decoder_t', 1, False), ('lv_image_cache_data_t', 1, False), ('lv_draw_buf_t', 1, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_cache_entry_t_p_lv_image_decoder_t_p_lv_image_cache_data_t_p_lv_draw_buf_t_p_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_lv_cache_entry_t_p_lv_image_decoder_t_p_lv_image_cache_data_t_p_lv_draw_buf_t_p_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_cache_entry_t_p_lv_image_decoder_t_p_lv_image_cache_data_t_p_lv_draw_buf_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_cache_entry_t_p_lv_image_decoder_t_p_lv_image_cache_data_t_p_lv_draw_buf_t_p_POINTER)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_lv_cache_entry_t_p_lv_image_decoder_t_p_lv_image_cache_data_t_p_lv_draw_buf_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_lv_cache_entry_t_p_lv_image_decoder_t_p_lv_image_cache_data_t_p_lv_draw_buf_t_p_POINTER)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_lv_cache_entry_t_p_lv_image_decoder_t_p_lv_image_cache_data_t_p_lv_draw_buf_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_lv_cache_entry_t_p_lv_image_decoder_t_p_lv_image_cache_data_t_p_lv_draw_buf_t_p_POINTER)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_cache_entry_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_chart_cursor_t *', 'lv_obj_t *', 'lv_color_t', 'INT')
// Handles 1 functions like 'lv_chart_add_cursor'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_chart_cursor_t_p_lv_obj_t_p_lv_color_t_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_chart_cursor_t_p_lv_obj_t_p_lv_color_t_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_chart_add_cursor', 'type': {'type': {'type': {'name': 'lv_chart_cursor_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'color', 'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'dir', 'type': {'name': 'lv_dir_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_chart_cursor_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_color_t', 0, False), ('lv_dir_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_chart_cursor_t_p_lv_obj_t_p_lv_color_t_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_lv_chart_cursor_t_p_lv_obj_t_p_lv_color_t_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_chart_cursor_t_p_lv_obj_t_p_lv_color_t_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_chart_cursor_t_p_lv_obj_t_p_lv_color_t_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_lv_chart_cursor_t_p_lv_obj_t_p_lv_color_t_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_lv_chart_cursor_t_p_lv_obj_t_p_lv_color_t_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_chart_cursor_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_chart_series_t *', 'lv_obj_t *', 'lv_chart_series_t *')
// Handles 1 functions like 'lv_chart_get_series_next'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_chart_series_t_p_lv_obj_t_p_lv_chart_series_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_chart_series_t_p_lv_obj_t_p_lv_chart_series_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_chart_get_series_next', 'type': {'type': {'type': {'name': 'lv_chart_series_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'chart', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'ser', 'type': {'type': {'name': 'lv_chart_series_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_chart_series_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_chart_series_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_chart_series_t_p_lv_obj_t_p_lv_chart_series_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_chart_series_t_p_lv_obj_t_p_lv_chart_series_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_chart_series_t_p_lv_obj_t_p_lv_chart_series_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_chart_series_t_p_lv_obj_t_p_lv_chart_series_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_chart_series_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_chart_series_t *', 'lv_obj_t *', 'lv_color_t', 'INT')
// Handles 1 functions like 'lv_chart_add_series'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_chart_series_t_p_lv_obj_t_p_lv_color_t_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_chart_series_t_p_lv_obj_t_p_lv_color_t_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_chart_add_series', 'type': {'type': {'type': {'name': 'lv_chart_series_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'color', 'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'axis', 'type': {'name': 'lv_chart_axis_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_chart_series_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_color_t', 0, False), ('lv_chart_axis_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_chart_series_t_p_lv_obj_t_p_lv_color_t_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_lv_chart_series_t_p_lv_obj_t_p_lv_color_t_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_chart_series_t_p_lv_obj_t_p_lv_color_t_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_chart_series_t_p_lv_obj_t_p_lv_color_t_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_lv_chart_series_t_p_lv_obj_t_p_lv_color_t_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_lv_chart_series_t_p_lv_obj_t_p_lv_color_t_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_chart_series_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_circle_buf_t *', 'INT', 'INT')
// Handles 1 functions like 'lv_circle_buf_create'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_circle_buf_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_circle_buf_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    int64_t arg_buf1;
    void* result_buf;

    // Expecting 2 arguments from JSON array for function '{'name': 'lv_circle_buf_create', 'type': {'type': {'type': {'name': 'lv_circle_buf_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'capacity', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'element_size', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_circle_buf_t', 1, False), '_resolved_arg_types': [('uint32_t', 0, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_circle_buf_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_lv_circle_buf_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_circle_buf_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_circle_buf_t_p_INT_INT)", specific_type_str0, entry->name);
        return false;
    }
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_lv_circle_buf_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg1, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_lv_circle_buf_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_circle_buf_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_circle_buf_t *', 'POINTER', 'INT', 'INT')
// Handles 1 functions like 'lv_circle_buf_create_from_buf'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_circle_buf_t_p_POINTER_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_circle_buf_t_p_POINTER_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_circle_buf_create_from_buf', 'type': {'type': {'type': {'name': 'lv_circle_buf_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'buf', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'capacity', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'element_size', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_circle_buf_t', 1, False), '_resolved_arg_types': [('void', 1, False), ('uint32_t', 0, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_circle_buf_t_p_POINTER_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_lv_circle_buf_t_p_POINTER_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_circle_buf_t_p_POINTER_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_circle_buf_t_p_POINTER_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_lv_circle_buf_t_p_POINTER_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_lv_circle_buf_t_p_POINTER_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_circle_buf_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_circle_buf_t *', 'lv_array_t *')
// Handles 1 functions like 'lv_circle_buf_create_from_array'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_circle_buf_t_p_lv_array_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_circle_buf_t_p_lv_array_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_circle_buf_create_from_array', 'type': {'type': {'type': {'name': 'lv_circle_buf_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'array', 'type': {'type': {'name': 'lv_array_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_circle_buf_t', 1, False), '_resolved_arg_types': [('lv_array_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_circle_buf_t_p_lv_array_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_circle_buf_t_p_lv_array_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_circle_buf_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_color_filter_dsc_t *', 'lv_obj_t *', 'INT')
// Handles 1 functions like 'lv_obj_get_style_color_filter_dsc'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_color_filter_dsc_t_p_lv_obj_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_color_filter_dsc_t_p_lv_obj_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_get_style_color_filter_dsc', 'type': {'type': {'type': {'name': 'lv_color_filter_dsc_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'part', 'type': {'name': 'lv_part_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_color_filter_dsc_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_part_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_color_filter_dsc_t_p_lv_obj_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_color_filter_dsc_t_p_lv_obj_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_color_filter_dsc_t_p_lv_obj_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_color_filter_dsc_t_p_lv_obj_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_color_filter_dsc_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_color_t',)
// Handles 2 functions like 'lv_color_white'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_color_t(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_color_t (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t result_buf;

    // Expecting 0 arguments from JSON array for function '{'name': 'lv_color_white', 'type': {'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': None, 'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg', 'quals': []}], '_resolved_ret_type': ('lv_color_t', 0, False), '_resolved_arg_types': []}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_color_t (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_color_t", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func();

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_color_t')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_color_t', 'INT')
// Handles 3 functions like 'lv_color_hex'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_color_t_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_color_t_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    int64_t result_buf;

    // Expecting 1 arguments from JSON array for function '{'name': 'lv_color_hex', 'type': {'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'c', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_color_t', 0, False), '_resolved_arg_types': [('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_color_t_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_color_t_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_color_t_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_color_t_INT)", specific_type_str0, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_color_t')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_color_t', 'INT', 'INT')
// Handles 2 functions like 'lv_palette_lighten'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_color_t_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_color_t_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    int64_t arg_buf1;
    int64_t result_buf;

    // Expecting 2 arguments from JSON array for function '{'name': 'lv_palette_lighten', 'type': {'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'p', 'type': {'name': 'lv_palette_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'lvl', 'type': {'name': 'uint8_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_color_t', 0, False), '_resolved_arg_types': [('lv_palette_t', 0, False), ('uint8_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_color_t_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_lv_color_t_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_color_t_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_color_t_INT_INT)", specific_type_str0, entry->name);
        return false;
    }
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_lv_color_t_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg1, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_lv_color_t_INT_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_color_t')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_color_t', 'INT', 'INT', 'INT')
// Handles 2 functions like 'lv_color_make'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_color_t_INT_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_color_t_INT_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t result_buf;

    // Expecting 3 arguments from JSON array for function '{'name': 'lv_color_make', 'type': {'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'r', 'type': {'name': 'uint8_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'g', 'type': {'name': 'uint8_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'b', 'type': {'name': 'uint8_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_color_t', 0, False), '_resolved_arg_types': [('uint8_t', 0, False), ('uint8_t', 0, False), ('uint8_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_color_t_INT_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_lv_color_t_INT_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_color_t_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_color_t_INT_INT_INT)", specific_type_str0, entry->name);
        return false;
    }
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_lv_color_t_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg1, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_lv_color_t_INT_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_lv_color_t_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg2, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_lv_color_t_INT_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(int64_t, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_color_t')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_color_t', 'lv_color_t', 'INT')
// Handles 2 functions like 'lv_color_lighten'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_color_t_lv_color_t_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_color_t_lv_color_t_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    int64_t arg_buf1;
    int64_t result_buf;

    // Expecting 2 arguments from JSON array for function '{'name': 'lv_color_lighten', 'type': {'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'c', 'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'lvl', 'type': {'name': 'lv_opa_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_color_t', 0, False), '_resolved_arg_types': [('lv_color_t', 0, False), ('lv_opa_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_color_t_lv_color_t_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_lv_color_t_lv_color_t_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_color_t_lv_color_t_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_color_t_lv_color_t_INT)", specific_type_str0, entry->name);
        return false;
    }
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_lv_color_t_lv_color_t_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg1, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_lv_color_t_lv_color_t_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_color_t')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_color_t', 'lv_color_t', 'lv_color_t', 'INT')
// Handles 1 functions like 'lv_color_mix'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_color_t_lv_color_t_lv_color_t_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_color_t_lv_color_t_lv_color_t_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t result_buf;

    // Expecting 3 arguments from JSON array for function '{'name': 'lv_color_mix', 'type': {'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'c1', 'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'c2', 'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'mix', 'type': {'name': 'uint8_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_color_t', 0, False), '_resolved_arg_types': [('lv_color_t', 0, False), ('lv_color_t', 0, False), ('uint8_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_color_t_lv_color_t_lv_color_t_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_lv_color_t_lv_color_t_lv_color_t_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_color_t_lv_color_t_lv_color_t_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_color_t_lv_color_t_lv_color_t_INT)", specific_type_str0, entry->name);
        return false;
    }
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_lv_color_t_lv_color_t_lv_color_t_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg1, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_lv_color_t_lv_color_t_lv_color_t_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_lv_color_t_lv_color_t_lv_color_t_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg2, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_lv_color_t_lv_color_t_lv_color_t_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(int64_t, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_color_t')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_color_t', 'lv_obj_t *', 'INT')
// Handles 23 functions like 'lv_obj_get_style_bg_color'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_color_t_lv_obj_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_color_t_lv_obj_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_get_style_bg_color', 'type': {'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'part', 'type': {'name': 'lv_part_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_color_t', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_part_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_color_t_lv_obj_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_color_t_lv_obj_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_color_t_lv_obj_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_color_t_lv_obj_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_color_t')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_color_t', 'lv_obj_t *', 'lv_chart_series_t *')
// Handles 1 functions like 'lv_chart_get_series_color'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_color_t_lv_obj_t_p_lv_chart_series_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_color_t_lv_obj_t_p_lv_chart_series_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_chart_get_series_color', 'type': {'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'chart', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'series', 'type': {'type': {'name': 'lv_chart_series_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_color_t', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_chart_series_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_color_t_lv_obj_t_p_lv_chart_series_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_color_t_lv_obj_t_p_lv_chart_series_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_color_t_lv_obj_t_p_lv_chart_series_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_color_t_lv_obj_t_p_lv_chart_series_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_color_t')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_color_t', 'lv_subject_t *')
// Handles 2 functions like 'lv_subject_get_color'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_color_t_lv_subject_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_color_t_lv_subject_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_subject_get_color', 'type': {'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'subject', 'type': {'type': {'name': 'lv_subject_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_color_t', 0, False), '_resolved_arg_types': [('lv_subject_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_color_t_lv_subject_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_color_t_lv_subject_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef int64_t (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_color_t')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(int64_t *)dest = (int64_t)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(int64_t *)dest = (int64_t)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than int64_t
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_display_t *', 'lv_obj_t *')
// Handles 1 functions like 'lv_obj_get_display'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_display_t_p_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_display_t_p_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_obj_get_display', 'type': {'type': {'type': {'name': 'lv_display_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_display_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_display_t_p_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_display_t_p_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_display_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_draw_buf_t *', 'lv_image_decoder_dsc_t *', 'lv_draw_buf_t *')
// Handles 1 functions like 'lv_image_decoder_post_process'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_draw_buf_t_p_lv_image_decoder_dsc_t_p_lv_draw_buf_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_draw_buf_t_p_lv_image_decoder_dsc_t_p_lv_draw_buf_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_image_decoder_post_process', 'type': {'type': {'type': {'name': 'lv_draw_buf_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'dsc', 'type': {'type': {'name': 'lv_image_decoder_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'decoded', 'type': {'type': {'name': 'lv_draw_buf_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_draw_buf_t', 1, False), '_resolved_arg_types': [('lv_image_decoder_dsc_t', 1, False), ('lv_draw_buf_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_draw_buf_t_p_lv_image_decoder_dsc_t_p_lv_draw_buf_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_draw_buf_t_p_lv_image_decoder_dsc_t_p_lv_draw_buf_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_draw_buf_t_p_lv_image_decoder_dsc_t_p_lv_draw_buf_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_draw_buf_t_p_lv_image_decoder_dsc_t_p_lv_draw_buf_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_draw_buf_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_draw_buf_t *', 'lv_obj_t *')
// Handles 1 functions like 'lv_canvas_get_draw_buf'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_draw_buf_t_p_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_draw_buf_t_p_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_canvas_get_draw_buf', 'type': {'type': {'type': {'name': 'lv_draw_buf_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_draw_buf_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_draw_buf_t_p_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_draw_buf_t_p_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_draw_buf_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_event_dsc_t *', 'lv_obj_t *', 'INT')
// Handles 1 functions like 'lv_obj_get_event_dsc'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_event_dsc_t_p_lv_obj_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_event_dsc_t_p_lv_obj_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_get_event_dsc', 'type': {'type': {'type': {'name': 'lv_event_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'index', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_event_dsc_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_event_dsc_t_p_lv_obj_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_event_dsc_t_p_lv_obj_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_event_dsc_t_p_lv_obj_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_event_dsc_t_p_lv_obj_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_event_dsc_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_event_dsc_t *', 'lv_obj_t *', 'INT', 'INT', 'POINTER')
// Handles 1 functions like 'lv_obj_add_event_cb'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_event_dsc_t_p_lv_obj_t_p_INT_INT_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_event_dsc_t_p_lv_obj_t_p_INT_INT_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    void* arg_buf3;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_obj_add_event_cb', 'type': {'type': {'type': {'name': 'lv_event_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'event_cb', 'type': {'name': 'lv_event_cb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'filter', 'type': {'name': 'lv_event_code_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'user_data', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_event_dsc_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_event_cb_t', 0, False), ('lv_event_code_t', 0, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_event_dsc_t_p_lv_obj_t_p_INT_INT_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_lv_event_dsc_t_p_lv_obj_t_p_INT_INT_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_event_dsc_t_p_lv_obj_t_p_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_event_dsc_t_p_lv_obj_t_p_INT_INT_POINTER)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_lv_event_dsc_t_p_lv_obj_t_p_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_lv_event_dsc_t_p_lv_obj_t_p_INT_INT_POINTER)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_lv_event_dsc_t_p_lv_obj_t_p_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_lv_event_dsc_t_p_lv_obj_t_p_INT_INT_POINTER)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_event_dsc_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_font_t *',)
// Handles 1 functions like 'lv_font_get_default'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_font_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_font_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* result_buf;

    // Expecting 0 arguments from JSON array for function '{'name': 'lv_font_get_default', 'type': {'type': {'type': {'name': 'lv_font_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': None, 'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg', 'quals': []}], '_resolved_ret_type': ('lv_font_t', 1, False), '_resolved_arg_types': []}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_font_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_font_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func();

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_font_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_font_t *', 'const char *')
// Handles 1 functions like 'lv_binfont_create'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_font_t_p_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_font_t_p_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_binfont_create', 'type': {'type': {'type': {'name': 'lv_font_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'path', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_font_t', 1, False), '_resolved_arg_types': [('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_font_t_p_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_font_t_p_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_font_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_font_t *', 'lv_obj_t *', 'INT')
// Handles 1 functions like 'lv_obj_get_style_text_font'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_font_t_p_lv_obj_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_font_t_p_lv_obj_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_get_style_text_font', 'type': {'type': {'type': {'name': 'lv_font_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'part', 'type': {'name': 'lv_part_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_font_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_part_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_font_t_p_lv_obj_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_font_t_p_lv_obj_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_font_t_p_lv_obj_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_font_t_p_lv_obj_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_font_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_fs_drv_t *', 'INT')
// Handles 1 functions like 'lv_fs_get_drv'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_fs_drv_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_fs_drv_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    void* result_buf;

    // Expecting 1 arguments from JSON array for function '{'name': 'lv_fs_get_drv', 'type': {'type': {'type': {'name': 'lv_fs_drv_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'letter', 'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_fs_drv_t', 1, False), '_resolved_arg_types': [('char', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_fs_drv_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_fs_drv_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_fs_drv_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_fs_drv_t_p_INT)", specific_type_str0, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_fs_drv_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_grad_dsc_t *', 'lv_obj_t *', 'INT')
// Handles 1 functions like 'lv_obj_get_style_bg_grad'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_grad_dsc_t_p_lv_obj_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_grad_dsc_t_p_lv_obj_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_get_style_bg_grad', 'type': {'type': {'type': {'name': 'lv_grad_dsc_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'part', 'type': {'name': 'lv_part_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_grad_dsc_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_part_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_grad_dsc_t_p_lv_obj_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_grad_dsc_t_p_lv_obj_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_grad_dsc_t_p_lv_obj_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_grad_dsc_t_p_lv_obj_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_grad_dsc_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_group_t *', 'lv_obj_t *')
// Handles 1 functions like 'lv_obj_get_group'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_group_t_p_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_group_t_p_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_obj_get_group', 'type': {'type': {'type': {'name': 'lv_group_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_group_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_group_t_p_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_group_t_p_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_group_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_image_decoder_t *',)
// Handles 1 functions like 'lv_image_decoder_create'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_image_decoder_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_image_decoder_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* result_buf;

    // Expecting 0 arguments from JSON array for function '{'name': 'lv_image_decoder_create', 'type': {'type': {'type': {'name': 'lv_image_decoder_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': None, 'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg', 'quals': []}], '_resolved_ret_type': ('lv_image_decoder_t', 1, False), '_resolved_arg_types': []}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_image_decoder_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_image_decoder_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func();

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_image_decoder_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_image_decoder_t *', 'lv_image_decoder_t *')
// Handles 1 functions like 'lv_image_decoder_get_next'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_image_decoder_t_p_lv_image_decoder_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_image_decoder_t_p_lv_image_decoder_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_image_decoder_get_next', 'type': {'type': {'type': {'name': 'lv_image_decoder_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'decoder', 'type': {'type': {'name': 'lv_image_decoder_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_image_decoder_t', 1, False), '_resolved_arg_types': [('lv_image_decoder_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_image_decoder_t_p_lv_image_decoder_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_image_decoder_t_p_lv_image_decoder_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_image_decoder_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_image_dsc_t *', 'lv_obj_t *')
// Handles 2 functions like 'lv_image_get_bitmap_map_src'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_image_dsc_t_p_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_image_dsc_t_p_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_image_get_bitmap_map_src', 'type': {'type': {'type': {'name': 'lv_image_dsc_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_image_dsc_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_image_dsc_t_p_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_image_dsc_t_p_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_image_dsc_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_iter_t *',)
// Handles 1 functions like 'lv_image_cache_iter_create'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_iter_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_iter_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* result_buf;

    // Expecting 0 arguments from JSON array for function '{'name': 'lv_image_cache_iter_create', 'type': {'type': {'type': {'name': 'lv_iter_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': None, 'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg', 'quals': []}], '_resolved_ret_type': ('lv_iter_t', 1, False), '_resolved_arg_types': []}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_iter_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_iter_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func();

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_iter_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_matrix_t *', 'lv_obj_t *')
// Handles 1 functions like 'lv_obj_get_transform'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_matrix_t_p_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_matrix_t_p_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_obj_get_transform', 'type': {'type': {'type': {'name': 'lv_matrix_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_matrix_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_matrix_t_p_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_matrix_t_p_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_matrix_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_obj_class_t *', 'lv_obj_t *')
// Handles 1 functions like 'lv_obj_get_class'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_obj_class_t_p_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_obj_class_t_p_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_obj_get_class', 'type': {'type': {'type': {'name': 'lv_obj_class_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_obj_class_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_obj_class_t_p_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_obj_class_t_p_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_obj_class_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_obj_t *',)
// Handles 4 functions like 'lv_screen_active'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* result_buf;

    // Expecting 0 arguments from JSON array for function '{'name': 'lv_screen_active', 'type': {'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': None, 'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg', 'quals': []}], '_resolved_ret_type': ('lv_obj_t', 1, False), '_resolved_arg_types': []}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func();

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_obj_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_obj_t *', 'lv_obj_t *')
// Handles 21 functions like 'lv_obj_get_screen'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_obj_t_p_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_obj_t_p_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_obj_get_screen', 'type': {'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_obj_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_obj_t_p_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_obj_t_p_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_obj_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_obj_t *', 'lv_obj_t *', 'INT')
// Handles 2 functions like 'lv_obj_get_child'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_obj_t_p_lv_obj_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_obj_t_p_lv_obj_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_get_child', 'type': {'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'idx', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_obj_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_obj_t_p_lv_obj_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_obj_t_p_lv_obj_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_obj_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_obj_t *', 'lv_obj_t *', 'INT', 'INT', 'INT')
// Handles 1 functions like 'lv_tileview_add_tile'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_obj_t_p_lv_obj_t_p_INT_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_obj_t_p_lv_obj_t_p_INT_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_tileview_add_tile', 'type': {'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'tv', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'col_id', 'type': {'name': 'uint8_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'row_id', 'type': {'name': 'uint8_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'dir', 'type': {'name': 'lv_dir_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_obj_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('uint8_t', 0, False), ('uint8_t', 0, False), ('lv_dir_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_obj_t_p_lv_obj_t_p_INT_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_lv_obj_t_p_lv_obj_t_p_INT_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_INT_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_INT_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_INT_INT_INT)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_obj_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_obj_t *', 'lv_obj_t *', 'INT', 'lv_obj_class_t *')
// Handles 2 functions like 'lv_obj_get_child_by_type'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_obj_t_p_lv_obj_t_p_INT_lv_obj_class_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_obj_t_p_lv_obj_t_p_INT_lv_obj_class_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_get_child_by_type', 'type': {'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'idx', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'class_p', 'type': {'type': {'name': 'lv_obj_class_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_obj_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('int32_t', 0, False), ('lv_obj_class_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_obj_t_p_lv_obj_t_p_INT_lv_obj_class_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_lv_obj_t_p_lv_obj_t_p_INT_lv_obj_class_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_INT_lv_obj_class_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_INT_lv_obj_class_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_INT_lv_obj_class_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_INT_lv_obj_class_t_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_obj_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_obj_t *', 'lv_obj_t *', 'POINTER')
// Handles 1 functions like 'lv_msgbox_add_header_button'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_obj_t_p_lv_obj_t_p_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_obj_t_p_lv_obj_t_p_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_msgbox_add_header_button', 'type': {'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'icon', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_obj_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_obj_t_p_lv_obj_t_p_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_obj_t_p_lv_obj_t_p_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_POINTER)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_obj_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_obj_t *', 'lv_obj_t *', 'POINTER', 'INT')
// Handles 1 functions like 'lv_win_add_button'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_obj_t_p_lv_obj_t_p_POINTER_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_obj_t_p_lv_obj_t_p_POINTER_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_win_add_button', 'type': {'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'win', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'icon', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'btn_w', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_obj_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('void', 1, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_obj_t_p_lv_obj_t_p_POINTER_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_lv_obj_t_p_lv_obj_t_p_POINTER_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_POINTER_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_POINTER_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_obj_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_obj_t *', 'lv_obj_t *', 'POINTER', 'const char *')
// Handles 1 functions like 'lv_list_add_button'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_obj_t_p_lv_obj_t_p_POINTER_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_obj_t_p_lv_obj_t_p_POINTER_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_list_add_button', 'type': {'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'list', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'icon', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'txt', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_obj_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('void', 1, False), ('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_obj_t_p_lv_obj_t_p_POINTER_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_lv_obj_t_p_lv_obj_t_p_POINTER_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_POINTER_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_POINTER_const_char_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_POINTER_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_POINTER_const_char_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_obj_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_obj_t *', 'lv_obj_t *', 'const char *')
// Handles 7 functions like 'lv_list_add_text'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_obj_t_p_lv_obj_t_p_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_obj_t_p_lv_obj_t_p_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_list_add_text', 'type': {'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'list', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'txt', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_obj_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_obj_t_p_lv_obj_t_p_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_obj_t_p_lv_obj_t_p_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_obj_t_p_lv_obj_t_p_const_char_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_obj_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_obj_t *', 'lv_observer_t *')
// Handles 1 functions like 'lv_observer_get_target_obj'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_obj_t_p_lv_observer_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_obj_t_p_lv_observer_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_observer_get_target_obj', 'type': {'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'observer', 'type': {'type': {'name': 'lv_observer_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_obj_t', 1, False), '_resolved_arg_types': [('lv_observer_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_obj_t_p_lv_observer_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_obj_t_p_lv_observer_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_obj_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_observer_t *', 'lv_obj_t *', 'lv_subject_t *')
// Handles 5 functions like 'lv_obj_bind_checked'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_bind_checked', 'type': {'type': {'type': {'name': 'lv_observer_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'subject', 'type': {'type': {'name': 'lv_subject_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_observer_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_subject_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_observer_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_observer_t *', 'lv_obj_t *', 'lv_subject_t *', 'INT', 'INT')
// Handles 12 functions like 'lv_obj_bind_flag_if_eq'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_obj_bind_flag_if_eq', 'type': {'type': {'type': {'name': 'lv_observer_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'subject', 'type': {'type': {'name': 'lv_subject_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'flag', 'type': {'name': 'lv_obj_flag_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'ref_value', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_observer_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_subject_t', 1, False), ('lv_obj_flag_t', 0, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_observer_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_observer_t *', 'lv_obj_t *', 'lv_subject_t *', 'const char *')
// Handles 1 functions like 'lv_label_bind_text'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_label_bind_text', 'type': {'type': {'type': {'name': 'lv_observer_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'subject', 'type': {'type': {'name': 'lv_subject_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'fmt', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_observer_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_subject_t', 1, False), ('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_const_char_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_const_char_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_observer_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_observer_t *', 'lv_subject_t *', 'INT', 'POINTER')
// Handles 1 functions like 'lv_subject_add_observer'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_subject_add_observer', 'type': {'type': {'type': {'name': 'lv_observer_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'subject', 'type': {'type': {'name': 'lv_subject_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'observer_cb', 'type': {'name': 'lv_observer_cb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'user_data', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_observer_t', 1, False), '_resolved_arg_types': [('lv_subject_t', 1, False), ('lv_observer_cb_t', 0, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_observer_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_observer_t *', 'lv_subject_t *', 'INT', 'POINTER', 'POINTER')
// Handles 1 functions like 'lv_subject_add_observer_with_target'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;
    void* arg_buf3;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_subject_add_observer_with_target', 'type': {'type': {'type': {'name': 'lv_observer_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'subject', 'type': {'type': {'name': 'lv_subject_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'observer_cb', 'type': {'name': 'lv_observer_cb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'target', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'user_data', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_observer_t', 1, False), '_resolved_arg_types': [('lv_subject_t', 1, False), ('lv_observer_cb_t', 0, False), ('void', 1, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER_POINTER)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER_POINTER)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER_POINTER)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_observer_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_observer_t *', 'lv_subject_t *', 'INT', 'lv_obj_t *', 'POINTER')
// Handles 1 functions like 'lv_subject_add_observer_obj'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_observer_t_p_lv_subject_t_p_INT_lv_obj_t_p_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_observer_t_p_lv_subject_t_p_INT_lv_obj_t_p_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;
    void* arg_buf3;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_subject_add_observer_obj', 'type': {'type': {'type': {'name': 'lv_observer_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'subject', 'type': {'type': {'name': 'lv_subject_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'observer_cb', 'type': {'name': 'lv_observer_cb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'user_data', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_observer_t', 1, False), '_resolved_arg_types': [('lv_subject_t', 1, False), ('lv_observer_cb_t', 0, False), ('lv_obj_t', 1, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_observer_t_p_lv_subject_t_p_INT_lv_obj_t_p_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_lv_observer_t_p_lv_subject_t_p_INT_lv_obj_t_p_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_observer_t_p_lv_subject_t_p_INT_lv_obj_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_observer_t_p_lv_subject_t_p_INT_lv_obj_t_p_POINTER)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_lv_observer_t_p_lv_subject_t_p_INT_lv_obj_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_lv_observer_t_p_lv_subject_t_p_INT_lv_obj_t_p_POINTER)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_lv_observer_t_p_lv_subject_t_p_INT_lv_obj_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_lv_observer_t_p_lv_subject_t_p_INT_lv_obj_t_p_POINTER)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_observer_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_point_precise_t *', 'lv_obj_t *')
// Handles 2 functions like 'lv_line_get_points'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_point_precise_t_p_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_point_precise_t_p_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_line_get_points', 'type': {'type': {'type': {'name': 'lv_point_precise_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_point_precise_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_point_precise_t_p_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_point_precise_t_p_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_point_precise_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_rb_node_t *', 'lv_rb_node_t *')
// Handles 2 functions like 'lv_rb_minimum_from'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_rb_node_t_p_lv_rb_node_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_rb_node_t_p_lv_rb_node_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_rb_minimum_from', 'type': {'type': {'type': {'name': 'lv_rb_node_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'node', 'type': {'type': {'name': 'lv_rb_node_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_rb_node_t', 1, False), '_resolved_arg_types': [('lv_rb_node_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_rb_node_t_p_lv_rb_node_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_rb_node_t_p_lv_rb_node_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_rb_node_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_rb_node_t *', 'lv_rb_t *')
// Handles 2 functions like 'lv_rb_minimum'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_rb_node_t_p_lv_rb_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_rb_node_t_p_lv_rb_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_rb_minimum', 'type': {'type': {'type': {'name': 'lv_rb_node_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'node', 'type': {'type': {'name': 'lv_rb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_rb_node_t', 1, False), '_resolved_arg_types': [('lv_rb_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_rb_node_t_p_lv_rb_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_rb_node_t_p_lv_rb_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_rb_node_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_rb_node_t *', 'lv_rb_t *', 'POINTER')
// Handles 2 functions like 'lv_rb_insert'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_rb_node_t_p_lv_rb_t_p_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_rb_node_t_p_lv_rb_t_p_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_rb_insert', 'type': {'type': {'type': {'name': 'lv_rb_node_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'tree', 'type': {'type': {'name': 'lv_rb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'key', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_rb_node_t', 1, False), '_resolved_arg_types': [('lv_rb_t', 1, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_rb_node_t_p_lv_rb_t_p_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_rb_node_t_p_lv_rb_t_p_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_rb_node_t_p_lv_rb_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_rb_node_t_p_lv_rb_t_p_POINTER)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_rb_node_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_scale_section_t *', 'lv_obj_t *')
// Handles 1 functions like 'lv_scale_add_section'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_scale_section_t_p_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_scale_section_t_p_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_scale_add_section', 'type': {'type': {'type': {'name': 'lv_scale_section_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_scale_section_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_scale_section_t_p_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_scale_section_t_p_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_scale_section_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_span_t *', 'lv_obj_t *')
// Handles 1 functions like 'lv_spangroup_add_span'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_span_t_p_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_span_t_p_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_spangroup_add_span', 'type': {'type': {'type': {'name': 'lv_span_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_span_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_span_t_p_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_span_t_p_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_span_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_span_t *', 'lv_obj_t *', 'INT')
// Handles 1 functions like 'lv_spangroup_get_child'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_span_t_p_lv_obj_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_span_t_p_lv_obj_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_spangroup_get_child', 'type': {'type': {'type': {'name': 'lv_span_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'id', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_span_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_span_t_p_lv_obj_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_span_t_p_lv_obj_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_span_t_p_lv_obj_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_span_t_p_lv_obj_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_span_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_span_t *', 'lv_obj_t *', 'lv_point_t *')
// Handles 1 functions like 'lv_spangroup_get_span_by_point'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_span_t_p_lv_obj_t_p_lv_point_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_span_t_p_lv_obj_t_p_lv_point_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_spangroup_get_span_by_point', 'type': {'type': {'type': {'name': 'lv_span_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'point', 'type': {'type': {'name': 'lv_point_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_span_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_point_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_span_t_p_lv_obj_t_p_lv_point_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_span_t_p_lv_obj_t_p_lv_point_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_span_t_p_lv_obj_t_p_lv_point_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_span_t_p_lv_obj_t_p_lv_point_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_span_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_style_t *', 'lv_span_t *')
// Handles 1 functions like 'lv_span_get_style'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_style_t_p_lv_span_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_style_t_p_lv_span_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_span_get_style', 'type': {'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'span', 'type': {'type': {'name': 'lv_span_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_style_t', 1, False), '_resolved_arg_types': [('lv_span_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_style_t_p_lv_span_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_lv_style_t_p_lv_span_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_style_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_style_transition_dsc_t *', 'lv_obj_t *', 'INT')
// Handles 1 functions like 'lv_obj_get_style_transition'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_style_transition_dsc_t_p_lv_obj_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_style_transition_dsc_t_p_lv_obj_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_get_style_transition', 'type': {'type': {'type': {'name': 'lv_style_transition_dsc_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'part', 'type': {'name': 'lv_part_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_style_transition_dsc_t', 1, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_part_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_style_transition_dsc_t_p_lv_obj_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_style_transition_dsc_t_p_lv_obj_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_style_transition_dsc_t_p_lv_obj_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_style_transition_dsc_t_p_lv_obj_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_style_transition_dsc_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_subject_t *', 'lv_subject_t *', 'INT')
// Handles 1 functions like 'lv_subject_get_group_element'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_subject_t_p_lv_subject_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_subject_t_p_lv_subject_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_subject_get_group_element', 'type': {'type': {'type': {'name': 'lv_subject_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'subject', 'type': {'type': {'name': 'lv_subject_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'index', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_subject_t', 1, False), '_resolved_arg_types': [('lv_subject_t', 1, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_subject_t_p_lv_subject_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_subject_t_p_lv_subject_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_subject_t_p_lv_subject_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_subject_t_p_lv_subject_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_subject_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('lv_tree_node_t *', 'lv_tree_class_t *', 'lv_tree_node_t *')
// Handles 1 functions like 'lv_tree_node_create'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_lv_tree_node_t_p_lv_tree_class_t_p_lv_tree_node_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_lv_tree_node_t_p_lv_tree_class_t_p_lv_tree_node_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* result_buf;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_tree_node_create', 'type': {'type': {'type': {'name': 'lv_tree_node_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'class_p', 'type': {'type': {'name': 'lv_tree_class_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'parent', 'type': {'type': {'name': 'lv_tree_node_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('lv_tree_node_t', 1, False), '_resolved_arg_types': [('lv_tree_class_t', 1, False), ('lv_tree_node_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_lv_tree_node_t_p_lv_tree_class_t_p_lv_tree_node_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_lv_tree_node_t_p_lv_tree_class_t_p_lv_tree_node_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_lv_tree_node_t_p_lv_tree_class_t_p_lv_tree_node_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_lv_tree_node_t_p_lv_tree_class_t_p_lv_tree_node_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void* (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    result_buf = target_func(arg_buf0, arg_buf1);

    // Store result (from result_buf) if dest is provided
    if (dest) {
        const char* specific_ret_type_str = entry->ret_type ? entry->ret_type : "void";
        // Copy result from buffer to dest (casting dest based on specific return type 'lv_tree_node_t *')
        // WARNING: Assumes calling convention compatibility & sufficient space at dest!
        if (strchr(specific_ret_type_str, '*')) { // Pointer type
             *(void**)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "float") == 0 || strcmp(specific_ret_type_str, "double") == 0) { // Float/Double
             *(void* *)dest = (void*)result_buf;
        } else if (strcmp(specific_ret_type_str, "void") != 0) { // Integer/Enum/Bool/Color?
             *(void* *)dest = (void*)result_buf;
             // TODO: Potential truncation/sign issues if specific_ret_type is smaller than void*
        }
    }

    return true;
}

// Generic Invoker for signature category: ('void',)
// Handles 13 functions like 'lv_init'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)

    // Expecting 0 arguments from JSON array for function '{'name': 'lv_init', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': None, 'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg', 'quals': []}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': []}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func();


    return true;
}

// Generic Invoker for signature category: ('void', 'BOOL')
// Handles 1 functions like 'lv_obj_enable_style_refresh'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_BOOL(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_BOOL (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;

    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_enable_style_refresh', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'en', 'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('bool', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_BOOL (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_BOOL", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_BOOL)", specific_type_str0, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'INT')
// Handles 6 functions like 'lv_mem_remove_pool'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;

    // Expecting 1 arguments from JSON array for function '{'name': 'lv_mem_remove_pool', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'pool', 'type': {'name': 'lv_mem_pool_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_mem_pool_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_INT)", specific_type_str0, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'INT', 'BOOL')
// Handles 1 functions like 'lv_image_cache_resize'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_INT_BOOL(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_INT_BOOL (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    int64_t arg_buf1;

    // Expecting 2 arguments from JSON array for function '{'name': 'lv_image_cache_resize', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'new_size', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'evict_now', 'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('uint32_t', 0, False), ('bool', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_INT_BOOL (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_INT_BOOL", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_INT_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_INT_BOOL)", specific_type_str0, entry->name);
        return false;
    }
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_INT_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg1, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_INT_BOOL)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'INT', 'lv_sqrt_res_t *', 'INT')
// Handles 1 functions like 'lv_sqrt'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_INT_lv_sqrt_res_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_INT_lv_sqrt_res_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    int64_t arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;

    // Expecting 3 arguments from JSON array for function '{'name': 'lv_sqrt', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'x', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'q', 'type': {'type': {'name': 'lv_sqrt_res_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'mask', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('uint32_t', 0, False), ('lv_sqrt_res_t', 1, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_INT_lv_sqrt_res_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_void_INT_lv_sqrt_res_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str0 = entry->arg_types[0];
    if (!specific_type_str0) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 0 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_INT_lv_sqrt_res_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 0 (using specific type 'specific_type_str0')
    if (!(unmarshal_value(json_arg0, specific_type_str0, (void*)&arg_buf0))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_INT_lv_sqrt_res_t_p_INT)", specific_type_str0, entry->name);
        return false;
    }
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_INT_lv_sqrt_res_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg1, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_INT_lv_sqrt_res_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_INT_lv_sqrt_res_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg2, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_INT_lv_sqrt_res_t_p_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(int64_t, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'POINTER')
// Handles 1 functions like 'lv_obj_null_on_delete'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_obj_null_on_delete', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj_ptr', 'type': {'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 2, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'POINTER', 'INT')
// Handles 1 functions like 'lv_memzero'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_POINTER_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_POINTER_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_memzero', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'dst', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'len', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('void', 1, False), ('size_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_POINTER_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_POINTER_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_POINTER_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'POINTER', 'INT', 'INT')
// Handles 1 functions like 'lv_memset'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_POINTER_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_POINTER_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_memset', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'dst', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'v', 'type': {'name': 'uint8_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'len', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('void', 1, False), ('uint8_t', 0, False), ('size_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_POINTER_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_POINTER_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_POINTER_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_POINTER_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_POINTER_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_POINTER_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_anim_t *')
// Handles 1 functions like 'lv_obj_delete_anim_completed_cb'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_anim_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_anim_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_obj_delete_anim_completed_cb', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'a', 'type': {'type': {'name': 'lv_anim_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_anim_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_anim_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_anim_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_area_t *', 'INT')
// Handles 2 functions like 'lv_area_set_width'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_area_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_area_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_area_set_width', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'area_p', 'type': {'type': {'name': 'lv_area_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'w', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_area_t', 1, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_area_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_area_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_area_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_area_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_area_t *', 'INT', 'INT')
// Handles 2 functions like 'lv_area_increase'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_area_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_area_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_area_increase', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'area', 'type': {'type': {'name': 'lv_area_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'w_extra', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'h_extra', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_area_t', 1, False), ('int32_t', 0, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_area_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_area_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_area_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_area_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_area_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_area_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_area_t *', 'INT', 'INT', 'INT', 'INT')
// Handles 1 functions like 'lv_area_set'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_area_t_p_INT_INT_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_area_t_p_INT_INT_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;
    int64_t arg_buf4;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 4 arguments from JSON array for function '{'name': 'lv_area_set', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'area_p', 'type': {'type': {'name': 'lv_area_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'x1', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'y1', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'x2', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'y2', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_area_t', 1, False), ('int32_t', 0, False), ('int32_t', 0, False), ('int32_t', 0, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (4 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_area_t_p_INT_INT_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 4) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 4 JSON args for func '%s', got %d for invoke_void_lv_area_t_p_INT_INT_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_area_t_p_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_area_t_p_INT_INT_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_area_t_p_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_area_t_p_INT_INT_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_area_t_p_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_area_t_p_INT_INT_INT_INT)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_void_lv_area_t_p_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg3, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_void_lv_area_t_p_INT_INT_INT_INT)", specific_type_str4, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_area_t *', 'lv_area_t *')
// Handles 1 functions like 'lv_area_copy'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_area_t_p_lv_area_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_area_t_p_lv_area_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_area_copy', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'dest', 'type': {'type': {'name': 'lv_area_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'src', 'type': {'type': {'name': 'lv_area_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_area_t', 1, False), ('lv_area_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_area_t_p_lv_area_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_area_t_p_lv_area_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_area_t_p_lv_area_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_area_t_p_lv_area_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_area_t *', 'lv_area_t *', 'INT', 'INT', 'INT')
// Handles 1 functions like 'lv_area_align'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_area_t_p_lv_area_t_p_INT_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_area_t_p_lv_area_t_p_INT_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;
    int64_t arg_buf4;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 4 arguments from JSON array for function '{'name': 'lv_area_align', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'base', 'type': {'type': {'name': 'lv_area_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'to_align', 'type': {'type': {'name': 'lv_area_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'align', 'type': {'name': 'lv_align_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'ofs_x', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'ofs_y', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_area_t', 1, False), ('lv_area_t', 1, False), ('lv_align_t', 0, False), ('int32_t', 0, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (4 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_area_t_p_lv_area_t_p_INT_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 4) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 4 JSON args for func '%s', got %d for invoke_void_lv_area_t_p_lv_area_t_p_INT_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_area_t_p_lv_area_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_area_t_p_lv_area_t_p_INT_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_area_t_p_lv_area_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_area_t_p_lv_area_t_p_INT_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_area_t_p_lv_area_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_area_t_p_lv_area_t_p_INT_INT_INT)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_void_lv_area_t_p_lv_area_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg3, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_void_lv_area_t_p_lv_area_t_p_INT_INT_INT)", specific_type_str4, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_array_t *')
// Handles 3 functions like 'lv_array_deinit'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_array_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_array_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_array_deinit', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'array', 'type': {'type': {'name': 'lv_array_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_array_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_array_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_array_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_array_t *', 'INT', 'INT')
// Handles 1 functions like 'lv_array_init'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_array_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_array_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_array_init', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'array', 'type': {'type': {'name': 'lv_array_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'capacity', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'element_size', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_array_t', 1, False), ('uint32_t', 0, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_array_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_array_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_array_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_array_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_array_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_array_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_array_t *', 'POINTER', 'INT', 'INT')
// Handles 1 functions like 'lv_array_init_from_buf'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_array_t_p_POINTER_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_array_t_p_POINTER_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_array_init_from_buf', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'array', 'type': {'type': {'name': 'lv_array_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'buf', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'capacity', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'element_size', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_array_t', 1, False), ('void', 1, False), ('uint32_t', 0, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_array_t_p_POINTER_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_void_lv_array_t_p_POINTER_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_array_t_p_POINTER_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_array_t_p_POINTER_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_array_t_p_POINTER_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_array_t_p_POINTER_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_array_t_p_POINTER_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_array_t_p_POINTER_INT_INT)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_array_t *', 'lv_array_t *')
// Handles 1 functions like 'lv_array_copy'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_array_t_p_lv_array_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_array_t_p_lv_array_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_array_copy', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'target', 'type': {'type': {'name': 'lv_array_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'source', 'type': {'type': {'name': 'lv_array_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_array_t', 1, False), ('lv_array_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_array_t_p_lv_array_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_array_t_p_lv_array_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_array_t_p_lv_array_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_array_t_p_lv_array_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_circle_buf_t *')
// Handles 2 functions like 'lv_circle_buf_destroy'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_circle_buf_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_circle_buf_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_circle_buf_destroy', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'circle_buf', 'type': {'type': {'name': 'lv_circle_buf_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_circle_buf_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_circle_buf_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_circle_buf_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_color16_t *', 'INT')
// Handles 1 functions like 'lv_color16_premultiply'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_color16_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_color16_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_color16_premultiply', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'c', 'type': {'type': {'name': 'lv_color16_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'a', 'type': {'name': 'lv_opa_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_color16_t', 1, False), ('lv_opa_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_color16_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_color16_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_color16_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_color16_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_color32_t *')
// Handles 1 functions like 'lv_color_premultiply'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_color32_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_color32_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_color_premultiply', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'c', 'type': {'type': {'name': 'lv_color32_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_color32_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_color32_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_color32_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_color_filter_dsc_t *', 'INT')
// Handles 1 functions like 'lv_color_filter_dsc_init'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_color_filter_dsc_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_color_filter_dsc_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_color_filter_dsc_init', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'dsc', 'type': {'type': {'name': 'lv_color_filter_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'cb', 'type': {'name': 'lv_color_filter_cb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_color_filter_dsc_t', 1, False), ('lv_color_filter_cb_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_color_filter_dsc_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_color_filter_dsc_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_color_filter_dsc_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_color_filter_dsc_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_display_t *')
// Handles 1 functions like 'lv_refr_now'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_display_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_display_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_refr_now', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'disp', 'type': {'type': {'name': 'lv_display_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_display_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_display_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_display_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_event_t *')
// Handles 1 functions like 'lv_keyboard_def_event_cb'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_event_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_event_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_keyboard_def_event_cb', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'e', 'type': {'type': {'name': 'lv_event_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_event_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_event_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_event_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_font_glyph_dsc_t *')
// Handles 1 functions like 'lv_font_glyph_release_draw_data'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_font_glyph_dsc_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_font_glyph_dsc_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_font_glyph_release_draw_data', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'g_dsc', 'type': {'type': {'name': 'lv_font_glyph_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_font_glyph_dsc_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_font_glyph_dsc_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_font_glyph_dsc_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_font_t *')
// Handles 1 functions like 'lv_binfont_destroy'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_font_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_font_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_binfont_destroy', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'font', 'type': {'type': {'name': 'lv_font_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_font_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_font_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_font_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_font_t *', 'INT')
// Handles 1 functions like 'lv_font_set_kerning'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_font_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_font_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_font_set_kerning', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'font', 'type': {'type': {'name': 'lv_font_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'kerning', 'type': {'name': 'lv_font_kerning_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_font_t', 1, False), ('lv_font_kerning_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_font_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_font_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_font_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_font_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_fs_drv_t *')
// Handles 2 functions like 'lv_fs_drv_init'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_fs_drv_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_fs_drv_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_fs_drv_init', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'drv', 'type': {'type': {'name': 'lv_fs_drv_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_fs_drv_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_fs_drv_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_fs_drv_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_fs_path_ex_t *', 'INT', 'POINTER', 'INT')
// Handles 1 functions like 'lv_fs_make_path_from_buffer'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_fs_path_ex_t_p_INT_POINTER_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_fs_path_ex_t_p_INT_POINTER_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;
    int64_t arg_buf3;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_fs_make_path_from_buffer', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'path', 'type': {'type': {'name': 'lv_fs_path_ex_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'letter', 'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'buf', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'size', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_fs_path_ex_t', 1, False), ('char', 0, False), ('void', 1, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_fs_path_ex_t_p_INT_POINTER_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_void_lv_fs_path_ex_t_p_INT_POINTER_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_fs_path_ex_t_p_INT_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_fs_path_ex_t_p_INT_POINTER_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_fs_path_ex_t_p_INT_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_fs_path_ex_t_p_INT_POINTER_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_fs_path_ex_t_p_INT_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_fs_path_ex_t_p_INT_POINTER_INT)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_grad_dsc_t *')
// Handles 2 functions like 'lv_grad_horizontal_init'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_grad_dsc_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_grad_dsc_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_grad_horizontal_init', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'dsc', 'type': {'type': {'name': 'lv_grad_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_grad_dsc_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_grad_dsc_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_grad_dsc_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_grad_dsc_t *', 'lv_color_t *', 'lv_opa_t *', 'POINTER', 'INT')
// Handles 1 functions like 'lv_grad_init_stops'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_grad_dsc_t_p_lv_color_t_p_lv_opa_t_p_POINTER_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_grad_dsc_t_p_lv_color_t_p_lv_opa_t_p_POINTER_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;
    void* arg_buf3;
    int64_t arg_buf4;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 4 arguments from JSON array for function '{'name': 'lv_grad_init_stops', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'grad', 'type': {'type': {'name': 'lv_grad_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'colors', 'type': {'name': 'lv_color_t', 'json_type': 'array', 'quals': ['const'], 'dim': None}, 'json_type': 'arg'}, {'name': 'opa', 'type': {'name': 'lv_opa_t', 'json_type': 'array', 'quals': ['const'], 'dim': None}, 'json_type': 'arg'}, {'name': 'fracs', 'type': {'name': 'uint8_t', 'json_type': 'array', 'quals': ['const'], 'dim': None}, 'json_type': 'arg'}, {'name': 'num_stops', 'type': {'name': 'int', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_grad_dsc_t', 1, False), ('lv_color_t', 1, True), ('lv_opa_t', 1, True), ('uint8_t', 1, True), ('int', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (4 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_grad_dsc_t_p_lv_color_t_p_lv_opa_t_p_POINTER_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 4) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 4 JSON args for func '%s', got %d for invoke_void_lv_grad_dsc_t_p_lv_color_t_p_lv_opa_t_p_POINTER_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_grad_dsc_t_p_lv_color_t_p_lv_opa_t_p_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_grad_dsc_t_p_lv_color_t_p_lv_opa_t_p_POINTER_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_grad_dsc_t_p_lv_color_t_p_lv_opa_t_p_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_grad_dsc_t_p_lv_color_t_p_lv_opa_t_p_POINTER_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_grad_dsc_t_p_lv_color_t_p_lv_opa_t_p_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_grad_dsc_t_p_lv_color_t_p_lv_opa_t_p_POINTER_INT)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_void_lv_grad_dsc_t_p_lv_color_t_p_lv_opa_t_p_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg3, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_void_lv_grad_dsc_t_p_lv_color_t_p_lv_opa_t_p_POINTER_INT)", specific_type_str4, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_image_decoder_dsc_t *')
// Handles 1 functions like 'lv_image_decoder_close'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_image_decoder_dsc_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_image_decoder_dsc_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_image_decoder_close', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'dsc', 'type': {'type': {'name': 'lv_image_decoder_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_image_decoder_dsc_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_image_decoder_dsc_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_image_decoder_dsc_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_image_decoder_t *')
// Handles 1 functions like 'lv_image_decoder_delete'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_image_decoder_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_image_decoder_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_image_decoder_delete', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'decoder', 'type': {'type': {'name': 'lv_image_decoder_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_image_decoder_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_image_decoder_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_image_decoder_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_image_decoder_t *', 'INT')
// Handles 4 functions like 'lv_image_decoder_set_info_cb'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_image_decoder_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_image_decoder_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_image_decoder_set_info_cb', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'decoder', 'type': {'type': {'name': 'lv_image_decoder_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'info_cb', 'type': {'name': 'lv_image_decoder_info_f_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_image_decoder_t', 1, False), ('lv_image_decoder_info_f_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_image_decoder_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_image_decoder_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_image_decoder_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_image_decoder_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_image_decoder_t *', 'lv_image_decoder_dsc_t *')
// Handles 1 functions like 'lv_bin_decoder_close'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_bin_decoder_close', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'decoder', 'type': {'type': {'name': 'lv_image_decoder_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'dsc', 'type': {'type': {'name': 'lv_image_decoder_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_image_decoder_t', 1, False), ('lv_image_decoder_dsc_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_image_dsc_t *')
// Handles 1 functions like 'lv_image_buf_free'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_image_dsc_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_image_dsc_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_image_buf_free', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'dsc', 'type': {'type': {'name': 'lv_image_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_image_dsc_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_image_dsc_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_image_dsc_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_image_dsc_t *', 'INT', 'INT')
// Handles 1 functions like 'lv_image_buf_set_palette'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_image_dsc_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_image_dsc_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_image_buf_set_palette', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'dsc', 'type': {'type': {'name': 'lv_image_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'id', 'type': {'name': 'uint8_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'c', 'type': {'name': 'lv_color32_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_image_dsc_t', 1, False), ('uint8_t', 0, False), ('lv_color32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_image_dsc_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_image_dsc_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_image_dsc_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_image_dsc_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_image_dsc_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_image_dsc_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_layer_t *')
// Handles 2 functions like 'lv_layer_init'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_layer_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_layer_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_layer_init', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'layer', 'type': {'type': {'name': 'lv_layer_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_layer_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_layer_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_layer_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_layer_t *', 'lv_obj_t *')
// Handles 1 functions like 'lv_obj_redraw'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_layer_t_p_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_layer_t_p_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_redraw', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'layer', 'type': {'type': {'name': 'lv_layer_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_layer_t', 1, False), ('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_layer_t_p_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_layer_t_p_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_layer_t_p_lv_obj_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_layer_t_p_lv_obj_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_ll_t *')
// Handles 1 functions like 'lv_ll_clear'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_ll_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_ll_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_ll_clear', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'll_p', 'type': {'type': {'name': 'lv_ll_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_ll_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_ll_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_ll_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_ll_t *', 'INT')
// Handles 1 functions like 'lv_ll_init'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_ll_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_ll_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_ll_init', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'll_p', 'type': {'type': {'name': 'lv_ll_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'node_size', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_ll_t', 1, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_ll_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_ll_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_ll_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_ll_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_ll_t *', 'POINTER')
// Handles 1 functions like 'lv_ll_remove'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_ll_t_p_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_ll_t_p_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_ll_remove', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'll_p', 'type': {'type': {'name': 'lv_ll_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'node_p', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_ll_t', 1, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_ll_t_p_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_ll_t_p_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_ll_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_ll_t_p_POINTER)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_ll_t *', 'POINTER', 'POINTER')
// Handles 1 functions like 'lv_ll_move_before'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_ll_t_p_POINTER_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_ll_t_p_POINTER_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_ll_move_before', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'll_p', 'type': {'type': {'name': 'lv_ll_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'n_act', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'n_after', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_ll_t', 1, False), ('void', 1, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_ll_t_p_POINTER_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_ll_t_p_POINTER_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_ll_t_p_POINTER_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_ll_t_p_POINTER_POINTER)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_ll_t_p_POINTER_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_ll_t_p_POINTER_POINTER)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_ll_t *', 'lv_ll_t *', 'POINTER', 'BOOL')
// Handles 1 functions like 'lv_ll_chg_list'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_ll_t_p_lv_ll_t_p_POINTER_BOOL(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_ll_t_p_lv_ll_t_p_POINTER_BOOL (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;
    int64_t arg_buf3;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_ll_chg_list', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'll_ori_p', 'type': {'type': {'name': 'lv_ll_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'll_new_p', 'type': {'type': {'name': 'lv_ll_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'node', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'head', 'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_ll_t', 1, False), ('lv_ll_t', 1, False), ('void', 1, False), ('bool', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_ll_t_p_lv_ll_t_p_POINTER_BOOL (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_void_lv_ll_t_p_lv_ll_t_p_POINTER_BOOL", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_ll_t_p_lv_ll_t_p_POINTER_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_ll_t_p_lv_ll_t_p_POINTER_BOOL)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_ll_t_p_lv_ll_t_p_POINTER_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_ll_t_p_lv_ll_t_p_POINTER_BOOL)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_ll_t_p_lv_ll_t_p_POINTER_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_ll_t_p_lv_ll_t_p_POINTER_BOOL)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_mem_monitor_t *')
// Handles 2 functions like 'lv_mem_monitor_core'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_mem_monitor_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_mem_monitor_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_mem_monitor_core', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'mon_p', 'type': {'type': {'name': 'lv_mem_monitor_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_mem_monitor_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_mem_monitor_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_mem_monitor_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *')
// Handles 37 functions like 'lv_screen_load'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_screen_load', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'scr', 'type': {'type': {'name': '_lv_obj_t', 'type': {'name': 'struct', 'json_type': 'primitive_type'}, 'json_type': 'forward_decl', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'BOOL')
// Handles 14 functions like 'lv_image_set_antialias'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_BOOL(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_BOOL (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_image_set_antialias', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'antialias', 'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('bool', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_BOOL (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_BOOL", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_BOOL)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'BOOL', 'INT')
// Handles 5 functions like 'lv_obj_set_style_bg_image_tiled'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_BOOL_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_BOOL_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_set_style_bg_image_tiled', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'selector', 'type': {'name': 'lv_style_selector_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('bool', 0, False), ('lv_style_selector_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_BOOL_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_BOOL_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_BOOL_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_BOOL_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_BOOL_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_BOOL_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'INT')
// Handles 85 functions like 'lv_obj_set_flex_flow'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_set_flex_flow', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'flow', 'type': {'name': 'lv_flex_flow_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_flex_flow_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'INT', 'BOOL')
// Handles 2 functions like 'lv_obj_set_flag'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_INT_BOOL(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_INT_BOOL (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_set_flag', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'f', 'type': {'name': 'lv_obj_flag_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'v', 'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_obj_flag_t', 0, False), ('bool', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_INT_BOOL (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_INT_BOOL", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_INT_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_BOOL)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_INT_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_BOOL)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'INT', 'INT')
// Handles 133 functions like 'lv_obj_set_grid_align'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_set_grid_align', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'column_align', 'type': {'name': 'lv_grid_align_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'row_align', 'type': {'name': 'lv_grid_align_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_grid_align_t', 0, False), ('lv_grid_align_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'INT', 'INT', 'BOOL')
// Handles 1 functions like 'lv_obj_move_children_by'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_INT_INT_BOOL(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_INT_INT_BOOL (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_obj_move_children_by', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'x_diff', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'y_diff', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'ignore_floating', 'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('int32_t', 0, False), ('int32_t', 0, False), ('bool', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_INT_INT_BOOL (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_INT_INT_BOOL", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_BOOL)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_BOOL)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_BOOL)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'INT', 'INT', 'INT')
// Handles 11 functions like 'lv_obj_set_flex_align'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_INT_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_INT_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_obj_set_flex_align', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'main_place', 'type': {'name': 'lv_flex_align_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'cross_place', 'type': {'name': 'lv_flex_align_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'track_cross_place', 'type': {'name': 'lv_flex_align_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_flex_align_t', 0, False), ('lv_flex_align_t', 0, False), ('lv_flex_align_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_INT_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_INT_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'INT', 'INT', 'INT', 'BOOL')
// Handles 1 functions like 'lv_screen_load_anim'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_INT_INT_INT_BOOL(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_INT_INT_INT_BOOL (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;
    int64_t arg_buf4;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 4 arguments from JSON array for function '{'name': 'lv_screen_load_anim', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'scr', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'anim_type', 'type': {'name': 'lv_screen_load_anim_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'time', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'delay', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'auto_del', 'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_screen_load_anim_t', 0, False), ('uint32_t', 0, False), ('uint32_t', 0, False), ('bool', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (4 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_INT_INT_INT_BOOL (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 4) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 4 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_INT_INT_INT_BOOL", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_BOOL)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_BOOL)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_BOOL)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg3, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_BOOL)", specific_type_str4, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'INT', 'INT', 'INT', 'INT', 'INT', 'INT')
// Handles 1 functions like 'lv_obj_set_grid_cell'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_INT_INT_INT_INT_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_INT_INT_INT_INT_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;
    int64_t arg_buf4;
    int64_t arg_buf5;
    int64_t arg_buf6;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 6 arguments from JSON array for function '{'name': 'lv_obj_set_grid_cell', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'column_align', 'type': {'name': 'lv_grid_align_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'col_pos', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'col_span', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'row_align', 'type': {'name': 'lv_grid_align_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'row_pos', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'row_span', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_grid_align_t', 0, False), ('int32_t', 0, False), ('int32_t', 0, False), ('lv_grid_align_t', 0, False), ('int32_t', 0, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (6 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_INT_INT_INT_INT_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 6) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 6 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_INT_INT_INT_INT_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_INT_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_INT_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_INT_INT_INT)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg3, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_INT_INT_INT)", specific_type_str4, entry->name);
        return false;
    }
    const char* specific_type_str5 = entry->arg_types[5];
    if (!specific_type_str5) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 5 of '%s'", entry->name); return false; }
    cJSON *json_arg4 = cJSON_GetArrayItem(args_array, 4);
    if (!json_arg4) { LOG_ERR("Invoke Error: Failed to get JSON arg 4 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 4 into C arg buffer 5 (using specific type 'specific_type_str5')
    if (!(unmarshal_value(json_arg4, specific_type_str5, (void*)&arg_buf5))) {
        LOG_ERR_JSON(json_arg4, "Invoke Error: Failed to unmarshal JSON arg 4 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_INT_INT_INT)", specific_type_str5, entry->name);
        return false;
    }
    const char* specific_type_str6 = entry->arg_types[6];
    if (!specific_type_str6) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 6 of '%s'", entry->name); return false; }
    cJSON *json_arg5 = cJSON_GetArrayItem(args_array, 5);
    if (!json_arg5) { LOG_ERR("Invoke Error: Failed to get JSON arg 5 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 5 into C arg buffer 6 (using specific type 'specific_type_str6')
    if (!(unmarshal_value(json_arg5, specific_type_str6, (void*)&arg_buf6))) {
        LOG_ERR_JSON(json_arg5, "Invoke Error: Failed to unmarshal JSON arg 5 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_INT_INT_INT_INT)", specific_type_str6, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t, int64_t, int64_t, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4, arg_buf5, arg_buf6);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'INT', 'INT', 'POINTER')
// Handles 1 functions like 'lv_table_set_cell_user_data'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_INT_INT_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_INT_INT_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    void* arg_buf3;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_table_set_cell_user_data', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'row', 'type': {'name': 'uint16_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'col', 'type': {'name': 'uint16_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'user_data', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('uint16_t', 0, False), ('uint16_t', 0, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_INT_INT_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_INT_INT_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_POINTER)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_POINTER)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_POINTER)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'INT', 'INT', 'const char *')
// Handles 1 functions like 'lv_table_set_cell_value'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_INT_INT_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_INT_INT_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    void* arg_buf3;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_table_set_cell_value', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'row', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'col', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'txt', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('uint32_t', 0, False), ('uint32_t', 0, False), ('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_INT_INT_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_INT_INT_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_const_char_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_const_char_p)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_const_char_p)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'INT', 'INT', 'lv_color_t', 'INT')
// Handles 1 functions like 'lv_canvas_set_px'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_INT_INT_lv_color_t_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_INT_INT_lv_color_t_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;
    int64_t arg_buf4;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 4 arguments from JSON array for function '{'name': 'lv_canvas_set_px', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'x', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'y', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'color', 'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'opa', 'type': {'name': 'lv_opa_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('int32_t', 0, False), ('int32_t', 0, False), ('lv_color_t', 0, False), ('lv_opa_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (4 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_INT_INT_lv_color_t_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 4) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 4 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_INT_INT_lv_color_t_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_lv_color_t_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_lv_color_t_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_lv_color_t_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_lv_color_t_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_lv_color_t_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_lv_color_t_INT)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_void_lv_obj_t_p_INT_INT_lv_color_t_INT)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg3, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_INT_lv_color_t_INT)", specific_type_str4, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'INT', 'POINTER')
// Handles 1 functions like 'lv_obj_tree_walk'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_INT_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_INT_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_tree_walk', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'start_obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'cb', 'type': {'name': 'lv_obj_tree_walk_cb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'user_data', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_obj_tree_walk_cb_t', 0, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_INT_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_INT_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_POINTER)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_POINTER)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'INT', 'POINTER', 'POINTER', 'POINTER')
// Handles 1 functions like 'lv_imagebutton_set_src'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_INT_POINTER_POINTER_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_INT_POINTER_POINTER_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;
    void* arg_buf3;
    void* arg_buf4;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 4 arguments from JSON array for function '{'name': 'lv_imagebutton_set_src', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'imagebutton', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'state', 'type': {'name': 'lv_imagebutton_state_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'src_left', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'src_mid', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'src_right', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_imagebutton_state_t', 0, False), ('void', 1, False), ('void', 1, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (4 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_INT_POINTER_POINTER_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 4) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 4 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_INT_POINTER_POINTER_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_INT_POINTER_POINTER_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_POINTER_POINTER_POINTER)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_INT_POINTER_POINTER_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_POINTER_POINTER_POINTER)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_INT_POINTER_POINTER_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_POINTER_POINTER_POINTER)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_void_lv_obj_t_p_INT_POINTER_POINTER_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg3, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_POINTER_POINTER_POINTER)", specific_type_str4, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, void*, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'INT', 'const char *')
// Handles 2 functions like 'lv_label_ins_text'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_INT_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_INT_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_label_ins_text', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'pos', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'txt', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('uint32_t', 0, False), ('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_INT_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_INT_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_INT_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_const_char_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_INT_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_const_char_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'INT', 'lv_draw_arc_dsc_t *')
// Handles 1 functions like 'lv_obj_init_draw_arc_dsc'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_INT_lv_draw_arc_dsc_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_INT_lv_draw_arc_dsc_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_init_draw_arc_dsc', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'part', 'type': {'name': 'lv_part_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'draw_dsc', 'type': {'type': {'name': 'lv_draw_arc_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_part_t', 0, False), ('lv_draw_arc_dsc_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_INT_lv_draw_arc_dsc_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_INT_lv_draw_arc_dsc_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_arc_dsc_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_arc_dsc_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_arc_dsc_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_arc_dsc_t_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'INT', 'lv_draw_image_dsc_t *')
// Handles 1 functions like 'lv_obj_init_draw_image_dsc'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_INT_lv_draw_image_dsc_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_INT_lv_draw_image_dsc_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_init_draw_image_dsc', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'part', 'type': {'name': 'lv_part_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'draw_dsc', 'type': {'type': {'name': 'lv_draw_image_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_part_t', 0, False), ('lv_draw_image_dsc_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_INT_lv_draw_image_dsc_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_INT_lv_draw_image_dsc_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_image_dsc_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_image_dsc_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_image_dsc_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_image_dsc_t_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'INT', 'lv_draw_label_dsc_t *')
// Handles 1 functions like 'lv_obj_init_draw_label_dsc'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_INT_lv_draw_label_dsc_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_INT_lv_draw_label_dsc_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_init_draw_label_dsc', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'part', 'type': {'name': 'lv_part_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'draw_dsc', 'type': {'type': {'name': 'lv_draw_label_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_part_t', 0, False), ('lv_draw_label_dsc_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_INT_lv_draw_label_dsc_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_INT_lv_draw_label_dsc_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_label_dsc_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_label_dsc_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_label_dsc_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_label_dsc_t_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'INT', 'lv_draw_line_dsc_t *')
// Handles 1 functions like 'lv_obj_init_draw_line_dsc'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_INT_lv_draw_line_dsc_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_INT_lv_draw_line_dsc_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_init_draw_line_dsc', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'part', 'type': {'name': 'lv_part_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'draw_dsc', 'type': {'type': {'name': 'lv_draw_line_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_part_t', 0, False), ('lv_draw_line_dsc_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_INT_lv_draw_line_dsc_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_INT_lv_draw_line_dsc_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_line_dsc_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_line_dsc_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_line_dsc_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_line_dsc_t_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'INT', 'lv_draw_rect_dsc_t *')
// Handles 1 functions like 'lv_obj_init_draw_rect_dsc'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_INT_lv_draw_rect_dsc_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_INT_lv_draw_rect_dsc_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_init_draw_rect_dsc', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'part', 'type': {'name': 'lv_part_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'draw_dsc', 'type': {'type': {'name': 'lv_draw_rect_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_part_t', 0, False), ('lv_draw_rect_dsc_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_INT_lv_draw_rect_dsc_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_INT_lv_draw_rect_dsc_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_rect_dsc_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_rect_dsc_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_rect_dsc_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_lv_draw_rect_dsc_t_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'INT', 'lv_point_t *')
// Handles 1 functions like 'lv_label_get_letter_pos'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_INT_lv_point_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_INT_lv_point_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_label_get_letter_pos', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'char_id', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'pos', 'type': {'type': {'name': 'lv_point_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('uint32_t', 0, False), ('lv_point_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_INT_lv_point_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_INT_lv_point_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_INT_lv_point_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_lv_point_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_INT_lv_point_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_INT_lv_point_t_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'POINTER')
// Handles 3 functions like 'lv_obj_set_user_data'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_set_user_data', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'user_data', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_POINTER)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'POINTER', 'INT')
// Handles 5 functions like 'lv_obj_set_style_bg_image_src'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_POINTER_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_POINTER_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_set_style_bg_image_src', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'selector', 'type': {'name': 'lv_style_selector_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('void', 1, False), ('lv_style_selector_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_POINTER_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_POINTER_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_POINTER_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_POINTER_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'POINTER', 'INT', 'INT', 'INT')
// Handles 1 functions like 'lv_canvas_set_buffer'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_POINTER_INT_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_POINTER_INT_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;
    int64_t arg_buf4;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 4 arguments from JSON array for function '{'name': 'lv_canvas_set_buffer', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'buf', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'w', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'h', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'cf', 'type': {'name': 'lv_color_format_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('void', 1, False), ('int32_t', 0, False), ('int32_t', 0, False), ('lv_color_format_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (4 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_POINTER_INT_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 4) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 4 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_POINTER_INT_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_POINTER_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_POINTER_INT_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_POINTER_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_POINTER_INT_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_POINTER_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_POINTER_INT_INT_INT)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_void_lv_obj_t_p_POINTER_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg3, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_POINTER_INT_INT_INT)", specific_type_str4, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'POINTER', 'POINTER')
// Handles 2 functions like 'lv_obj_set_grid_dsc_array'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_POINTER_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_POINTER_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_set_grid_dsc_array', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'col_dsc', 'type': {'name': 'int32_t', 'json_type': 'array', 'quals': ['const'], 'dim': None}, 'json_type': 'arg'}, {'name': 'row_dsc', 'type': {'name': 'int32_t', 'json_type': 'array', 'quals': ['const'], 'dim': None}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('int32_t', 1, True), ('int32_t', 1, True)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_POINTER_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_POINTER_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_POINTER_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_POINTER_POINTER)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_POINTER_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_POINTER_POINTER)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'const char *')
// Handles 15 functions like 'lv_label_set_text'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_label_set_text', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'text', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_const_char_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'const char *', 'INT')
// Handles 4 functions like 'lv_dropdown_add_option'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_const_char_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_const_char_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_dropdown_add_option', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'option', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'pos', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('char', 1, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_const_char_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_const_char_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_const_char_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_const_char_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_const_char_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_const_char_p_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_anim_t *', 'INT')
// Handles 1 functions like 'lv_obj_set_style_anim'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_anim_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_anim_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_set_style_anim', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'type': {'name': 'lv_anim_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'selector', 'type': {'name': 'lv_style_selector_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_anim_t', 1, False), ('lv_style_selector_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_anim_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_anim_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_anim_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_anim_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_anim_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_anim_t_p_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_area_t *')
// Handles 4 functions like 'lv_obj_get_coords'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_area_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_area_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_get_coords', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'coords', 'type': {'type': {'name': 'lv_area_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_area_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_area_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_area_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_area_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_area_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_area_t *', 'INT')
// Handles 1 functions like 'lv_obj_get_transformed_area'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_area_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_area_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_get_transformed_area', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'area', 'type': {'type': {'name': 'lv_area_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'flags', 'type': {'name': 'lv_obj_point_transform_flag_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_area_t', 1, False), ('lv_obj_point_transform_flag_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_area_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_area_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_area_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_area_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_area_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_area_t_p_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_area_t *', 'lv_area_t *')
// Handles 1 functions like 'lv_obj_get_scrollbar_area'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_area_t_p_lv_area_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_area_t_p_lv_area_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_get_scrollbar_area', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'hor', 'type': {'type': {'name': 'lv_area_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'ver', 'type': {'type': {'name': 'lv_area_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_area_t', 1, False), ('lv_area_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_area_t_p_lv_area_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_area_t_p_lv_area_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_area_t_p_lv_area_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_area_t_p_lv_area_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_area_t_p_lv_area_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_area_t_p_lv_area_t_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_area_t *', 'lv_draw_buf_t *', 'lv_area_t *')
// Handles 1 functions like 'lv_canvas_copy_buf'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_area_t_p_lv_draw_buf_t_p_lv_area_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_area_t_p_lv_draw_buf_t_p_lv_area_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;
    void* arg_buf3;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_canvas_copy_buf', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'canvas_area', 'type': {'type': {'name': 'lv_area_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'dest_buf', 'type': {'type': {'name': 'lv_draw_buf_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'dest_area', 'type': {'type': {'name': 'lv_area_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_area_t', 1, False), ('lv_draw_buf_t', 1, False), ('lv_area_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_area_t_p_lv_draw_buf_t_p_lv_area_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_area_t_p_lv_draw_buf_t_p_lv_area_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_area_t_p_lv_draw_buf_t_p_lv_area_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_area_t_p_lv_draw_buf_t_p_lv_area_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_area_t_p_lv_draw_buf_t_p_lv_area_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_area_t_p_lv_draw_buf_t_p_lv_area_t_p)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_lv_area_t_p_lv_draw_buf_t_p_lv_area_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_area_t_p_lv_draw_buf_t_p_lv_area_t_p)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_buttonmatrix_ctrl_t *')
// Handles 1 functions like 'lv_buttonmatrix_set_ctrl_map'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_buttonmatrix_ctrl_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_buttonmatrix_ctrl_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_buttonmatrix_set_ctrl_map', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'ctrl_map', 'type': {'name': 'lv_buttonmatrix_ctrl_t', 'json_type': 'array', 'quals': ['const'], 'dim': None}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_buttonmatrix_ctrl_t', 1, True)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_buttonmatrix_ctrl_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_buttonmatrix_ctrl_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_buttonmatrix_ctrl_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_buttonmatrix_ctrl_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_chart_cursor_t *', 'lv_chart_series_t *', 'INT')
// Handles 1 functions like 'lv_chart_set_cursor_point'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_chart_series_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_chart_series_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;
    int64_t arg_buf3;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_chart_set_cursor_point', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'chart', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'cursor', 'type': {'type': {'name': 'lv_chart_cursor_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'ser', 'type': {'type': {'name': 'lv_chart_series_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'point_id', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_chart_cursor_t', 1, False), ('lv_chart_series_t', 1, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_chart_series_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_chart_series_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_chart_series_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_chart_series_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_chart_series_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_chart_series_t_p_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_chart_series_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_chart_series_t_p_INT)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_chart_cursor_t *', 'lv_point_t *')
// Handles 1 functions like 'lv_chart_set_cursor_pos'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_point_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_point_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_chart_set_cursor_pos', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'chart', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'cursor', 'type': {'type': {'name': 'lv_chart_cursor_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'pos', 'type': {'type': {'name': 'lv_point_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_chart_cursor_t', 1, False), ('lv_point_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_point_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_point_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_point_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_point_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_point_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_point_t_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_chart_series_t *')
// Handles 1 functions like 'lv_chart_remove_series'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_chart_series_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_chart_series_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_chart_remove_series', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'series', 'type': {'type': {'name': 'lv_chart_series_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_chart_series_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_chart_series_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_chart_series_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_chart_series_t *', 'BOOL')
// Handles 1 functions like 'lv_chart_hide_series'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_chart_series_t_p_BOOL(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_chart_series_t_p_BOOL (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_chart_hide_series', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'chart', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'series', 'type': {'type': {'name': 'lv_chart_series_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'hide', 'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_chart_series_t', 1, False), ('bool', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_chart_series_t_p_BOOL (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_chart_series_t_p_BOOL", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_BOOL)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_BOOL)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_chart_series_t *', 'INT')
// Handles 3 functions like 'lv_chart_set_x_start_point'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_chart_set_x_start_point', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'ser', 'type': {'type': {'name': 'lv_chart_series_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'id', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_chart_series_t', 1, False), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_chart_series_t *', 'INT', 'INT')
// Handles 2 functions like 'lv_chart_set_next_value2'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_chart_set_next_value2', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'ser', 'type': {'type': {'name': 'lv_chart_series_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'x_value', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'y_value', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_chart_series_t', 1, False), ('int32_t', 0, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_chart_series_t *', 'INT', 'INT', 'INT')
// Handles 1 functions like 'lv_chart_set_series_value_by_id2'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;
    int64_t arg_buf4;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 4 arguments from JSON array for function '{'name': 'lv_chart_set_series_value_by_id2', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'ser', 'type': {'type': {'name': 'lv_chart_series_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'id', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'x_value', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'y_value', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_chart_series_t', 1, False), ('uint32_t', 0, False), ('int32_t', 0, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (4 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 4) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 4 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT_INT)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg3, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT_INT)", specific_type_str4, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_chart_series_t *', 'INT', 'lv_point_t *')
// Handles 1 functions like 'lv_chart_get_point_pos_by_id'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_lv_point_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_lv_point_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    void* arg_buf3;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_chart_get_point_pos_by_id', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'ser', 'type': {'type': {'name': 'lv_chart_series_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'id', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'p_out', 'type': {'type': {'name': 'lv_point_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_chart_series_t', 1, False), ('uint32_t', 0, False), ('lv_point_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_lv_point_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_lv_point_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_lv_point_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_lv_point_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_lv_point_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_lv_point_t_p)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_lv_point_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_lv_point_t_p)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_chart_series_t *', 'POINTER')
// Handles 2 functions like 'lv_chart_set_series_ext_y_array'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_chart_set_series_ext_y_array', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'ser', 'type': {'type': {'name': 'lv_chart_series_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'array', 'type': {'name': 'int32_t', 'json_type': 'array', 'quals': [], 'dim': None}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_chart_series_t', 1, False), ('int32_t', 1, True)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_chart_series_t *', 'POINTER', 'INT')
// Handles 1 functions like 'lv_chart_set_series_values'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;
    int64_t arg_buf3;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_chart_set_series_values', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'ser', 'type': {'type': {'name': 'lv_chart_series_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'values', 'type': {'name': 'int32_t', 'json_type': 'array', 'quals': ['const'], 'dim': None}, 'json_type': 'arg'}, {'name': 'values_cnt', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_chart_series_t', 1, False), ('int32_t', 1, True), ('size_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_INT)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_chart_series_t *', 'POINTER', 'POINTER', 'INT')
// Handles 1 functions like 'lv_chart_set_series_values2'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_POINTER_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_POINTER_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;
    void* arg_buf3;
    int64_t arg_buf4;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 4 arguments from JSON array for function '{'name': 'lv_chart_set_series_values2', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'ser', 'type': {'type': {'name': 'lv_chart_series_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'x_values', 'type': {'name': 'int32_t', 'json_type': 'array', 'quals': ['const'], 'dim': None}, 'json_type': 'arg'}, {'name': 'y_values', 'type': {'name': 'int32_t', 'json_type': 'array', 'quals': ['const'], 'dim': None}, 'json_type': 'arg'}, {'name': 'values_cnt', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_chart_series_t', 1, False), ('int32_t', 1, True), ('int32_t', 1, True), ('size_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (4 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_POINTER_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 4) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 4 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_POINTER_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_POINTER_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_POINTER_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_POINTER_INT)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_POINTER_INT)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg3, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_POINTER_INT)", specific_type_str4, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_chart_series_t *', 'lv_color_t')
// Handles 1 functions like 'lv_chart_set_series_color'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_chart_series_t_p_lv_color_t(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_chart_series_t_p_lv_color_t (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_chart_set_series_color', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'chart', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'series', 'type': {'type': {'name': 'lv_chart_series_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'color', 'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_chart_series_t', 1, False), ('lv_color_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_chart_series_t_p_lv_color_t (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_chart_series_t_p_lv_color_t", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_lv_color_t)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_lv_color_t)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_lv_color_t)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_chart_series_t_p_lv_color_t)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_color_filter_dsc_t *', 'INT')
// Handles 1 functions like 'lv_obj_set_style_color_filter_dsc'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_color_filter_dsc_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_color_filter_dsc_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_set_style_color_filter_dsc', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'type': {'name': 'lv_color_filter_dsc_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'selector', 'type': {'name': 'lv_style_selector_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_color_filter_dsc_t', 1, False), ('lv_style_selector_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_color_filter_dsc_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_color_filter_dsc_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_color_filter_dsc_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_color_filter_dsc_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_color_filter_dsc_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_color_filter_dsc_t_p_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_color_t', 'INT')
// Handles 13 functions like 'lv_obj_set_style_bg_color'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_color_t_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_color_t_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_set_style_bg_color', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'selector', 'type': {'name': 'lv_style_selector_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_color_t', 0, False), ('lv_style_selector_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_color_t_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_color_t_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_color_t_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_color_t_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_color_t_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_color_t_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_draw_buf_t *')
// Handles 1 functions like 'lv_canvas_set_draw_buf'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_draw_buf_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_draw_buf_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_canvas_set_draw_buf', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'draw_buf', 'type': {'type': {'name': 'lv_draw_buf_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_draw_buf_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_draw_buf_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_draw_buf_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_draw_buf_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_draw_buf_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_font_t *', 'INT')
// Handles 1 functions like 'lv_obj_set_style_text_font'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_font_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_font_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_set_style_text_font', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'type': {'name': 'lv_font_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'selector', 'type': {'name': 'lv_style_selector_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_font_t', 1, False), ('lv_style_selector_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_font_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_font_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_font_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_font_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_font_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_font_t_p_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_grad_dsc_t *', 'INT')
// Handles 1 functions like 'lv_obj_set_style_bg_grad'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_grad_dsc_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_grad_dsc_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_set_style_bg_grad', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'type': {'name': 'lv_grad_dsc_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'selector', 'type': {'name': 'lv_style_selector_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_grad_dsc_t', 1, False), ('lv_style_selector_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_grad_dsc_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_grad_dsc_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_grad_dsc_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_grad_dsc_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_grad_dsc_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_grad_dsc_t_p_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_image_dsc_t *')
// Handles 1 functions like 'lv_image_set_bitmap_map_src'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_image_dsc_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_image_dsc_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_image_set_bitmap_map_src', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'src', 'type': {'type': {'name': 'lv_image_dsc_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_image_dsc_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_image_dsc_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_image_dsc_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_image_dsc_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_image_dsc_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_layer_t *')
// Handles 2 functions like 'lv_canvas_init_layer'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_layer_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_layer_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_canvas_init_layer', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'canvas', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'layer', 'type': {'type': {'name': 'lv_layer_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_layer_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_layer_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_layer_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_layer_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_layer_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_matrix_t *')
// Handles 1 functions like 'lv_obj_set_transform'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_matrix_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_matrix_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_set_transform', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'matrix', 'type': {'type': {'name': 'lv_matrix_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_matrix_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_matrix_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_matrix_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_matrix_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_matrix_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_obj_t *')
// Handles 5 functions like 'lv_obj_set_parent'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_set_parent', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'parent', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_obj_t *', 'INT')
// Handles 4 functions like 'lv_arc_align_obj_to_angle'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_obj_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_obj_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_arc_align_obj_to_angle', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'obj_to_align', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'r_offset', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_obj_t', 1, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_obj_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_obj_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_obj_t *', 'INT', 'INT')
// Handles 1 functions like 'lv_scale_set_line_needle_value'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_scale_set_line_needle_value', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'needle_line', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'needle_length', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_obj_t', 1, False), ('int32_t', 0, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_obj_t *', 'INT', 'INT', 'INT')
// Handles 1 functions like 'lv_obj_align_to'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;
    int64_t arg_buf4;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 4 arguments from JSON array for function '{'name': 'lv_obj_align_to', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'base', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'align', 'type': {'name': 'lv_align_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'x_ofs', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'y_ofs', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_obj_t', 1, False), ('lv_align_t', 0, False), ('int32_t', 0, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (4 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 4) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 4 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT_INT)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg3, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT_INT)", specific_type_str4, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_obj_t *', 'const char *')
// Handles 1 functions like 'lv_list_set_button_text'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_obj_t_p_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_obj_t_p_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_list_set_button_text', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'list', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'btn', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'txt', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_obj_t', 1, False), ('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_obj_t_p_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_obj_t_p_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_const_char_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_const_char_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_obj_t *', 'lv_obj_t *')
// Handles 1 functions like 'lv_menu_set_load_page_event'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_obj_t_p_lv_obj_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_obj_t_p_lv_obj_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_menu_set_load_page_event', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'menu', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'page', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_obj_t', 1, False), ('lv_obj_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_obj_t_p_lv_obj_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_obj_t_p_lv_obj_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_lv_obj_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_lv_obj_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_lv_obj_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_obj_t_p_lv_obj_t_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_point_precise_t *', 'INT')
// Handles 2 functions like 'lv_line_set_points'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_point_precise_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_point_precise_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_line_set_points', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'points', 'type': {'name': 'lv_point_precise_t', 'json_type': 'array', 'quals': ['const'], 'dim': None}, 'json_type': 'arg'}, {'name': 'point_num', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_point_precise_t', 1, True), ('uint32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_point_precise_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_point_precise_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_point_precise_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_point_precise_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_point_precise_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_point_precise_t_p_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_point_t *')
// Handles 2 functions like 'lv_obj_get_scroll_end'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_point_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_point_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_get_scroll_end', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'end', 'type': {'type': {'name': 'lv_point_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_point_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_point_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_point_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_point_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_point_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_point_t *', 'INT')
// Handles 1 functions like 'lv_obj_transform_point'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_point_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_point_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_transform_point', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'p', 'type': {'type': {'name': 'lv_point_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'flags', 'type': {'name': 'lv_obj_point_transform_flag_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_point_t', 1, False), ('lv_obj_point_transform_flag_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_point_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_point_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_point_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_point_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_point_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_point_t_p_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_point_t *', 'INT', 'INT')
// Handles 1 functions like 'lv_obj_transform_point_array'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_point_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_point_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_obj_transform_point_array', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'points', 'type': {'name': 'lv_point_t', 'json_type': 'array', 'quals': [], 'dim': None}, 'json_type': 'arg'}, {'name': 'count', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'flags', 'type': {'name': 'lv_obj_point_transform_flag_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_point_t', 1, True), ('size_t', 0, False), ('lv_obj_point_transform_flag_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_point_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_point_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_point_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_point_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_point_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_point_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_lv_point_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_point_t_p_INT_INT)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_scale_section_t *', 'INT', 'INT')
// Handles 1 functions like 'lv_scale_set_section_range'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_scale_section_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_scale_section_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 3 arguments from JSON array for function '{'name': 'lv_scale_set_section_range', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'scale', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'section', 'type': {'type': {'name': 'lv_scale_section_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'min', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'max', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_scale_section_t', 1, False), ('int32_t', 0, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (3 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_scale_section_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 3) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 3 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_scale_section_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_scale_section_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_scale_section_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_scale_section_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_scale_section_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_obj_t_p_lv_scale_section_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_scale_section_t_p_INT_INT)", specific_type_str3, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_scale_section_t *', 'lv_style_t *')
// Handles 3 functions like 'lv_scale_set_section_style_main'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_scale_section_t_p_lv_style_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_scale_section_t_p_lv_style_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_scale_set_section_style_main', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'scale', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'section', 'type': {'type': {'name': 'lv_scale_section_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_scale_section_t', 1, False), ('lv_style_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_scale_section_t_p_lv_style_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_scale_section_t_p_lv_style_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_scale_section_t_p_lv_style_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_scale_section_t_p_lv_style_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_scale_section_t_p_lv_style_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_scale_section_t_p_lv_style_t_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_span_t *')
// Handles 1 functions like 'lv_spangroup_delete_span'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_span_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_span_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_spangroup_delete_span', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'span', 'type': {'type': {'name': 'lv_span_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_span_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_span_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_span_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_span_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_span_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_span_t *', 'const char *')
// Handles 2 functions like 'lv_spangroup_set_span_text'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_span_t_p_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_span_t_p_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_spangroup_set_span_text', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'span', 'type': {'type': {'name': 'lv_span_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'text', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_span_t', 1, False), ('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_span_t_p_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_span_t_p_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_span_t_p_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_span_t_p_const_char_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_span_t_p_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_span_t_p_const_char_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_span_t *', 'lv_style_t *')
// Handles 1 functions like 'lv_spangroup_set_span_style'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_span_t_p_lv_style_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_span_t_p_lv_style_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_spangroup_set_span_style', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'span', 'type': {'type': {'name': 'lv_span_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_span_t', 1, False), ('lv_style_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_span_t_p_lv_style_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_span_t_p_lv_style_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_span_t_p_lv_style_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_span_t_p_lv_style_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_span_t_p_lv_style_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_span_t_p_lv_style_t_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_style_t *', 'INT')
// Handles 2 functions like 'lv_obj_add_style'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_style_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_style_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_add_style', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'selector', 'type': {'name': 'lv_style_selector_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_style_t', 1, False), ('lv_style_selector_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_style_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_style_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_style_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_style_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_style_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_style_t_p_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_style_transition_dsc_t *', 'INT')
// Handles 1 functions like 'lv_obj_set_style_transition'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_style_transition_dsc_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_style_transition_dsc_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_obj_set_style_transition', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'type': {'name': 'lv_style_transition_dsc_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'selector', 'type': {'name': 'lv_style_selector_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_style_transition_dsc_t', 1, False), ('lv_style_selector_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_style_transition_dsc_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_style_transition_dsc_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_style_transition_dsc_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_style_transition_dsc_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_obj_t_p_lv_style_transition_dsc_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_style_transition_dsc_t_p_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_obj_t *', 'lv_subject_t *')
// Handles 1 functions like 'lv_obj_remove_from_subject'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_obj_t_p_lv_subject_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_obj_t_p_lv_subject_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_obj_remove_from_subject', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'obj', 'type': {'type': {'name': 'lv_obj_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'subject', 'type': {'type': {'name': 'lv_subject_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_obj_t', 1, False), ('lv_subject_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_obj_t_p_lv_subject_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_obj_t_p_lv_subject_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_obj_t_p_lv_subject_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_obj_t_p_lv_subject_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_observer_t *')
// Handles 1 functions like 'lv_observer_remove'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_observer_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_observer_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_observer_remove', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'observer', 'type': {'type': {'name': 'lv_observer_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_observer_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_observer_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_observer_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_point_precise_t *', 'INT', 'INT')
// Handles 1 functions like 'lv_point_precise_set'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_point_precise_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_point_precise_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_point_precise_set', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'p', 'type': {'type': {'name': 'lv_point_precise_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'x', 'type': {'name': 'lv_value_precise_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'y', 'type': {'name': 'lv_value_precise_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_point_precise_t', 1, False), ('lv_value_precise_t', 0, False), ('lv_value_precise_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_point_precise_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_point_precise_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_point_precise_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_point_precise_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_point_precise_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_point_precise_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_point_precise_t *', 'lv_point_precise_t *')
// Handles 1 functions like 'lv_point_precise_swap'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_point_precise_t_p_lv_point_precise_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_point_precise_t_p_lv_point_precise_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_point_precise_swap', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'p1', 'type': {'type': {'name': 'lv_point_precise_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'p2', 'type': {'type': {'name': 'lv_point_precise_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_point_precise_t', 1, False), ('lv_point_precise_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_point_precise_t_p_lv_point_precise_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_point_precise_t_p_lv_point_precise_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_point_precise_t_p_lv_point_precise_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_point_precise_t_p_lv_point_precise_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_point_t *', 'INT', 'INT')
// Handles 1 functions like 'lv_point_set'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_point_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_point_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_point_set', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'p', 'type': {'type': {'name': 'lv_point_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'x', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'y', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_point_t', 1, False), ('int32_t', 0, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_point_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_point_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_point_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_point_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_point_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_point_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_point_t *', 'INT', 'INT', 'INT', 'INT', 'lv_point_t *', 'BOOL')
// Handles 1 functions like 'lv_point_array_transform'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_point_t_p_INT_INT_INT_INT_lv_point_t_p_BOOL(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_point_t_p_INT_INT_INT_INT_lv_point_t_p_BOOL (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;
    int64_t arg_buf4;
    void* arg_buf5;
    int64_t arg_buf6;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 6 arguments from JSON array for function '{'name': 'lv_point_array_transform', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'points', 'type': {'type': {'name': 'lv_point_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'count', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'angle', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'scale_x', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'scale_y', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'pivot', 'type': {'type': {'name': 'lv_point_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'zoom_first', 'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_point_t', 1, False), ('size_t', 0, False), ('int32_t', 0, False), ('int32_t', 0, False), ('int32_t', 0, False), ('lv_point_t', 1, False), ('bool', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (6 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_point_t_p_INT_INT_INT_INT_lv_point_t_p_BOOL (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 6) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 6 JSON args for func '%s', got %d for invoke_void_lv_point_t_p_INT_INT_INT_INT_lv_point_t_p_BOOL", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_INT_lv_point_t_p_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_INT_lv_point_t_p_BOOL)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_INT_lv_point_t_p_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_INT_lv_point_t_p_BOOL)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_INT_lv_point_t_p_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_INT_lv_point_t_p_BOOL)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_INT_lv_point_t_p_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg3, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_INT_lv_point_t_p_BOOL)", specific_type_str4, entry->name);
        return false;
    }
    const char* specific_type_str5 = entry->arg_types[5];
    if (!specific_type_str5) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 5 of '%s'", entry->name); return false; }
    cJSON *json_arg4 = cJSON_GetArrayItem(args_array, 4);
    if (!json_arg4) { LOG_ERR("Invoke Error: Failed to get JSON arg 4 for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_INT_lv_point_t_p_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 4 into C arg buffer 5 (using specific type 'specific_type_str5')
    if (!(unmarshal_value(json_arg4, specific_type_str5, (void*)&arg_buf5))) {
        LOG_ERR_JSON(json_arg4, "Invoke Error: Failed to unmarshal JSON arg 4 as type '%s' for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_INT_lv_point_t_p_BOOL)", specific_type_str5, entry->name);
        return false;
    }
    const char* specific_type_str6 = entry->arg_types[6];
    if (!specific_type_str6) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 6 of '%s'", entry->name); return false; }
    cJSON *json_arg5 = cJSON_GetArrayItem(args_array, 5);
    if (!json_arg5) { LOG_ERR("Invoke Error: Failed to get JSON arg 5 for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_INT_lv_point_t_p_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 5 into C arg buffer 6 (using specific type 'specific_type_str6')
    if (!(unmarshal_value(json_arg5, specific_type_str6, (void*)&arg_buf6))) {
        LOG_ERR_JSON(json_arg5, "Invoke Error: Failed to unmarshal JSON arg 5 as type '%s' for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_INT_lv_point_t_p_BOOL)", specific_type_str6, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t, int64_t, int64_t, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4, arg_buf5, arg_buf6);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_point_t *', 'INT', 'INT', 'INT', 'lv_point_t *', 'BOOL')
// Handles 1 functions like 'lv_point_transform'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_point_t_p_INT_INT_INT_lv_point_t_p_BOOL(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_point_t_p_INT_INT_INT_lv_point_t_p_BOOL (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;
    void* arg_buf4;
    int64_t arg_buf5;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 5 arguments from JSON array for function '{'name': 'lv_point_transform', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'point', 'type': {'type': {'name': 'lv_point_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'angle', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'scale_x', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'scale_y', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'pivot', 'type': {'type': {'name': 'lv_point_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'zoom_first', 'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_point_t', 1, False), ('int32_t', 0, False), ('int32_t', 0, False), ('int32_t', 0, False), ('lv_point_t', 1, False), ('bool', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (5 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_point_t_p_INT_INT_INT_lv_point_t_p_BOOL (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 5) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 5 JSON args for func '%s', got %d for invoke_void_lv_point_t_p_INT_INT_INT_lv_point_t_p_BOOL", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_lv_point_t_p_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_lv_point_t_p_BOOL)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_lv_point_t_p_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_lv_point_t_p_BOOL)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_lv_point_t_p_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_lv_point_t_p_BOOL)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_lv_point_t_p_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg3, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_lv_point_t_p_BOOL)", specific_type_str4, entry->name);
        return false;
    }
    const char* specific_type_str5 = entry->arg_types[5];
    if (!specific_type_str5) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 5 of '%s'", entry->name); return false; }
    cJSON *json_arg4 = cJSON_GetArrayItem(args_array, 4);
    if (!json_arg4) { LOG_ERR("Invoke Error: Failed to get JSON arg 4 for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_lv_point_t_p_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 4 into C arg buffer 5 (using specific type 'specific_type_str5')
    if (!(unmarshal_value(json_arg4, specific_type_str5, (void*)&arg_buf5))) {
        LOG_ERR_JSON(json_arg4, "Invoke Error: Failed to unmarshal JSON arg 4 as type '%s' for func '%s' (invoke_void_lv_point_t_p_INT_INT_INT_lv_point_t_p_BOOL)", specific_type_str5, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t, int64_t, void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4, arg_buf5);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_point_t *', 'const char *', 'lv_font_t *', 'INT', 'INT', 'INT', 'INT')
// Handles 1 functions like 'lv_text_get_size'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_point_t_p_const_char_p_lv_font_t_p_INT_INT_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_point_t_p_const_char_p_lv_font_t_p_INT_INT_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;
    int64_t arg_buf3;
    int64_t arg_buf4;
    int64_t arg_buf5;
    int64_t arg_buf6;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 6 arguments from JSON array for function '{'name': 'lv_text_get_size', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'size_res', 'type': {'type': {'name': 'lv_point_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'text', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'font', 'type': {'type': {'name': 'lv_font_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'letter_space', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'line_space', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'max_width', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'flag', 'type': {'name': 'lv_text_flag_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_point_t', 1, False), ('char', 1, False), ('lv_font_t', 1, False), ('int32_t', 0, False), ('int32_t', 0, False), ('int32_t', 0, False), ('lv_text_flag_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (6 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_point_t_p_const_char_p_lv_font_t_p_INT_INT_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 6) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 6 JSON args for func '%s', got %d for invoke_void_lv_point_t_p_const_char_p_lv_font_t_p_INT_INT_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_point_t_p_const_char_p_lv_font_t_p_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_point_t_p_const_char_p_lv_font_t_p_INT_INT_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_point_t_p_const_char_p_lv_font_t_p_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_point_t_p_const_char_p_lv_font_t_p_INT_INT_INT_INT)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_point_t_p_const_char_p_lv_font_t_p_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_point_t_p_const_char_p_lv_font_t_p_INT_INT_INT_INT)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_void_lv_point_t_p_const_char_p_lv_font_t_p_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg3, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_void_lv_point_t_p_const_char_p_lv_font_t_p_INT_INT_INT_INT)", specific_type_str4, entry->name);
        return false;
    }
    const char* specific_type_str5 = entry->arg_types[5];
    if (!specific_type_str5) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 5 of '%s'", entry->name); return false; }
    cJSON *json_arg4 = cJSON_GetArrayItem(args_array, 4);
    if (!json_arg4) { LOG_ERR("Invoke Error: Failed to get JSON arg 4 for func '%s' (invoke_void_lv_point_t_p_const_char_p_lv_font_t_p_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 4 into C arg buffer 5 (using specific type 'specific_type_str5')
    if (!(unmarshal_value(json_arg4, specific_type_str5, (void*)&arg_buf5))) {
        LOG_ERR_JSON(json_arg4, "Invoke Error: Failed to unmarshal JSON arg 4 as type '%s' for func '%s' (invoke_void_lv_point_t_p_const_char_p_lv_font_t_p_INT_INT_INT_INT)", specific_type_str5, entry->name);
        return false;
    }
    const char* specific_type_str6 = entry->arg_types[6];
    if (!specific_type_str6) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 6 of '%s'", entry->name); return false; }
    cJSON *json_arg5 = cJSON_GetArrayItem(args_array, 5);
    if (!json_arg5) { LOG_ERR("Invoke Error: Failed to get JSON arg 5 for func '%s' (invoke_void_lv_point_t_p_const_char_p_lv_font_t_p_INT_INT_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 5 into C arg buffer 6 (using specific type 'specific_type_str6')
    if (!(unmarshal_value(json_arg5, specific_type_str6, (void*)&arg_buf6))) {
        LOG_ERR_JSON(json_arg5, "Invoke Error: Failed to unmarshal JSON arg 5 as type '%s' for func '%s' (invoke_void_lv_point_t_p_const_char_p_lv_font_t_p_INT_INT_INT_INT)", specific_type_str6, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, void*, int64_t, int64_t, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4, arg_buf5, arg_buf6);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_point_t *', 'lv_point_t *')
// Handles 1 functions like 'lv_point_swap'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_point_t_p_lv_point_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_point_t_p_lv_point_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_point_swap', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'p1', 'type': {'type': {'name': 'lv_point_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'p2', 'type': {'type': {'name': 'lv_point_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_point_t', 1, False), ('lv_point_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_point_t_p_lv_point_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_point_t_p_lv_point_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_point_t_p_lv_point_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_point_t_p_lv_point_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_rb_t *')
// Handles 1 functions like 'lv_rb_destroy'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_rb_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_rb_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_rb_destroy', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'tree', 'type': {'type': {'name': 'lv_rb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_rb_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_rb_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_rb_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_scale_section_t *', 'INT', 'INT')
// Handles 1 functions like 'lv_scale_section_set_range'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_scale_section_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_scale_section_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_scale_section_set_range', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'section', 'type': {'type': {'name': 'lv_scale_section_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'min', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'max', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_scale_section_t', 1, False), ('int32_t', 0, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_scale_section_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_scale_section_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_scale_section_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_scale_section_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_scale_section_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_scale_section_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_scale_section_t *', 'INT', 'lv_style_t *')
// Handles 1 functions like 'lv_scale_section_set_style'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_scale_section_t_p_INT_lv_style_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_scale_section_t_p_INT_lv_style_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    void* arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_scale_section_set_style', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'section', 'type': {'type': {'name': 'lv_scale_section_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'part', 'type': {'name': 'lv_part_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'section_part_style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_scale_section_t', 1, False), ('lv_part_t', 0, False), ('lv_style_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_scale_section_t_p_INT_lv_style_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_scale_section_t_p_INT_lv_style_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_scale_section_t_p_INT_lv_style_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_scale_section_t_p_INT_lv_style_t_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_scale_section_t_p_INT_lv_style_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_scale_section_t_p_INT_lv_style_t_p)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_span_t *', 'const char *')
// Handles 3 functions like 'lv_span_set_text'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_span_t_p_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_span_t_p_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_span_set_text', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'span', 'type': {'type': {'name': 'lv_span_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'text', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_span_t', 1, False), ('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_span_t_p_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_span_t_p_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_span_t_p_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_span_t_p_const_char_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_style_t *')
// Handles 3 functions like 'lv_style_init'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_style_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_style_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_style_init', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_style_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_style_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_style_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_style_t *', 'BOOL')
// Handles 5 functions like 'lv_style_set_bg_image_tiled'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_style_t_p_BOOL(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_style_t_p_BOOL (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_style_set_bg_image_tiled', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'name': 'bool', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_style_t', 1, False), ('bool', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_style_t_p_BOOL (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_style_t_p_BOOL", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_style_t_p_BOOL)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_style_t_p_BOOL)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_style_t *', 'INT')
// Handles 99 functions like 'lv_style_set_width'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_style_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_style_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_style_set_width', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_style_t', 1, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_style_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_style_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_style_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_style_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_style_t *', 'INT', 'INT')
// Handles 2 functions like 'lv_style_set_prop'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_style_t_p_INT_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_style_t_p_INT_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;
    int64_t arg_buf2;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 2 arguments from JSON array for function '{'name': 'lv_style_set_prop', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'prop', 'type': {'name': 'lv_style_prop_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'name': 'lv_style_value_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_style_t', 1, False), ('lv_style_prop_t', 0, False), ('lv_style_value_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (2 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_style_t_p_INT_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 2) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 2 JSON args for func '%s', got %d for invoke_void_lv_style_t_p_INT_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_style_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_style_t_p_INT_INT)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_style_t_p_INT_INT)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_style_t_p_INT_INT)", specific_type_str2, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_style_t *', 'POINTER')
// Handles 5 functions like 'lv_style_set_bg_image_src'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_style_t_p_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_style_t_p_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_style_set_bg_image_src', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_style_t', 1, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_style_t_p_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_style_t_p_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_style_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_style_t_p_POINTER)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_style_t *', 'lv_anim_t *')
// Handles 1 functions like 'lv_style_set_anim'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_style_t_p_lv_anim_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_style_t_p_lv_anim_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_style_set_anim', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'type': {'name': 'lv_anim_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_style_t', 1, False), ('lv_anim_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_style_t_p_lv_anim_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_style_t_p_lv_anim_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_style_t_p_lv_anim_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_style_t_p_lv_anim_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_style_t *', 'lv_color_filter_dsc_t *')
// Handles 1 functions like 'lv_style_set_color_filter_dsc'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_style_t_p_lv_color_filter_dsc_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_style_t_p_lv_color_filter_dsc_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_style_set_color_filter_dsc', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'type': {'name': 'lv_color_filter_dsc_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_style_t', 1, False), ('lv_color_filter_dsc_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_style_t_p_lv_color_filter_dsc_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_style_t_p_lv_color_filter_dsc_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_style_t_p_lv_color_filter_dsc_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_style_t_p_lv_color_filter_dsc_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_style_t *', 'lv_color_t')
// Handles 12 functions like 'lv_style_set_bg_color'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_style_t_p_lv_color_t(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_style_t_p_lv_color_t (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_style_set_bg_color', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_style_t', 1, False), ('lv_color_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_style_t_p_lv_color_t (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_style_t_p_lv_color_t", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_style_t_p_lv_color_t)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_style_t_p_lv_color_t)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_style_t *', 'lv_font_t *')
// Handles 1 functions like 'lv_style_set_text_font'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_style_t_p_lv_font_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_style_t_p_lv_font_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_style_set_text_font', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'type': {'name': 'lv_font_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_style_t', 1, False), ('lv_font_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_style_t_p_lv_font_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_style_t_p_lv_font_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_style_t_p_lv_font_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_style_t_p_lv_font_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_style_t *', 'lv_grad_dsc_t *')
// Handles 1 functions like 'lv_style_set_bg_grad'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_style_t_p_lv_grad_dsc_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_style_t_p_lv_grad_dsc_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_style_set_bg_grad', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'type': {'name': 'lv_grad_dsc_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_style_t', 1, False), ('lv_grad_dsc_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_style_t_p_lv_grad_dsc_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_style_t_p_lv_grad_dsc_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_style_t_p_lv_grad_dsc_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_style_t_p_lv_grad_dsc_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_style_t *', 'lv_style_t *')
// Handles 1 functions like 'lv_style_copy'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_style_t_p_lv_style_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_style_t_p_lv_style_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_style_copy', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'dst', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'src', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_style_t', 1, False), ('lv_style_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_style_t_p_lv_style_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_style_t_p_lv_style_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_style_t_p_lv_style_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_style_t_p_lv_style_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_style_t *', 'lv_style_transition_dsc_t *')
// Handles 1 functions like 'lv_style_set_transition'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_style_t_p_lv_style_transition_dsc_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_style_t_p_lv_style_transition_dsc_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_style_set_transition', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'style', 'type': {'type': {'name': 'lv_style_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'type': {'name': 'lv_style_transition_dsc_t', 'json_type': 'lvgl_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_style_t', 1, False), ('lv_style_transition_dsc_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_style_t_p_lv_style_transition_dsc_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_style_t_p_lv_style_transition_dsc_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_style_t_p_lv_style_transition_dsc_t_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_style_t_p_lv_style_transition_dsc_t_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_style_transition_dsc_t *', 'lv_style_prop_t *', 'INT', 'INT', 'INT', 'POINTER')
// Handles 1 functions like 'lv_style_transition_dsc_init'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_style_transition_dsc_t_p_lv_style_prop_t_p_INT_INT_INT_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_style_transition_dsc_t_p_lv_style_prop_t_p_INT_INT_INT_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    int64_t arg_buf2;
    int64_t arg_buf3;
    int64_t arg_buf4;
    void* arg_buf5;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 5 arguments from JSON array for function '{'name': 'lv_style_transition_dsc_init', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'tr', 'type': {'type': {'name': 'lv_style_transition_dsc_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'props', 'type': {'name': 'lv_style_prop_t', 'json_type': 'array', 'quals': ['const'], 'dim': None}, 'json_type': 'arg'}, {'name': 'path_cb', 'type': {'name': 'lv_anim_path_cb_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'time', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'delay', 'type': {'name': 'uint32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'user_data', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_style_transition_dsc_t', 1, False), ('lv_style_prop_t', 1, True), ('lv_anim_path_cb_t', 0, False), ('uint32_t', 0, False), ('uint32_t', 0, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (5 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_style_transition_dsc_t_p_lv_style_prop_t_p_INT_INT_INT_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 5) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 5 JSON args for func '%s', got %d for invoke_void_lv_style_transition_dsc_t_p_lv_style_prop_t_p_INT_INT_INT_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_style_transition_dsc_t_p_lv_style_prop_t_p_INT_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_style_transition_dsc_t_p_lv_style_prop_t_p_INT_INT_INT_POINTER)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_style_transition_dsc_t_p_lv_style_prop_t_p_INT_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_style_transition_dsc_t_p_lv_style_prop_t_p_INT_INT_INT_POINTER)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_style_transition_dsc_t_p_lv_style_prop_t_p_INT_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_style_transition_dsc_t_p_lv_style_prop_t_p_INT_INT_INT_POINTER)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_void_lv_style_transition_dsc_t_p_lv_style_prop_t_p_INT_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg3, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_void_lv_style_transition_dsc_t_p_lv_style_prop_t_p_INT_INT_INT_POINTER)", specific_type_str4, entry->name);
        return false;
    }
    const char* specific_type_str5 = entry->arg_types[5];
    if (!specific_type_str5) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 5 of '%s'", entry->name); return false; }
    cJSON *json_arg4 = cJSON_GetArrayItem(args_array, 4);
    if (!json_arg4) { LOG_ERR("Invoke Error: Failed to get JSON arg 4 for func '%s' (invoke_void_lv_style_transition_dsc_t_p_lv_style_prop_t_p_INT_INT_INT_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 4 into C arg buffer 5 (using specific type 'specific_type_str5')
    if (!(unmarshal_value(json_arg4, specific_type_str5, (void*)&arg_buf5))) {
        LOG_ERR_JSON(json_arg4, "Invoke Error: Failed to unmarshal JSON arg 4 as type '%s' for func '%s' (invoke_void_lv_style_transition_dsc_t_p_lv_style_prop_t_p_INT_INT_INT_POINTER)", specific_type_str5, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, int64_t, int64_t, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4, arg_buf5);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_subject_t *')
// Handles 2 functions like 'lv_subject_deinit'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_subject_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_subject_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_subject_deinit', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'subject', 'type': {'type': {'name': 'lv_subject_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_subject_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_subject_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_subject_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_subject_t *', 'INT')
// Handles 2 functions like 'lv_subject_init_int'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_subject_t_p_INT(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_subject_t_p_INT (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_subject_init_int', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'subject', 'type': {'type': {'name': 'lv_subject_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'name': 'int32_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_subject_t', 1, False), ('int32_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_subject_t_p_INT (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_subject_t_p_INT", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_subject_t_p_INT)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_subject_t_p_INT)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_subject_t *', 'POINTER')
// Handles 2 functions like 'lv_subject_init_pointer'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_subject_t_p_POINTER(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_subject_t_p_POINTER (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_subject_init_pointer', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'subject', 'type': {'type': {'name': 'lv_subject_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_subject_t', 1, False), ('void', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_subject_t_p_POINTER (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_subject_t_p_POINTER", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_subject_t_p_POINTER)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_subject_t_p_POINTER)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_subject_t *', 'const char *')
// Handles 1 functions like 'lv_subject_copy_string'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_subject_t_p_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_subject_t_p_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_subject_copy_string', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'subject', 'type': {'type': {'name': 'lv_subject_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'buf', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_subject_t', 1, False), ('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_subject_t_p_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_subject_t_p_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_subject_t_p_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_subject_t_p_const_char_p)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_subject_t *', 'const char *', 'const char *', 'INT', 'const char *')
// Handles 1 functions like 'lv_subject_init_string'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_subject_t_p_const_char_p_const_char_p_INT_const_char_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_subject_t_p_const_char_p_const_char_p_INT_const_char_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    void* arg_buf1;
    void* arg_buf2;
    int64_t arg_buf3;
    void* arg_buf4;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 4 arguments from JSON array for function '{'name': 'lv_subject_init_string', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'subject', 'type': {'type': {'name': 'lv_subject_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'buf', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'prev_buf', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'size', 'type': {'name': 'size_t', 'json_type': 'stdlib_type', 'quals': []}, 'json_type': 'arg'}, {'name': 'value', 'type': {'type': {'name': 'char', 'json_type': 'primitive_type', 'quals': ['const']}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_subject_t', 1, False), ('char', 1, False), ('char', 1, False), ('size_t', 0, False), ('char', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (4 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_subject_t_p_const_char_p_const_char_p_INT_const_char_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 4) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 4 JSON args for func '%s', got %d for invoke_void_lv_subject_t_p_const_char_p_const_char_p_INT_const_char_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_subject_t_p_const_char_p_const_char_p_INT_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_subject_t_p_const_char_p_const_char_p_INT_const_char_p)", specific_type_str1, entry->name);
        return false;
    }
    const char* specific_type_str2 = entry->arg_types[2];
    if (!specific_type_str2) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 2 of '%s'", entry->name); return false; }
    cJSON *json_arg1 = cJSON_GetArrayItem(args_array, 1);
    if (!json_arg1) { LOG_ERR("Invoke Error: Failed to get JSON arg 1 for func '%s' (invoke_void_lv_subject_t_p_const_char_p_const_char_p_INT_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 1 into C arg buffer 2 (using specific type 'specific_type_str2')
    if (!(unmarshal_value(json_arg1, specific_type_str2, (void*)&arg_buf2))) {
        LOG_ERR_JSON(json_arg1, "Invoke Error: Failed to unmarshal JSON arg 1 as type '%s' for func '%s' (invoke_void_lv_subject_t_p_const_char_p_const_char_p_INT_const_char_p)", specific_type_str2, entry->name);
        return false;
    }
    const char* specific_type_str3 = entry->arg_types[3];
    if (!specific_type_str3) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 3 of '%s'", entry->name); return false; }
    cJSON *json_arg2 = cJSON_GetArrayItem(args_array, 2);
    if (!json_arg2) { LOG_ERR("Invoke Error: Failed to get JSON arg 2 for func '%s' (invoke_void_lv_subject_t_p_const_char_p_const_char_p_INT_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 2 into C arg buffer 3 (using specific type 'specific_type_str3')
    if (!(unmarshal_value(json_arg2, specific_type_str3, (void*)&arg_buf3))) {
        LOG_ERR_JSON(json_arg2, "Invoke Error: Failed to unmarshal JSON arg 2 as type '%s' for func '%s' (invoke_void_lv_subject_t_p_const_char_p_const_char_p_INT_const_char_p)", specific_type_str3, entry->name);
        return false;
    }
    const char* specific_type_str4 = entry->arg_types[4];
    if (!specific_type_str4) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 4 of '%s'", entry->name); return false; }
    cJSON *json_arg3 = cJSON_GetArrayItem(args_array, 3);
    if (!json_arg3) { LOG_ERR("Invoke Error: Failed to get JSON arg 3 for func '%s' (invoke_void_lv_subject_t_p_const_char_p_const_char_p_INT_const_char_p)", entry->name); return false; }
    // Unmarshal JSON arg 3 into C arg buffer 4 (using specific type 'specific_type_str4')
    if (!(unmarshal_value(json_arg3, specific_type_str4, (void*)&arg_buf4))) {
        LOG_ERR_JSON(json_arg3, "Invoke Error: Failed to unmarshal JSON arg 3 as type '%s' for func '%s' (invoke_void_lv_subject_t_p_const_char_p_const_char_p_INT_const_char_p)", specific_type_str4, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, void*, void*, int64_t, void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1, arg_buf2, arg_buf3, arg_buf4);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_subject_t *', 'lv_color_t')
// Handles 2 functions like 'lv_subject_init_color'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_subject_t_p_lv_color_t(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_subject_t_p_lv_color_t (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;
    int64_t arg_buf1;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 1 arguments from JSON array for function '{'name': 'lv_subject_init_color', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'subject', 'type': {'type': {'name': 'lv_subject_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}, {'name': 'color', 'type': {'name': 'lv_color_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_subject_t', 1, False), ('lv_color_t', 0, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (1 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_subject_t_p_lv_color_t (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 1) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 1 JSON args for func '%s', got %d for invoke_void_lv_subject_t_p_lv_color_t", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry
    const char* specific_type_str1 = entry->arg_types[1];
    if (!specific_type_str1) { LOG_ERR("Invoke Error: Internal setup error - missing type for arg 1 of '%s'", entry->name); return false; }
    cJSON *json_arg0 = cJSON_GetArrayItem(args_array, 0);
    if (!json_arg0) { LOG_ERR("Invoke Error: Failed to get JSON arg 0 for func '%s' (invoke_void_lv_subject_t_p_lv_color_t)", entry->name); return false; }
    // Unmarshal JSON arg 0 into C arg buffer 1 (using specific type 'specific_type_str1')
    if (!(unmarshal_value(json_arg0, specific_type_str1, (void*)&arg_buf1))) {
        LOG_ERR_JSON(json_arg0, "Invoke Error: Failed to unmarshal JSON arg 0 as type '%s' for func '%s' (invoke_void_lv_subject_t_p_lv_color_t)", specific_type_str1, entry->name);
        return false;
    }

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*, int64_t);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0, arg_buf1);


    return true;
}

// Generic Invoker for signature category: ('void', 'lv_tree_node_t *')
// Handles 1 functions like 'lv_tree_node_delete'
// WARNING: Uses simplified signature for casting func_ptr, relies on compatible calling conventions.
static bool invoke_void_lv_tree_node_t_p(const invoke_table_entry_t *entry, void *target_obj_ptr, void *dest, cJSON *args_array) {
    if (!entry || !entry->func_ptr || !entry->ret_type) { LOG_ERR("Invoke Error: Invalid entry passed to invoke_void_lv_tree_node_t_p (for func '%s')", entry ? entry->name : "NULL_ENTRY"); return false; }
    // Declare stack buffers for arguments (sized based on signature category)
    void* arg_buf0;

    if (!entry->arg_types[0]) { LOG_ERR("Invoke Error: Missing type string for target arg 0 of '%s'", entry->name); return false; }
    arg_buf0 = (void*)target_obj_ptr;
    // Expecting 0 arguments from JSON array for function '{'name': 'lv_tree_node_delete', 'type': {'type': {'name': 'void', 'json_type': 'primitive_type', 'quals': []}, 'json_type': 'ret_type'}, 'json_type': 'function', 'args': [{'name': 'node', 'type': {'type': {'name': 'lv_tree_node_t', 'json_type': 'lvgl_type', 'quals': []}, 'json_type': 'pointer', 'quals': []}, 'json_type': 'arg'}], '_resolved_ret_type': ('void', 0, False), '_resolved_arg_types': [('lv_tree_node_t', 1, False)]}'
    if (!cJSON_IsArray(args_array)) {
       if (0 == 0 && args_array == NULL) { /* Okay */ }
       else { LOG_ERR_JSON(args_array, "Invoke Error: args_array is not a valid array for invoke_void_lv_tree_node_t_p (func '%s')", entry->name); return false; }
    }
    int arg_count = (args_array == NULL) ? 0 : cJSON_GetArraySize(args_array);
    if (arg_count != 0) { LOG_ERR_JSON(args_array, "Invoke Error: Expected 0 JSON args for func '%s', got %d for invoke_void_lv_tree_node_t_p", entry->name, arg_count); return false; }

    // Unmarshal arguments from JSON into stack buffers using specific types from entry

    // Cast function pointer based on simplified signature category
    typedef void (*invoker_func_type)(void*);
    invoker_func_type target_func = (invoker_func_type)entry->func_ptr;

    // Call the target LVGL function using values from stack buffers
    target_func(arg_buf0);


    return true;
}



// --- Invocation Table ---
// The global invocation table
static const invoke_table_entry_t g_invoke_table[] = {
    {
        .name = "lv_arc_align_obj_to_angle",
        .invoke = &invoke_void_lv_obj_t_p_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_arc_align_obj_to_angle,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_bind_value",
        .invoke = &invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p,
        .func_ptr = (void*)&lv_arc_bind_value,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_obj_t *", "lv_subject_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_arc_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_get_angle_end",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_arc_get_angle_end,
        .ret_type = "lv_value_precise_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_get_angle_start",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_arc_get_angle_start,
        .ret_type = "lv_value_precise_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_get_bg_angle_end",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_arc_get_bg_angle_end,
        .ret_type = "lv_value_precise_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_get_bg_angle_start",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_arc_get_bg_angle_start,
        .ret_type = "lv_value_precise_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_get_knob_offset",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_arc_get_knob_offset,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_get_max_value",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_arc_get_max_value,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_get_min_value",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_arc_get_min_value,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_get_mode",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_arc_get_mode,
        .ret_type = "lv_arc_mode_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_get_rotation",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_arc_get_rotation,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_get_value",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_arc_get_value,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_rotate_obj_to_angle",
        .invoke = &invoke_void_lv_obj_t_p_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_arc_rotate_obj_to_angle,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_set_angles",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_arc_set_angles,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_value_precise_t", "lv_value_precise_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_set_bg_angles",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_arc_set_bg_angles,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_value_precise_t", "lv_value_precise_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_set_bg_end_angle",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_arc_set_bg_end_angle,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_value_precise_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_set_bg_start_angle",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_arc_set_bg_start_angle,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_value_precise_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_set_change_rate",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_arc_set_change_rate,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_set_end_angle",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_arc_set_end_angle,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_value_precise_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_set_knob_offset",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_arc_set_knob_offset,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_set_mode",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_arc_set_mode,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_arc_mode_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_set_range",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_arc_set_range,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_set_rotation",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_arc_set_rotation,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_set_start_angle",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_arc_set_start_angle,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_value_precise_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_arc_set_value",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_arc_set_value,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_area_align",
        .invoke = &invoke_void_lv_area_t_p_lv_area_t_p_INT_INT_INT,
        .func_ptr = (void*)&lv_area_align,
        .ret_type = "void",
        .arg_types = { "lv_area_t *", "lv_area_t *", "lv_align_t", "int32_t", "int32_t", NULL, NULL, NULL }
    },
    {
        .name = "lv_area_copy",
        .invoke = &invoke_void_lv_area_t_p_lv_area_t_p,
        .func_ptr = (void*)&lv_area_copy,
        .ret_type = "void",
        .arg_types = { "lv_area_t *", "lv_area_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_area_get_height",
        .invoke = &invoke_INT_lv_area_t_p,
        .func_ptr = (void*)&lv_area_get_height,
        .ret_type = "int32_t",
        .arg_types = { "lv_area_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_area_get_size",
        .invoke = &invoke_INT_lv_area_t_p,
        .func_ptr = (void*)&lv_area_get_size,
        .ret_type = "uint32_t",
        .arg_types = { "lv_area_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_area_get_width",
        .invoke = &invoke_INT_lv_area_t_p,
        .func_ptr = (void*)&lv_area_get_width,
        .ret_type = "int32_t",
        .arg_types = { "lv_area_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_area_increase",
        .invoke = &invoke_void_lv_area_t_p_INT_INT,
        .func_ptr = (void*)&lv_area_increase,
        .ret_type = "void",
        .arg_types = { "lv_area_t *", "int32_t", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_area_move",
        .invoke = &invoke_void_lv_area_t_p_INT_INT,
        .func_ptr = (void*)&lv_area_move,
        .ret_type = "void",
        .arg_types = { "lv_area_t *", "int32_t", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_area_set",
        .invoke = &invoke_void_lv_area_t_p_INT_INT_INT_INT,
        .func_ptr = (void*)&lv_area_set,
        .ret_type = "void",
        .arg_types = { "lv_area_t *", "int32_t", "int32_t", "int32_t", "int32_t", NULL, NULL, NULL }
    },
    {
        .name = "lv_area_set_height",
        .invoke = &invoke_void_lv_area_t_p_INT,
        .func_ptr = (void*)&lv_area_set_height,
        .ret_type = "void",
        .arg_types = { "lv_area_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_area_set_width",
        .invoke = &invoke_void_lv_area_t_p_INT,
        .func_ptr = (void*)&lv_area_set_width,
        .ret_type = "void",
        .arg_types = { "lv_area_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_array_assign",
        .invoke = &invoke_INT_lv_array_t_p_INT_POINTER,
        .func_ptr = (void*)&lv_array_assign,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_array_t *", "uint32_t", "void *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_array_at",
        .invoke = &invoke_POINTER_lv_array_t_p_INT,
        .func_ptr = (void*)&lv_array_at,
        .ret_type = "void *",
        .arg_types = { "lv_array_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_array_back",
        .invoke = &invoke_POINTER_lv_array_t_p,
        .func_ptr = (void*)&lv_array_back,
        .ret_type = "void *",
        .arg_types = { "lv_array_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_array_capacity",
        .invoke = &invoke_INT_lv_array_t_p,
        .func_ptr = (void*)&lv_array_capacity,
        .ret_type = "uint32_t",
        .arg_types = { "lv_array_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_array_clear",
        .invoke = &invoke_void_lv_array_t_p,
        .func_ptr = (void*)&lv_array_clear,
        .ret_type = "void",
        .arg_types = { "lv_array_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_array_concat",
        .invoke = &invoke_INT_lv_array_t_p_lv_array_t_p,
        .func_ptr = (void*)&lv_array_concat,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_array_t *", "lv_array_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_array_copy",
        .invoke = &invoke_void_lv_array_t_p_lv_array_t_p,
        .func_ptr = (void*)&lv_array_copy,
        .ret_type = "void",
        .arg_types = { "lv_array_t *", "lv_array_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_array_deinit",
        .invoke = &invoke_void_lv_array_t_p,
        .func_ptr = (void*)&lv_array_deinit,
        .ret_type = "void",
        .arg_types = { "lv_array_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_array_erase",
        .invoke = &invoke_INT_lv_array_t_p_INT_INT,
        .func_ptr = (void*)&lv_array_erase,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_array_t *", "uint32_t", "uint32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_array_front",
        .invoke = &invoke_POINTER_lv_array_t_p,
        .func_ptr = (void*)&lv_array_front,
        .ret_type = "void *",
        .arg_types = { "lv_array_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_array_init",
        .invoke = &invoke_void_lv_array_t_p_INT_INT,
        .func_ptr = (void*)&lv_array_init,
        .ret_type = "void",
        .arg_types = { "lv_array_t *", "uint32_t", "uint32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_array_init_from_buf",
        .invoke = &invoke_void_lv_array_t_p_POINTER_INT_INT,
        .func_ptr = (void*)&lv_array_init_from_buf,
        .ret_type = "void",
        .arg_types = { "lv_array_t *", "void *", "uint32_t", "uint32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_array_is_empty",
        .invoke = &invoke_BOOL_lv_array_t_p,
        .func_ptr = (void*)&lv_array_is_empty,
        .ret_type = "bool",
        .arg_types = { "lv_array_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_array_is_full",
        .invoke = &invoke_BOOL_lv_array_t_p,
        .func_ptr = (void*)&lv_array_is_full,
        .ret_type = "bool",
        .arg_types = { "lv_array_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_array_push_back",
        .invoke = &invoke_INT_lv_array_t_p_POINTER,
        .func_ptr = (void*)&lv_array_push_back,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_array_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_array_remove",
        .invoke = &invoke_INT_lv_array_t_p_INT,
        .func_ptr = (void*)&lv_array_remove,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_array_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_array_resize",
        .invoke = &invoke_BOOL_lv_array_t_p_INT,
        .func_ptr = (void*)&lv_array_resize,
        .ret_type = "bool",
        .arg_types = { "lv_array_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_array_shrink",
        .invoke = &invoke_void_lv_array_t_p,
        .func_ptr = (void*)&lv_array_shrink,
        .ret_type = "void",
        .arg_types = { "lv_array_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_array_size",
        .invoke = &invoke_INT_lv_array_t_p,
        .func_ptr = (void*)&lv_array_size,
        .ret_type = "uint32_t",
        .arg_types = { "lv_array_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_async_call",
        .invoke = &invoke_INT_INT_POINTER,
        .func_ptr = (void*)&lv_async_call,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_async_cb_t", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_async_call_cancel",
        .invoke = &invoke_INT_INT_POINTER,
        .func_ptr = (void*)&lv_async_call_cancel,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_async_cb_t", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_atan2",
        .invoke = &invoke_INT_INT_INT,
        .func_ptr = (void*)&lv_atan2,
        .ret_type = "uint16_t",
        .arg_types = { "int", "int", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_bar_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_bar_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_bar_get_max_value",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_bar_get_max_value,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_bar_get_min_value",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_bar_get_min_value,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_bar_get_mode",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_bar_get_mode,
        .ret_type = "lv_bar_mode_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_bar_get_orientation",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_bar_get_orientation,
        .ret_type = "lv_bar_orientation_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_bar_get_start_value",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_bar_get_start_value,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_bar_get_value",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_bar_get_value,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_bar_is_symmetrical",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_bar_is_symmetrical,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_bar_set_mode",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_bar_set_mode,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_bar_mode_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_bar_set_orientation",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_bar_set_orientation,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_bar_orientation_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_bar_set_range",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_bar_set_range,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_bar_set_start_value",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_bar_set_start_value,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_anim_enable_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_bar_set_value",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_bar_set_value,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_anim_enable_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_bezier3",
        .invoke = &invoke_INT_INT_INT_INT_INT_INT,
        .func_ptr = (void*)&lv_bezier3,
        .ret_type = "int32_t",
        .arg_types = { "int32_t", "int32_t", "uint32_t", "int32_t", "int32_t", NULL, NULL, NULL }
    },
    {
        .name = "lv_bin_decoder_close",
        .invoke = &invoke_void_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p,
        .func_ptr = (void*)&lv_bin_decoder_close,
        .ret_type = "void",
        .arg_types = { "lv_image_decoder_t *", "lv_image_decoder_dsc_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_bin_decoder_get_area",
        .invoke = &invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p,
        .func_ptr = (void*)&lv_bin_decoder_get_area,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_image_decoder_t *", "lv_image_decoder_dsc_t *", "lv_area_t *", "lv_area_t *", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_bin_decoder_info",
        .invoke = &invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p_lv_image_header_t_p,
        .func_ptr = (void*)&lv_bin_decoder_info,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_image_decoder_t *", "lv_image_decoder_dsc_t *", "lv_image_header_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_bin_decoder_init",
        .invoke = &invoke_void,
        .func_ptr = (void*)&lv_bin_decoder_init,
        .ret_type = "void",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_bin_decoder_open",
        .invoke = &invoke_INT_lv_image_decoder_t_p_lv_image_decoder_dsc_t_p,
        .func_ptr = (void*)&lv_bin_decoder_open,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_image_decoder_t *", "lv_image_decoder_dsc_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_binfont_create",
        .invoke = &invoke_lv_font_t_p_const_char_p,
        .func_ptr = (void*)&lv_binfont_create,
        .ret_type = "lv_font_t *",
        .arg_types = { "char *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_binfont_destroy",
        .invoke = &invoke_void_lv_font_t_p,
        .func_ptr = (void*)&lv_binfont_destroy,
        .ret_type = "void",
        .arg_types = { "lv_font_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_button_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_button_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_buttonmatrix_clear_button_ctrl",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_buttonmatrix_clear_button_ctrl,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "lv_buttonmatrix_ctrl_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_buttonmatrix_clear_button_ctrl_all",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_buttonmatrix_clear_button_ctrl_all,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_buttonmatrix_ctrl_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_buttonmatrix_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_buttonmatrix_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_buttonmatrix_get_button_text",
        .invoke = &invoke_const_char_p_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_buttonmatrix_get_button_text,
        .ret_type = "char *",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_buttonmatrix_get_map",
        .invoke = &invoke_POINTER_lv_obj_t_p,
        .func_ptr = (void*)&lv_buttonmatrix_get_map,
        .ret_type = "char **",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_buttonmatrix_get_one_checked",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_buttonmatrix_get_one_checked,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_buttonmatrix_get_selected_button",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_buttonmatrix_get_selected_button,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_buttonmatrix_has_button_ctrl",
        .invoke = &invoke_BOOL_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_buttonmatrix_has_button_ctrl,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "uint32_t", "lv_buttonmatrix_ctrl_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_buttonmatrix_set_button_ctrl",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_buttonmatrix_set_button_ctrl,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "lv_buttonmatrix_ctrl_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_buttonmatrix_set_button_ctrl_all",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_buttonmatrix_set_button_ctrl_all,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_buttonmatrix_ctrl_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_buttonmatrix_set_button_width",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_buttonmatrix_set_button_width,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "uint32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_buttonmatrix_set_ctrl_map",
        .invoke = &invoke_void_lv_obj_t_p_lv_buttonmatrix_ctrl_t_p,
        .func_ptr = (void*)&lv_buttonmatrix_set_ctrl_map,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_buttonmatrix_ctrl_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_buttonmatrix_set_one_checked",
        .invoke = &invoke_void_lv_obj_t_p_BOOL,
        .func_ptr = (void*)&lv_buttonmatrix_set_one_checked,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_buttonmatrix_set_selected_button",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_buttonmatrix_set_selected_button,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_calloc",
        .invoke = &invoke_POINTER_INT_INT,
        .func_ptr = (void*)&lv_calloc,
        .ret_type = "void *",
        .arg_types = { "size_t", "size_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_canvas_buf_size",
        .invoke = &invoke_INT_INT_INT_INT_INT,
        .func_ptr = (void*)&lv_canvas_buf_size,
        .ret_type = "uint32_t",
        .arg_types = { "int32_t", "int32_t", "uint8_t", "uint8_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_canvas_copy_buf",
        .invoke = &invoke_void_lv_obj_t_p_lv_area_t_p_lv_draw_buf_t_p_lv_area_t_p,
        .func_ptr = (void*)&lv_canvas_copy_buf,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_area_t *", "lv_draw_buf_t *", "lv_area_t *", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_canvas_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_canvas_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_canvas_fill_bg",
        .invoke = &invoke_void_lv_obj_t_p_lv_color_t_INT,
        .func_ptr = (void*)&lv_canvas_fill_bg,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_color_t", "lv_opa_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_canvas_finish_layer",
        .invoke = &invoke_void_lv_obj_t_p_lv_layer_t_p,
        .func_ptr = (void*)&lv_canvas_finish_layer,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_layer_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_canvas_get_buf",
        .invoke = &invoke_POINTER_lv_obj_t_p,
        .func_ptr = (void*)&lv_canvas_get_buf,
        .ret_type = "void *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_canvas_get_draw_buf",
        .invoke = &invoke_lv_draw_buf_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_canvas_get_draw_buf,
        .ret_type = "lv_draw_buf_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_canvas_get_image",
        .invoke = &invoke_lv_image_dsc_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_canvas_get_image,
        .ret_type = "lv_image_dsc_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_canvas_get_px",
        .invoke = &invoke_INT_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_canvas_get_px,
        .ret_type = "lv_color32_t",
        .arg_types = { "lv_obj_t *", "int32_t", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_canvas_init_layer",
        .invoke = &invoke_void_lv_obj_t_p_lv_layer_t_p,
        .func_ptr = (void*)&lv_canvas_init_layer,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_layer_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_canvas_set_buffer",
        .invoke = &invoke_void_lv_obj_t_p_POINTER_INT_INT_INT,
        .func_ptr = (void*)&lv_canvas_set_buffer,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "void *", "int32_t", "int32_t", "lv_color_format_t", NULL, NULL, NULL }
    },
    {
        .name = "lv_canvas_set_draw_buf",
        .invoke = &invoke_void_lv_obj_t_p_lv_draw_buf_t_p,
        .func_ptr = (void*)&lv_canvas_set_draw_buf,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_draw_buf_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_canvas_set_palette",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_canvas_set_palette,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint8_t", "lv_color32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_canvas_set_px",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT_lv_color_t_INT,
        .func_ptr = (void*)&lv_canvas_set_px,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "int32_t", "lv_color_t", "lv_opa_t", NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_add_cursor",
        .invoke = &invoke_lv_chart_cursor_t_p_lv_obj_t_p_lv_color_t_INT,
        .func_ptr = (void*)&lv_chart_add_cursor,
        .ret_type = "lv_chart_cursor_t *",
        .arg_types = { "lv_obj_t *", "lv_color_t", "lv_dir_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_add_series",
        .invoke = &invoke_lv_chart_series_t_p_lv_obj_t_p_lv_color_t_INT,
        .func_ptr = (void*)&lv_chart_add_series,
        .ret_type = "lv_chart_series_t *",
        .arg_types = { "lv_obj_t *", "lv_color_t", "lv_chart_axis_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_chart_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_get_cursor_point",
        .invoke = &invoke_INT_lv_obj_t_p_lv_chart_cursor_t_p,
        .func_ptr = (void*)&lv_chart_get_cursor_point,
        .ret_type = "lv_point_t",
        .arg_types = { "lv_obj_t *", "lv_chart_cursor_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_get_first_point_center_offset",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_chart_get_first_point_center_offset,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_get_point_count",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_chart_get_point_count,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_get_point_pos_by_id",
        .invoke = &invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_lv_point_t_p,
        .func_ptr = (void*)&lv_chart_get_point_pos_by_id,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_chart_series_t *", "uint32_t", "lv_point_t *", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_get_pressed_point",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_chart_get_pressed_point,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_get_series_color",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_lv_chart_series_t_p,
        .func_ptr = (void*)&lv_chart_get_series_color,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_chart_series_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_get_series_next",
        .invoke = &invoke_lv_chart_series_t_p_lv_obj_t_p_lv_chart_series_t_p,
        .func_ptr = (void*)&lv_chart_get_series_next,
        .ret_type = "lv_chart_series_t *",
        .arg_types = { "lv_obj_t *", "lv_chart_series_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_get_series_x_array",
        .invoke = &invoke_POINTER_lv_obj_t_p_lv_chart_series_t_p,
        .func_ptr = (void*)&lv_chart_get_series_x_array,
        .ret_type = "int32_t *",
        .arg_types = { "lv_obj_t *", "lv_chart_series_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_get_series_y_array",
        .invoke = &invoke_POINTER_lv_obj_t_p_lv_chart_series_t_p,
        .func_ptr = (void*)&lv_chart_get_series_y_array,
        .ret_type = "int32_t *",
        .arg_types = { "lv_obj_t *", "lv_chart_series_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_get_type",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_chart_get_type,
        .ret_type = "lv_chart_type_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_get_x_start_point",
        .invoke = &invoke_INT_lv_obj_t_p_lv_chart_series_t_p,
        .func_ptr = (void*)&lv_chart_get_x_start_point,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", "lv_chart_series_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_hide_series",
        .invoke = &invoke_void_lv_obj_t_p_lv_chart_series_t_p_BOOL,
        .func_ptr = (void*)&lv_chart_hide_series,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_chart_series_t *", "bool", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_refresh",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_chart_refresh,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_remove_series",
        .invoke = &invoke_void_lv_obj_t_p_lv_chart_series_t_p,
        .func_ptr = (void*)&lv_chart_remove_series,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_chart_series_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_set_all_values",
        .invoke = &invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT,
        .func_ptr = (void*)&lv_chart_set_all_values,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_chart_series_t *", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_set_axis_range",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT_INT,
        .func_ptr = (void*)&lv_chart_set_axis_range,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_chart_axis_t", "int32_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_set_cursor_point",
        .invoke = &invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_chart_series_t_p_INT,
        .func_ptr = (void*)&lv_chart_set_cursor_point,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_chart_cursor_t *", "lv_chart_series_t *", "uint32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_set_cursor_pos",
        .invoke = &invoke_void_lv_obj_t_p_lv_chart_cursor_t_p_lv_point_t_p,
        .func_ptr = (void*)&lv_chart_set_cursor_pos,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_chart_cursor_t *", "lv_point_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_set_div_line_count",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_chart_set_div_line_count,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint8_t", "uint8_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_set_next_value",
        .invoke = &invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT,
        .func_ptr = (void*)&lv_chart_set_next_value,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_chart_series_t *", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_set_next_value2",
        .invoke = &invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT,
        .func_ptr = (void*)&lv_chart_set_next_value2,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_chart_series_t *", "int32_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_set_point_count",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_chart_set_point_count,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_set_series_color",
        .invoke = &invoke_void_lv_obj_t_p_lv_chart_series_t_p_lv_color_t,
        .func_ptr = (void*)&lv_chart_set_series_color,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_chart_series_t *", "lv_color_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_set_series_ext_x_array",
        .invoke = &invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER,
        .func_ptr = (void*)&lv_chart_set_series_ext_x_array,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_chart_series_t *", "int32_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_set_series_ext_y_array",
        .invoke = &invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER,
        .func_ptr = (void*)&lv_chart_set_series_ext_y_array,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_chart_series_t *", "int32_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_set_series_value_by_id",
        .invoke = &invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT,
        .func_ptr = (void*)&lv_chart_set_series_value_by_id,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_chart_series_t *", "uint32_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_set_series_value_by_id2",
        .invoke = &invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT_INT_INT,
        .func_ptr = (void*)&lv_chart_set_series_value_by_id2,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_chart_series_t *", "uint32_t", "int32_t", "int32_t", NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_set_series_values",
        .invoke = &invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_INT,
        .func_ptr = (void*)&lv_chart_set_series_values,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_chart_series_t *", "int32_t *", "size_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_set_series_values2",
        .invoke = &invoke_void_lv_obj_t_p_lv_chart_series_t_p_POINTER_POINTER_INT,
        .func_ptr = (void*)&lv_chart_set_series_values2,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_chart_series_t *", "int32_t *", "int32_t *", "size_t", NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_set_type",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_chart_set_type,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_chart_type_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_set_update_mode",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_chart_set_update_mode,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_chart_update_mode_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_chart_set_x_start_point",
        .invoke = &invoke_void_lv_obj_t_p_lv_chart_series_t_p_INT,
        .func_ptr = (void*)&lv_chart_set_x_start_point,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_chart_series_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_checkbox_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_checkbox_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_checkbox_get_text",
        .invoke = &invoke_const_char_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_checkbox_get_text,
        .ret_type = "char *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_checkbox_set_text",
        .invoke = &invoke_void_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_checkbox_set_text,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_checkbox_set_text_static",
        .invoke = &invoke_void_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_checkbox_set_text_static,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_circle_buf_capacity",
        .invoke = &invoke_INT_lv_circle_buf_t_p,
        .func_ptr = (void*)&lv_circle_buf_capacity,
        .ret_type = "uint32_t",
        .arg_types = { "lv_circle_buf_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_circle_buf_create",
        .invoke = &invoke_lv_circle_buf_t_p_INT_INT,
        .func_ptr = (void*)&lv_circle_buf_create,
        .ret_type = "lv_circle_buf_t *",
        .arg_types = { "uint32_t", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_circle_buf_create_from_array",
        .invoke = &invoke_lv_circle_buf_t_p_lv_array_t_p,
        .func_ptr = (void*)&lv_circle_buf_create_from_array,
        .ret_type = "lv_circle_buf_t *",
        .arg_types = { "lv_array_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_circle_buf_create_from_buf",
        .invoke = &invoke_lv_circle_buf_t_p_POINTER_INT_INT,
        .func_ptr = (void*)&lv_circle_buf_create_from_buf,
        .ret_type = "lv_circle_buf_t *",
        .arg_types = { "void *", "uint32_t", "uint32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_circle_buf_destroy",
        .invoke = &invoke_void_lv_circle_buf_t_p,
        .func_ptr = (void*)&lv_circle_buf_destroy,
        .ret_type = "void",
        .arg_types = { "lv_circle_buf_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_circle_buf_fill",
        .invoke = &invoke_INT_lv_circle_buf_t_p_INT_INT_POINTER,
        .func_ptr = (void*)&lv_circle_buf_fill,
        .ret_type = "uint32_t",
        .arg_types = { "lv_circle_buf_t *", "uint32_t", "lv_circle_buf_fill_cb_t", "void *", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_circle_buf_head",
        .invoke = &invoke_POINTER_lv_circle_buf_t_p,
        .func_ptr = (void*)&lv_circle_buf_head,
        .ret_type = "void *",
        .arg_types = { "lv_circle_buf_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_circle_buf_is_empty",
        .invoke = &invoke_BOOL_lv_circle_buf_t_p,
        .func_ptr = (void*)&lv_circle_buf_is_empty,
        .ret_type = "bool",
        .arg_types = { "lv_circle_buf_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_circle_buf_is_full",
        .invoke = &invoke_BOOL_lv_circle_buf_t_p,
        .func_ptr = (void*)&lv_circle_buf_is_full,
        .ret_type = "bool",
        .arg_types = { "lv_circle_buf_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_circle_buf_peek",
        .invoke = &invoke_INT_lv_circle_buf_t_p_POINTER,
        .func_ptr = (void*)&lv_circle_buf_peek,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_circle_buf_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_circle_buf_peek_at",
        .invoke = &invoke_INT_lv_circle_buf_t_p_INT_POINTER,
        .func_ptr = (void*)&lv_circle_buf_peek_at,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_circle_buf_t *", "uint32_t", "void *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_circle_buf_read",
        .invoke = &invoke_INT_lv_circle_buf_t_p_POINTER,
        .func_ptr = (void*)&lv_circle_buf_read,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_circle_buf_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_circle_buf_remain",
        .invoke = &invoke_INT_lv_circle_buf_t_p,
        .func_ptr = (void*)&lv_circle_buf_remain,
        .ret_type = "uint32_t",
        .arg_types = { "lv_circle_buf_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_circle_buf_reset",
        .invoke = &invoke_void_lv_circle_buf_t_p,
        .func_ptr = (void*)&lv_circle_buf_reset,
        .ret_type = "void",
        .arg_types = { "lv_circle_buf_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_circle_buf_resize",
        .invoke = &invoke_INT_lv_circle_buf_t_p_INT,
        .func_ptr = (void*)&lv_circle_buf_resize,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_circle_buf_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_circle_buf_size",
        .invoke = &invoke_INT_lv_circle_buf_t_p,
        .func_ptr = (void*)&lv_circle_buf_size,
        .ret_type = "uint32_t",
        .arg_types = { "lv_circle_buf_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_circle_buf_skip",
        .invoke = &invoke_INT_lv_circle_buf_t_p,
        .func_ptr = (void*)&lv_circle_buf_skip,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_circle_buf_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_circle_buf_tail",
        .invoke = &invoke_POINTER_lv_circle_buf_t_p,
        .func_ptr = (void*)&lv_circle_buf_tail,
        .ret_type = "void *",
        .arg_types = { "lv_circle_buf_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_circle_buf_write",
        .invoke = &invoke_INT_lv_circle_buf_t_p_POINTER,
        .func_ptr = (void*)&lv_circle_buf_write,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_circle_buf_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_clamp_height",
        .invoke = &invoke_INT_INT_INT_INT_INT,
        .func_ptr = (void*)&lv_clamp_height,
        .ret_type = "int32_t",
        .arg_types = { "int32_t", "int32_t", "int32_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_clamp_width",
        .invoke = &invoke_INT_INT_INT_INT_INT,
        .func_ptr = (void*)&lv_clamp_width,
        .ret_type = "int32_t",
        .arg_types = { "int32_t", "int32_t", "int32_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color16_luminance",
        .invoke = &invoke_INT_INT,
        .func_ptr = (void*)&lv_color16_luminance,
        .ret_type = "uint8_t",
        .arg_types = { "lv_color16_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color16_premultiply",
        .invoke = &invoke_void_lv_color16_t_p_INT,
        .func_ptr = (void*)&lv_color16_premultiply,
        .ret_type = "void",
        .arg_types = { "lv_color16_t *", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color24_luminance",
        .invoke = &invoke_INT_POINTER,
        .func_ptr = (void*)&lv_color24_luminance,
        .ret_type = "uint8_t",
        .arg_types = { "uint8_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color32_eq",
        .invoke = &invoke_BOOL_INT_INT,
        .func_ptr = (void*)&lv_color32_eq,
        .ret_type = "bool",
        .arg_types = { "lv_color32_t", "lv_color32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color32_luminance",
        .invoke = &invoke_INT_INT,
        .func_ptr = (void*)&lv_color32_luminance,
        .ret_type = "uint8_t",
        .arg_types = { "lv_color32_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color32_make",
        .invoke = &invoke_INT_INT_INT_INT_INT,
        .func_ptr = (void*)&lv_color32_make,
        .ret_type = "lv_color32_t",
        .arg_types = { "uint8_t", "uint8_t", "uint8_t", "uint8_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_16_16_mix",
        .invoke = &invoke_INT_INT_INT_INT,
        .func_ptr = (void*)&lv_color_16_16_mix,
        .ret_type = "uint16_t",
        .arg_types = { "uint16_t", "uint16_t", "uint8_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_black",
        .invoke = &invoke_lv_color_t,
        .func_ptr = (void*)&lv_color_black,
        .ret_type = "lv_color_t",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_darken",
        .invoke = &invoke_lv_color_t_lv_color_t_INT,
        .func_ptr = (void*)&lv_color_darken,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_color_t", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_eq",
        .invoke = &invoke_BOOL_lv_color_t_lv_color_t,
        .func_ptr = (void*)&lv_color_eq,
        .ret_type = "bool",
        .arg_types = { "lv_color_t", "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_filter_dsc_init",
        .invoke = &invoke_void_lv_color_filter_dsc_t_p_INT,
        .func_ptr = (void*)&lv_color_filter_dsc_init,
        .ret_type = "void",
        .arg_types = { "lv_color_filter_dsc_t *", "lv_color_filter_cb_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_format_get_bpp",
        .invoke = &invoke_INT_INT,
        .func_ptr = (void*)&lv_color_format_get_bpp,
        .ret_type = "uint8_t",
        .arg_types = { "lv_color_format_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_format_get_size",
        .invoke = &invoke_INT_INT,
        .func_ptr = (void*)&lv_color_format_get_size,
        .ret_type = "uint8_t",
        .arg_types = { "lv_color_format_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_format_has_alpha",
        .invoke = &invoke_BOOL_INT,
        .func_ptr = (void*)&lv_color_format_has_alpha,
        .ret_type = "bool",
        .arg_types = { "lv_color_format_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_hex",
        .invoke = &invoke_lv_color_t_INT,
        .func_ptr = (void*)&lv_color_hex,
        .ret_type = "lv_color_t",
        .arg_types = { "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_hex3",
        .invoke = &invoke_lv_color_t_INT,
        .func_ptr = (void*)&lv_color_hex3,
        .ret_type = "lv_color_t",
        .arg_types = { "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_hsv_to_rgb",
        .invoke = &invoke_lv_color_t_INT_INT_INT,
        .func_ptr = (void*)&lv_color_hsv_to_rgb,
        .ret_type = "lv_color_t",
        .arg_types = { "uint16_t", "uint8_t", "uint8_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_lighten",
        .invoke = &invoke_lv_color_t_lv_color_t_INT,
        .func_ptr = (void*)&lv_color_lighten,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_color_t", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_luminance",
        .invoke = &invoke_INT_lv_color_t,
        .func_ptr = (void*)&lv_color_luminance,
        .ret_type = "uint8_t",
        .arg_types = { "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_make",
        .invoke = &invoke_lv_color_t_INT_INT_INT,
        .func_ptr = (void*)&lv_color_make,
        .ret_type = "lv_color_t",
        .arg_types = { "uint8_t", "uint8_t", "uint8_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_mix",
        .invoke = &invoke_lv_color_t_lv_color_t_lv_color_t_INT,
        .func_ptr = (void*)&lv_color_mix,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_color_t", "lv_color_t", "uint8_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_mix32",
        .invoke = &invoke_INT_INT_INT,
        .func_ptr = (void*)&lv_color_mix32,
        .ret_type = "lv_color32_t",
        .arg_types = { "lv_color32_t", "lv_color32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_mix32_premultiplied",
        .invoke = &invoke_INT_INT_INT,
        .func_ptr = (void*)&lv_color_mix32_premultiplied,
        .ret_type = "lv_color32_t",
        .arg_types = { "lv_color32_t", "lv_color32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_over32",
        .invoke = &invoke_INT_INT_INT,
        .func_ptr = (void*)&lv_color_over32,
        .ret_type = "lv_color32_t",
        .arg_types = { "lv_color32_t", "lv_color32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_premultiply",
        .invoke = &invoke_void_lv_color32_t_p,
        .func_ptr = (void*)&lv_color_premultiply,
        .ret_type = "void",
        .arg_types = { "lv_color32_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_rgb_to_hsv",
        .invoke = &invoke_INT_INT_INT_INT,
        .func_ptr = (void*)&lv_color_rgb_to_hsv,
        .ret_type = "lv_color_hsv_t",
        .arg_types = { "uint8_t", "uint8_t", "uint8_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_to_32",
        .invoke = &invoke_INT_lv_color_t_INT,
        .func_ptr = (void*)&lv_color_to_32,
        .ret_type = "lv_color32_t",
        .arg_types = { "lv_color_t", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_to_hsv",
        .invoke = &invoke_INT_lv_color_t,
        .func_ptr = (void*)&lv_color_to_hsv,
        .ret_type = "lv_color_hsv_t",
        .arg_types = { "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_to_int",
        .invoke = &invoke_INT_lv_color_t,
        .func_ptr = (void*)&lv_color_to_int,
        .ret_type = "uint32_t",
        .arg_types = { "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_to_u16",
        .invoke = &invoke_INT_lv_color_t,
        .func_ptr = (void*)&lv_color_to_u16,
        .ret_type = "uint16_t",
        .arg_types = { "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_to_u32",
        .invoke = &invoke_INT_lv_color_t,
        .func_ptr = (void*)&lv_color_to_u32,
        .ret_type = "uint32_t",
        .arg_types = { "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_color_white",
        .invoke = &invoke_lv_color_t,
        .func_ptr = (void*)&lv_color_white,
        .ret_type = "lv_color_t",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_cubic_bezier",
        .invoke = &invoke_INT_INT_INT_INT_INT_INT,
        .func_ptr = (void*)&lv_cubic_bezier,
        .ret_type = "int32_t",
        .arg_types = { "int32_t", "int32_t", "int32_t", "int32_t", "int32_t", NULL, NULL, NULL }
    },
    {
        .name = "lv_deinit",
        .invoke = &invoke_void,
        .func_ptr = (void*)&lv_deinit,
        .ret_type = "void",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_delay_ms",
        .invoke = &invoke_void_INT,
        .func_ptr = (void*)&lv_delay_ms,
        .ret_type = "void",
        .arg_types = { "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_delay_set_cb",
        .invoke = &invoke_void_INT,
        .func_ptr = (void*)&lv_delay_set_cb,
        .ret_type = "void",
        .arg_types = { "lv_delay_cb_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dpx",
        .invoke = &invoke_INT_INT,
        .func_ptr = (void*)&lv_dpx,
        .ret_type = "int32_t",
        .arg_types = { "int32_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_add_option",
        .invoke = &invoke_void_lv_obj_t_p_const_char_p_INT,
        .func_ptr = (void*)&lv_dropdown_add_option,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "char *", "uint32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_bind_value",
        .invoke = &invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p,
        .func_ptr = (void*)&lv_dropdown_bind_value,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_obj_t *", "lv_subject_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_clear_options",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_dropdown_clear_options,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_close",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_dropdown_close,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_dropdown_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_get_dir",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_dropdown_get_dir,
        .ret_type = "lv_dir_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_get_list",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_dropdown_get_list,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_get_option_count",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_dropdown_get_option_count,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_get_option_index",
        .invoke = &invoke_INT_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_dropdown_get_option_index,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_get_options",
        .invoke = &invoke_const_char_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_dropdown_get_options,
        .ret_type = "char *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_get_selected",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_dropdown_get_selected,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_get_selected_highlight",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_dropdown_get_selected_highlight,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_get_selected_str",
        .invoke = &invoke_void_lv_obj_t_p_const_char_p_INT,
        .func_ptr = (void*)&lv_dropdown_get_selected_str,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "char *", "uint32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_get_symbol",
        .invoke = &invoke_const_char_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_dropdown_get_symbol,
        .ret_type = "char *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_get_text",
        .invoke = &invoke_const_char_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_dropdown_get_text,
        .ret_type = "char *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_is_open",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_dropdown_is_open,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_open",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_dropdown_open,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_set_dir",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_dropdown_set_dir,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_dir_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_set_options",
        .invoke = &invoke_void_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_dropdown_set_options,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_set_options_static",
        .invoke = &invoke_void_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_dropdown_set_options_static,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_set_selected",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_dropdown_set_selected,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "lv_anim_enable_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_set_selected_highlight",
        .invoke = &invoke_void_lv_obj_t_p_BOOL,
        .func_ptr = (void*)&lv_dropdown_set_selected_highlight,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_set_symbol",
        .invoke = &invoke_void_lv_obj_t_p_POINTER,
        .func_ptr = (void*)&lv_dropdown_set_symbol,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_dropdown_set_text",
        .invoke = &invoke_void_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_dropdown_set_text,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_flex_init",
        .invoke = &invoke_void,
        .func_ptr = (void*)&lv_flex_init,
        .ret_type = "void",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_font_get_bitmap_fmt_txt",
        .invoke = &invoke_POINTER_lv_font_glyph_dsc_t_p_lv_draw_buf_t_p,
        .func_ptr = (void*)&lv_font_get_bitmap_fmt_txt,
        .ret_type = "void *",
        .arg_types = { "lv_font_glyph_dsc_t *", "lv_draw_buf_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_font_get_default",
        .invoke = &invoke_lv_font_t_p,
        .func_ptr = (void*)&lv_font_get_default,
        .ret_type = "lv_font_t *",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_font_get_glyph_bitmap",
        .invoke = &invoke_POINTER_lv_font_glyph_dsc_t_p_lv_draw_buf_t_p,
        .func_ptr = (void*)&lv_font_get_glyph_bitmap,
        .ret_type = "void *",
        .arg_types = { "lv_font_glyph_dsc_t *", "lv_draw_buf_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_font_get_glyph_dsc",
        .invoke = &invoke_BOOL_lv_font_t_p_lv_font_glyph_dsc_t_p_INT_INT,
        .func_ptr = (void*)&lv_font_get_glyph_dsc,
        .ret_type = "bool",
        .arg_types = { "lv_font_t *", "lv_font_glyph_dsc_t *", "uint32_t", "uint32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_font_get_glyph_dsc_fmt_txt",
        .invoke = &invoke_BOOL_lv_font_t_p_lv_font_glyph_dsc_t_p_INT_INT,
        .func_ptr = (void*)&lv_font_get_glyph_dsc_fmt_txt,
        .ret_type = "bool",
        .arg_types = { "lv_font_t *", "lv_font_glyph_dsc_t *", "uint32_t", "uint32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_font_get_glyph_width",
        .invoke = &invoke_INT_lv_font_t_p_INT_INT,
        .func_ptr = (void*)&lv_font_get_glyph_width,
        .ret_type = "uint16_t",
        .arg_types = { "lv_font_t *", "uint32_t", "uint32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_font_get_line_height",
        .invoke = &invoke_INT_lv_font_t_p,
        .func_ptr = (void*)&lv_font_get_line_height,
        .ret_type = "int32_t",
        .arg_types = { "lv_font_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_font_glyph_release_draw_data",
        .invoke = &invoke_void_lv_font_glyph_dsc_t_p,
        .func_ptr = (void*)&lv_font_glyph_release_draw_data,
        .ret_type = "void",
        .arg_types = { "lv_font_glyph_dsc_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_font_info_is_equal",
        .invoke = &invoke_BOOL_lv_font_info_t_p_lv_font_info_t_p,
        .func_ptr = (void*)&lv_font_info_is_equal,
        .ret_type = "bool",
        .arg_types = { "lv_font_info_t *", "lv_font_info_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_font_set_kerning",
        .invoke = &invoke_void_lv_font_t_p_INT,
        .func_ptr = (void*)&lv_font_set_kerning,
        .ret_type = "void",
        .arg_types = { "lv_font_t *", "lv_font_kerning_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_free",
        .invoke = &invoke_void,
        .func_ptr = (void*)&lv_free,
        .ret_type = "void",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_free_core",
        .invoke = &invoke_void,
        .func_ptr = (void*)&lv_free_core,
        .ret_type = "void",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_fs_close",
        .invoke = &invoke_INT_lv_fs_file_t_p,
        .func_ptr = (void*)&lv_fs_close,
        .ret_type = "lv_fs_res_t",
        .arg_types = { "lv_fs_file_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_fs_dir_close",
        .invoke = &invoke_INT_lv_fs_dir_t_p,
        .func_ptr = (void*)&lv_fs_dir_close,
        .ret_type = "lv_fs_res_t",
        .arg_types = { "lv_fs_dir_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_fs_dir_open",
        .invoke = &invoke_INT_lv_fs_dir_t_p_const_char_p,
        .func_ptr = (void*)&lv_fs_dir_open,
        .ret_type = "lv_fs_res_t",
        .arg_types = { "lv_fs_dir_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_fs_dir_read",
        .invoke = &invoke_INT_lv_fs_dir_t_p_const_char_p_INT,
        .func_ptr = (void*)&lv_fs_dir_read,
        .ret_type = "lv_fs_res_t",
        .arg_types = { "lv_fs_dir_t *", "char *", "uint32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_fs_drv_init",
        .invoke = &invoke_void_lv_fs_drv_t_p,
        .func_ptr = (void*)&lv_fs_drv_init,
        .ret_type = "void",
        .arg_types = { "lv_fs_drv_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_fs_drv_register",
        .invoke = &invoke_void_lv_fs_drv_t_p,
        .func_ptr = (void*)&lv_fs_drv_register,
        .ret_type = "void",
        .arg_types = { "lv_fs_drv_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_fs_get_drv",
        .invoke = &invoke_lv_fs_drv_t_p_INT,
        .func_ptr = (void*)&lv_fs_get_drv,
        .ret_type = "lv_fs_drv_t *",
        .arg_types = { "char", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_fs_get_ext",
        .invoke = &invoke_const_char_p_const_char_p,
        .func_ptr = (void*)&lv_fs_get_ext,
        .ret_type = "char *",
        .arg_types = { "char *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_fs_get_last",
        .invoke = &invoke_const_char_p_const_char_p,
        .func_ptr = (void*)&lv_fs_get_last,
        .ret_type = "char *",
        .arg_types = { "char *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_fs_get_letters",
        .invoke = &invoke_const_char_p_const_char_p,
        .func_ptr = (void*)&lv_fs_get_letters,
        .ret_type = "char *",
        .arg_types = { "char *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_fs_is_ready",
        .invoke = &invoke_BOOL_INT,
        .func_ptr = (void*)&lv_fs_is_ready,
        .ret_type = "bool",
        .arg_types = { "char", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_fs_make_path_from_buffer",
        .invoke = &invoke_void_lv_fs_path_ex_t_p_INT_POINTER_INT,
        .func_ptr = (void*)&lv_fs_make_path_from_buffer,
        .ret_type = "void",
        .arg_types = { "lv_fs_path_ex_t *", "char", "void *", "uint32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_fs_open",
        .invoke = &invoke_INT_lv_fs_file_t_p_const_char_p_INT,
        .func_ptr = (void*)&lv_fs_open,
        .ret_type = "lv_fs_res_t",
        .arg_types = { "lv_fs_file_t *", "char *", "lv_fs_mode_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_fs_read",
        .invoke = &invoke_INT_lv_fs_file_t_p_POINTER_INT_POINTER,
        .func_ptr = (void*)&lv_fs_read,
        .ret_type = "lv_fs_res_t",
        .arg_types = { "lv_fs_file_t *", "void *", "uint32_t", "uint32_t *", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_fs_seek",
        .invoke = &invoke_INT_lv_fs_file_t_p_INT_INT,
        .func_ptr = (void*)&lv_fs_seek,
        .ret_type = "lv_fs_res_t",
        .arg_types = { "lv_fs_file_t *", "uint32_t", "lv_fs_whence_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_fs_tell",
        .invoke = &invoke_INT_lv_fs_file_t_p_POINTER,
        .func_ptr = (void*)&lv_fs_tell,
        .ret_type = "lv_fs_res_t",
        .arg_types = { "lv_fs_file_t *", "uint32_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_fs_up",
        .invoke = &invoke_const_char_p_const_char_p,
        .func_ptr = (void*)&lv_fs_up,
        .ret_type = "char *",
        .arg_types = { "char *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_fs_write",
        .invoke = &invoke_INT_lv_fs_file_t_p_POINTER_INT_POINTER,
        .func_ptr = (void*)&lv_fs_write,
        .ret_type = "lv_fs_res_t",
        .arg_types = { "lv_fs_file_t *", "void *", "uint32_t", "uint32_t *", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_grad_horizontal_init",
        .invoke = &invoke_void_lv_grad_dsc_t_p,
        .func_ptr = (void*)&lv_grad_horizontal_init,
        .ret_type = "void",
        .arg_types = { "lv_grad_dsc_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_grad_init_stops",
        .invoke = &invoke_void_lv_grad_dsc_t_p_lv_color_t_p_lv_opa_t_p_POINTER_INT,
        .func_ptr = (void*)&lv_grad_init_stops,
        .ret_type = "void",
        .arg_types = { "lv_grad_dsc_t *", "lv_color_t *", "lv_opa_t *", "uint8_t *", "int", NULL, NULL, NULL }
    },
    {
        .name = "lv_grad_vertical_init",
        .invoke = &invoke_void_lv_grad_dsc_t_p,
        .func_ptr = (void*)&lv_grad_vertical_init,
        .ret_type = "void",
        .arg_types = { "lv_grad_dsc_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_grid_fr",
        .invoke = &invoke_INT_INT,
        .func_ptr = (void*)&lv_grid_fr,
        .ret_type = "int32_t",
        .arg_types = { "uint8_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_grid_init",
        .invoke = &invoke_void,
        .func_ptr = (void*)&lv_grid_init,
        .ret_type = "void",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_buf_free",
        .invoke = &invoke_void_lv_image_dsc_t_p,
        .func_ptr = (void*)&lv_image_buf_free,
        .ret_type = "void",
        .arg_types = { "lv_image_dsc_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_buf_set_palette",
        .invoke = &invoke_void_lv_image_dsc_t_p_INT_INT,
        .func_ptr = (void*)&lv_image_buf_set_palette,
        .ret_type = "void",
        .arg_types = { "lv_image_dsc_t *", "uint8_t", "lv_color32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_cache_drop",
        .invoke = &invoke_void,
        .func_ptr = (void*)&lv_image_cache_drop,
        .ret_type = "void",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_cache_dump",
        .invoke = &invoke_void,
        .func_ptr = (void*)&lv_image_cache_dump,
        .ret_type = "void",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_cache_init",
        .invoke = &invoke_INT_INT,
        .func_ptr = (void*)&lv_image_cache_init,
        .ret_type = "lv_result_t",
        .arg_types = { "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_cache_is_enabled",
        .invoke = &invoke_BOOL,
        .func_ptr = (void*)&lv_image_cache_is_enabled,
        .ret_type = "bool",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_cache_iter_create",
        .invoke = &invoke_lv_iter_t_p,
        .func_ptr = (void*)&lv_image_cache_iter_create,
        .ret_type = "lv_iter_t *",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_cache_resize",
        .invoke = &invoke_void_INT_BOOL,
        .func_ptr = (void*)&lv_image_cache_resize,
        .ret_type = "void",
        .arg_types = { "uint32_t", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_image_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_decoder_add_to_cache",
        .invoke = &invoke_lv_cache_entry_t_p_lv_image_decoder_t_p_lv_image_cache_data_t_p_lv_draw_buf_t_p_POINTER,
        .func_ptr = (void*)&lv_image_decoder_add_to_cache,
        .ret_type = "lv_cache_entry_t *",
        .arg_types = { "lv_image_decoder_t *", "lv_image_cache_data_t *", "lv_draw_buf_t *", "void *", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_decoder_close",
        .invoke = &invoke_void_lv_image_decoder_dsc_t_p,
        .func_ptr = (void*)&lv_image_decoder_close,
        .ret_type = "void",
        .arg_types = { "lv_image_decoder_dsc_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_decoder_create",
        .invoke = &invoke_lv_image_decoder_t_p,
        .func_ptr = (void*)&lv_image_decoder_create,
        .ret_type = "lv_image_decoder_t *",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_decoder_delete",
        .invoke = &invoke_void_lv_image_decoder_t_p,
        .func_ptr = (void*)&lv_image_decoder_delete,
        .ret_type = "void",
        .arg_types = { "lv_image_decoder_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_decoder_get_area",
        .invoke = &invoke_INT_lv_image_decoder_dsc_t_p_lv_area_t_p_lv_area_t_p,
        .func_ptr = (void*)&lv_image_decoder_get_area,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_image_decoder_dsc_t *", "lv_area_t *", "lv_area_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_decoder_get_info",
        .invoke = &invoke_INT_POINTER_lv_image_header_t_p,
        .func_ptr = (void*)&lv_image_decoder_get_info,
        .ret_type = "lv_result_t",
        .arg_types = { "void *", "lv_image_header_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_decoder_get_next",
        .invoke = &invoke_lv_image_decoder_t_p_lv_image_decoder_t_p,
        .func_ptr = (void*)&lv_image_decoder_get_next,
        .ret_type = "lv_image_decoder_t *",
        .arg_types = { "lv_image_decoder_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_decoder_open",
        .invoke = &invoke_INT_lv_image_decoder_dsc_t_p_POINTER_lv_image_decoder_args_t_p,
        .func_ptr = (void*)&lv_image_decoder_open,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_image_decoder_dsc_t *", "void *", "lv_image_decoder_args_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_decoder_post_process",
        .invoke = &invoke_lv_draw_buf_t_p_lv_image_decoder_dsc_t_p_lv_draw_buf_t_p,
        .func_ptr = (void*)&lv_image_decoder_post_process,
        .ret_type = "lv_draw_buf_t *",
        .arg_types = { "lv_image_decoder_dsc_t *", "lv_draw_buf_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_decoder_set_close_cb",
        .invoke = &invoke_void_lv_image_decoder_t_p_INT,
        .func_ptr = (void*)&lv_image_decoder_set_close_cb,
        .ret_type = "void",
        .arg_types = { "lv_image_decoder_t *", "lv_image_decoder_close_f_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_decoder_set_get_area_cb",
        .invoke = &invoke_void_lv_image_decoder_t_p_INT,
        .func_ptr = (void*)&lv_image_decoder_set_get_area_cb,
        .ret_type = "void",
        .arg_types = { "lv_image_decoder_t *", "lv_image_decoder_get_area_cb_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_decoder_set_info_cb",
        .invoke = &invoke_void_lv_image_decoder_t_p_INT,
        .func_ptr = (void*)&lv_image_decoder_set_info_cb,
        .ret_type = "void",
        .arg_types = { "lv_image_decoder_t *", "lv_image_decoder_info_f_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_decoder_set_open_cb",
        .invoke = &invoke_void_lv_image_decoder_t_p_INT,
        .func_ptr = (void*)&lv_image_decoder_set_open_cb,
        .ret_type = "void",
        .arg_types = { "lv_image_decoder_t *", "lv_image_decoder_open_f_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_get_antialias",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_image_get_antialias,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_get_bitmap_map_src",
        .invoke = &invoke_lv_image_dsc_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_image_get_bitmap_map_src,
        .ret_type = "lv_image_dsc_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_get_blend_mode",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_image_get_blend_mode,
        .ret_type = "lv_blend_mode_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_get_inner_align",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_image_get_inner_align,
        .ret_type = "lv_image_align_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_get_offset_x",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_image_get_offset_x,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_get_offset_y",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_image_get_offset_y,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_get_pivot",
        .invoke = &invoke_void_lv_obj_t_p_lv_point_t_p,
        .func_ptr = (void*)&lv_image_get_pivot,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_point_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_get_rotation",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_image_get_rotation,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_get_scale",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_image_get_scale,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_get_scale_x",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_image_get_scale_x,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_get_scale_y",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_image_get_scale_y,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_get_src",
        .invoke = &invoke_POINTER_lv_obj_t_p,
        .func_ptr = (void*)&lv_image_get_src,
        .ret_type = "void *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_get_src_height",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_image_get_src_height,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_get_src_width",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_image_get_src_width,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_get_transformed_height",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_image_get_transformed_height,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_get_transformed_width",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_image_get_transformed_width,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_set_antialias",
        .invoke = &invoke_void_lv_obj_t_p_BOOL,
        .func_ptr = (void*)&lv_image_set_antialias,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_set_bitmap_map_src",
        .invoke = &invoke_void_lv_obj_t_p_lv_image_dsc_t_p,
        .func_ptr = (void*)&lv_image_set_bitmap_map_src,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_image_dsc_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_set_blend_mode",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_image_set_blend_mode,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_blend_mode_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_set_inner_align",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_image_set_inner_align,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_image_align_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_set_offset_x",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_image_set_offset_x,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_set_offset_y",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_image_set_offset_y,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_set_pivot",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_image_set_pivot,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_set_rotation",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_image_set_rotation,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_set_scale",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_image_set_scale,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_set_scale_x",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_image_set_scale_x,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_set_scale_y",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_image_set_scale_y,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_set_src",
        .invoke = &invoke_void_lv_obj_t_p_POINTER,
        .func_ptr = (void*)&lv_image_set_src,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_image_src_get_type",
        .invoke = &invoke_INT,
        .func_ptr = (void*)&lv_image_src_get_type,
        .ret_type = "lv_image_src_t",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_imagebutton_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_imagebutton_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_imagebutton_get_src_left",
        .invoke = &invoke_POINTER_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_imagebutton_get_src_left,
        .ret_type = "void *",
        .arg_types = { "lv_obj_t *", "lv_imagebutton_state_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_imagebutton_get_src_middle",
        .invoke = &invoke_POINTER_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_imagebutton_get_src_middle,
        .ret_type = "void *",
        .arg_types = { "lv_obj_t *", "lv_imagebutton_state_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_imagebutton_get_src_right",
        .invoke = &invoke_POINTER_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_imagebutton_get_src_right,
        .ret_type = "void *",
        .arg_types = { "lv_obj_t *", "lv_imagebutton_state_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_imagebutton_set_src",
        .invoke = &invoke_void_lv_obj_t_p_INT_POINTER_POINTER_POINTER,
        .func_ptr = (void*)&lv_imagebutton_set_src,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_imagebutton_state_t", "void *", "void *", "void *", NULL, NULL, NULL }
    },
    {
        .name = "lv_imagebutton_set_state",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_imagebutton_set_state,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_imagebutton_state_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_init",
        .invoke = &invoke_void,
        .func_ptr = (void*)&lv_init,
        .ret_type = "void",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_is_initialized",
        .invoke = &invoke_BOOL,
        .func_ptr = (void*)&lv_is_initialized,
        .ret_type = "bool",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_keyboard_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_keyboard_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_keyboard_def_event_cb",
        .invoke = &invoke_void_lv_event_t_p,
        .func_ptr = (void*)&lv_keyboard_def_event_cb,
        .ret_type = "void",
        .arg_types = { "lv_event_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_keyboard_get_button_text",
        .invoke = &invoke_const_char_p_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_keyboard_get_button_text,
        .ret_type = "char *",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_keyboard_get_map_array",
        .invoke = &invoke_POINTER_lv_obj_t_p,
        .func_ptr = (void*)&lv_keyboard_get_map_array,
        .ret_type = "char **",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_keyboard_get_mode",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_keyboard_get_mode,
        .ret_type = "lv_keyboard_mode_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_keyboard_get_popovers",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_keyboard_get_popovers,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_keyboard_get_selected_button",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_keyboard_get_selected_button,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_keyboard_get_textarea",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_keyboard_get_textarea,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_keyboard_set_mode",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_keyboard_set_mode,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_keyboard_mode_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_keyboard_set_popovers",
        .invoke = &invoke_void_lv_obj_t_p_BOOL,
        .func_ptr = (void*)&lv_keyboard_set_popovers,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_keyboard_set_textarea",
        .invoke = &invoke_void_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_keyboard_set_textarea,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_label_bind_text",
        .invoke = &invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_const_char_p,
        .func_ptr = (void*)&lv_label_bind_text,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_obj_t *", "lv_subject_t *", "char *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_label_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_label_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_label_cut_text",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_label_cut_text,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "uint32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_label_get_letter_on",
        .invoke = &invoke_INT_lv_obj_t_p_lv_point_t_p_BOOL,
        .func_ptr = (void*)&lv_label_get_letter_on,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", "lv_point_t *", "bool", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_label_get_letter_pos",
        .invoke = &invoke_void_lv_obj_t_p_INT_lv_point_t_p,
        .func_ptr = (void*)&lv_label_get_letter_pos,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "lv_point_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_label_get_long_mode",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_label_get_long_mode,
        .ret_type = "lv_label_long_mode_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_label_get_recolor",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_label_get_recolor,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_label_get_text",
        .invoke = &invoke_const_char_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_label_get_text,
        .ret_type = "char *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_label_get_text_selection_end",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_label_get_text_selection_end,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_label_get_text_selection_start",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_label_get_text_selection_start,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_label_ins_text",
        .invoke = &invoke_void_lv_obj_t_p_INT_const_char_p,
        .func_ptr = (void*)&lv_label_ins_text,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "char *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_label_is_char_under_pos",
        .invoke = &invoke_BOOL_lv_obj_t_p_lv_point_t_p,
        .func_ptr = (void*)&lv_label_is_char_under_pos,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "lv_point_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_label_set_long_mode",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_label_set_long_mode,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_label_long_mode_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_label_set_recolor",
        .invoke = &invoke_void_lv_obj_t_p_BOOL,
        .func_ptr = (void*)&lv_label_set_recolor,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_label_set_text",
        .invoke = &invoke_void_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_label_set_text,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_label_set_text_selection_end",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_label_set_text_selection_end,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_label_set_text_selection_start",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_label_set_text_selection_start,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_label_set_text_static",
        .invoke = &invoke_void_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_label_set_text_static,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_layer_bottom",
        .invoke = &invoke_lv_obj_t_p,
        .func_ptr = (void*)&lv_layer_bottom,
        .ret_type = "lv_obj_t *",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_layer_init",
        .invoke = &invoke_void_lv_layer_t_p,
        .func_ptr = (void*)&lv_layer_init,
        .ret_type = "void",
        .arg_types = { "lv_layer_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_layer_reset",
        .invoke = &invoke_void_lv_layer_t_p,
        .func_ptr = (void*)&lv_layer_reset,
        .ret_type = "void",
        .arg_types = { "lv_layer_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_layer_sys",
        .invoke = &invoke_lv_obj_t_p,
        .func_ptr = (void*)&lv_layer_sys,
        .ret_type = "lv_obj_t *",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_layer_top",
        .invoke = &invoke_lv_obj_t_p,
        .func_ptr = (void*)&lv_layer_top,
        .ret_type = "lv_obj_t *",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_layout_register",
        .invoke = &invoke_INT_INT_POINTER,
        .func_ptr = (void*)&lv_layout_register,
        .ret_type = "uint32_t",
        .arg_types = { "lv_layout_update_cb_t", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_line_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_line_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_line_get_point_count",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_line_get_point_count,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_line_get_points",
        .invoke = &invoke_lv_point_precise_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_line_get_points,
        .ret_type = "lv_point_precise_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_line_get_points_mutable",
        .invoke = &invoke_lv_point_precise_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_line_get_points_mutable,
        .ret_type = "lv_point_precise_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_line_get_y_invert",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_line_get_y_invert,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_line_is_point_array_mutable",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_line_is_point_array_mutable,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_line_set_points",
        .invoke = &invoke_void_lv_obj_t_p_lv_point_precise_t_p_INT,
        .func_ptr = (void*)&lv_line_set_points,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_point_precise_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_line_set_points_mutable",
        .invoke = &invoke_void_lv_obj_t_p_lv_point_precise_t_p_INT,
        .func_ptr = (void*)&lv_line_set_points_mutable,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_point_precise_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_line_set_y_invert",
        .invoke = &invoke_void_lv_obj_t_p_BOOL,
        .func_ptr = (void*)&lv_line_set_y_invert,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_list_add_button",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p_POINTER_const_char_p,
        .func_ptr = (void*)&lv_list_add_button,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", "void *", "char *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_list_add_text",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_list_add_text,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_list_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_list_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_list_get_button_text",
        .invoke = &invoke_const_char_p_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_list_get_button_text,
        .ret_type = "char *",
        .arg_types = { "lv_obj_t *", "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_list_set_button_text",
        .invoke = &invoke_void_lv_obj_t_p_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_list_set_button_text,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_ll_chg_list",
        .invoke = &invoke_void_lv_ll_t_p_lv_ll_t_p_POINTER_BOOL,
        .func_ptr = (void*)&lv_ll_chg_list,
        .ret_type = "void",
        .arg_types = { "lv_ll_t *", "lv_ll_t *", "void *", "bool", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_ll_clear",
        .invoke = &invoke_void_lv_ll_t_p,
        .func_ptr = (void*)&lv_ll_clear,
        .ret_type = "void",
        .arg_types = { "lv_ll_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_ll_get_head",
        .invoke = &invoke_POINTER_lv_ll_t_p,
        .func_ptr = (void*)&lv_ll_get_head,
        .ret_type = "void *",
        .arg_types = { "lv_ll_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_ll_get_len",
        .invoke = &invoke_INT_lv_ll_t_p,
        .func_ptr = (void*)&lv_ll_get_len,
        .ret_type = "uint32_t",
        .arg_types = { "lv_ll_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_ll_get_next",
        .invoke = &invoke_POINTER_lv_ll_t_p_POINTER,
        .func_ptr = (void*)&lv_ll_get_next,
        .ret_type = "void *",
        .arg_types = { "lv_ll_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_ll_get_prev",
        .invoke = &invoke_POINTER_lv_ll_t_p_POINTER,
        .func_ptr = (void*)&lv_ll_get_prev,
        .ret_type = "void *",
        .arg_types = { "lv_ll_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_ll_get_tail",
        .invoke = &invoke_POINTER_lv_ll_t_p,
        .func_ptr = (void*)&lv_ll_get_tail,
        .ret_type = "void *",
        .arg_types = { "lv_ll_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_ll_init",
        .invoke = &invoke_void_lv_ll_t_p_INT,
        .func_ptr = (void*)&lv_ll_init,
        .ret_type = "void",
        .arg_types = { "lv_ll_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_ll_ins_head",
        .invoke = &invoke_POINTER_lv_ll_t_p,
        .func_ptr = (void*)&lv_ll_ins_head,
        .ret_type = "void *",
        .arg_types = { "lv_ll_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_ll_ins_prev",
        .invoke = &invoke_POINTER_lv_ll_t_p_POINTER,
        .func_ptr = (void*)&lv_ll_ins_prev,
        .ret_type = "void *",
        .arg_types = { "lv_ll_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_ll_ins_tail",
        .invoke = &invoke_POINTER_lv_ll_t_p,
        .func_ptr = (void*)&lv_ll_ins_tail,
        .ret_type = "void *",
        .arg_types = { "lv_ll_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_ll_is_empty",
        .invoke = &invoke_BOOL_lv_ll_t_p,
        .func_ptr = (void*)&lv_ll_is_empty,
        .ret_type = "bool",
        .arg_types = { "lv_ll_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_ll_move_before",
        .invoke = &invoke_void_lv_ll_t_p_POINTER_POINTER,
        .func_ptr = (void*)&lv_ll_move_before,
        .ret_type = "void",
        .arg_types = { "lv_ll_t *", "void *", "void *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_ll_remove",
        .invoke = &invoke_void_lv_ll_t_p_POINTER,
        .func_ptr = (void*)&lv_ll_remove,
        .ret_type = "void",
        .arg_types = { "lv_ll_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_malloc",
        .invoke = &invoke_POINTER_INT,
        .func_ptr = (void*)&lv_malloc,
        .ret_type = "void *",
        .arg_types = { "size_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_malloc_core",
        .invoke = &invoke_POINTER_INT,
        .func_ptr = (void*)&lv_malloc_core,
        .ret_type = "void *",
        .arg_types = { "size_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_malloc_zeroed",
        .invoke = &invoke_POINTER_INT,
        .func_ptr = (void*)&lv_malloc_zeroed,
        .ret_type = "void *",
        .arg_types = { "size_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_map",
        .invoke = &invoke_INT_INT_INT_INT_INT_INT,
        .func_ptr = (void*)&lv_map,
        .ret_type = "int32_t",
        .arg_types = { "int32_t", "int32_t", "int32_t", "int32_t", "int32_t", NULL, NULL, NULL }
    },
    {
        .name = "lv_mem_add_pool",
        .invoke = &invoke_INT_POINTER_INT,
        .func_ptr = (void*)&lv_mem_add_pool,
        .ret_type = "lv_mem_pool_t",
        .arg_types = { "void *", "size_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_mem_deinit",
        .invoke = &invoke_void,
        .func_ptr = (void*)&lv_mem_deinit,
        .ret_type = "void",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_mem_init",
        .invoke = &invoke_void,
        .func_ptr = (void*)&lv_mem_init,
        .ret_type = "void",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_mem_monitor",
        .invoke = &invoke_void_lv_mem_monitor_t_p,
        .func_ptr = (void*)&lv_mem_monitor,
        .ret_type = "void",
        .arg_types = { "lv_mem_monitor_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_mem_monitor_core",
        .invoke = &invoke_void_lv_mem_monitor_t_p,
        .func_ptr = (void*)&lv_mem_monitor_core,
        .ret_type = "void",
        .arg_types = { "lv_mem_monitor_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_mem_remove_pool",
        .invoke = &invoke_void_INT,
        .func_ptr = (void*)&lv_mem_remove_pool,
        .ret_type = "void",
        .arg_types = { "lv_mem_pool_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_mem_test",
        .invoke = &invoke_INT,
        .func_ptr = (void*)&lv_mem_test,
        .ret_type = "lv_result_t",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_mem_test_core",
        .invoke = &invoke_INT,
        .func_ptr = (void*)&lv_mem_test_core,
        .ret_type = "lv_result_t",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_memcmp",
        .invoke = &invoke_INT_POINTER_POINTER_INT,
        .func_ptr = (void*)&lv_memcmp,
        .ret_type = "int",
        .arg_types = { "void *", "void *", "size_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_memcpy",
        .invoke = &invoke_POINTER_POINTER_POINTER_INT,
        .func_ptr = (void*)&lv_memcpy,
        .ret_type = "void *",
        .arg_types = { "void *", "void *", "size_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_memmove",
        .invoke = &invoke_POINTER_POINTER_POINTER_INT,
        .func_ptr = (void*)&lv_memmove,
        .ret_type = "void *",
        .arg_types = { "void *", "void *", "size_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_memset",
        .invoke = &invoke_void_POINTER_INT_INT,
        .func_ptr = (void*)&lv_memset,
        .ret_type = "void",
        .arg_types = { "void *", "uint8_t", "size_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_memzero",
        .invoke = &invoke_void_POINTER_INT,
        .func_ptr = (void*)&lv_memzero,
        .ret_type = "void",
        .arg_types = { "void *", "size_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_back_button_is_root",
        .invoke = &invoke_BOOL_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_menu_back_button_is_root,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_clear_history",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_menu_clear_history,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_cont_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_menu_cont_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_menu_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_get_cur_main_page",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_menu_get_cur_main_page,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_get_cur_sidebar_page",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_menu_get_cur_sidebar_page,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_get_main_header",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_menu_get_main_header,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_get_main_header_back_button",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_menu_get_main_header_back_button,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_get_sidebar_header",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_menu_get_sidebar_header,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_get_sidebar_header_back_button",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_menu_get_sidebar_header_back_button,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_page_create",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_menu_page_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_section_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_menu_section_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_separator_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_menu_separator_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_set_load_page_event",
        .invoke = &invoke_void_lv_obj_t_p_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_menu_set_load_page_event,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_obj_t *", "lv_obj_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_set_mode_header",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_menu_set_mode_header,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_menu_mode_header_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_set_mode_root_back_button",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_menu_set_mode_root_back_button,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_menu_mode_root_back_button_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_set_page",
        .invoke = &invoke_void_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_menu_set_page,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_set_page_title",
        .invoke = &invoke_void_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_menu_set_page_title,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_set_page_title_static",
        .invoke = &invoke_void_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_menu_set_page_title_static,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_menu_set_sidebar_page",
        .invoke = &invoke_void_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_menu_set_sidebar_page,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_msgbox_add_close_button",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_msgbox_add_close_button,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_msgbox_add_footer_button",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_msgbox_add_footer_button,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_msgbox_add_header_button",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p_POINTER,
        .func_ptr = (void*)&lv_msgbox_add_header_button,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_msgbox_add_text",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_msgbox_add_text,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_msgbox_add_title",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_msgbox_add_title,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_msgbox_close",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_msgbox_close,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_msgbox_close_async",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_msgbox_close_async,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_msgbox_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_msgbox_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_msgbox_get_content",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_msgbox_get_content,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_msgbox_get_footer",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_msgbox_get_footer,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_msgbox_get_header",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_msgbox_get_header,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_msgbox_get_title",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_msgbox_get_title,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_add_event_cb",
        .invoke = &invoke_lv_event_dsc_t_p_lv_obj_t_p_INT_INT_POINTER,
        .func_ptr = (void*)&lv_obj_add_event_cb,
        .ret_type = "lv_event_dsc_t *",
        .arg_types = { "lv_obj_t *", "lv_event_cb_t", "lv_event_code_t", "void *", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_add_flag",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_add_flag,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_obj_flag_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_add_state",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_add_state,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_state_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_add_style",
        .invoke = &invoke_void_lv_obj_t_p_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_obj_add_style,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_style_t *", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_align",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT_INT,
        .func_ptr = (void*)&lv_obj_align,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_align_t", "int32_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_align_to",
        .invoke = &invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT_INT,
        .func_ptr = (void*)&lv_obj_align_to,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_obj_t *", "lv_align_t", "int32_t", "int32_t", NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_allocate_spec_attr",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_allocate_spec_attr,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_area_is_visible",
        .invoke = &invoke_BOOL_lv_obj_t_p_lv_area_t_p,
        .func_ptr = (void*)&lv_obj_area_is_visible,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "lv_area_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_bind_checked",
        .invoke = &invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p,
        .func_ptr = (void*)&lv_obj_bind_checked,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_obj_t *", "lv_subject_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_bind_flag_if_eq",
        .invoke = &invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_bind_flag_if_eq,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_obj_t *", "lv_subject_t *", "lv_obj_flag_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_bind_flag_if_ge",
        .invoke = &invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_bind_flag_if_ge,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_obj_t *", "lv_subject_t *", "lv_obj_flag_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_bind_flag_if_gt",
        .invoke = &invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_bind_flag_if_gt,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_obj_t *", "lv_subject_t *", "lv_obj_flag_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_bind_flag_if_le",
        .invoke = &invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_bind_flag_if_le,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_obj_t *", "lv_subject_t *", "lv_obj_flag_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_bind_flag_if_lt",
        .invoke = &invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_bind_flag_if_lt,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_obj_t *", "lv_subject_t *", "lv_obj_flag_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_bind_flag_if_not_eq",
        .invoke = &invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_bind_flag_if_not_eq,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_obj_t *", "lv_subject_t *", "lv_obj_flag_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_bind_state_if_eq",
        .invoke = &invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_bind_state_if_eq,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_obj_t *", "lv_subject_t *", "lv_state_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_bind_state_if_ge",
        .invoke = &invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_bind_state_if_ge,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_obj_t *", "lv_subject_t *", "lv_state_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_bind_state_if_gt",
        .invoke = &invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_bind_state_if_gt,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_obj_t *", "lv_subject_t *", "lv_state_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_bind_state_if_le",
        .invoke = &invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_bind_state_if_le,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_obj_t *", "lv_subject_t *", "lv_state_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_bind_state_if_lt",
        .invoke = &invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_bind_state_if_lt,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_obj_t *", "lv_subject_t *", "lv_state_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_bind_state_if_not_eq",
        .invoke = &invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_bind_state_if_not_eq,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_obj_t *", "lv_subject_t *", "lv_state_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_calculate_ext_draw_size",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_calculate_ext_draw_size,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_calculate_style_text_align",
        .invoke = &invoke_INT_lv_obj_t_p_INT_const_char_p,
        .func_ptr = (void*)&lv_obj_calculate_style_text_align,
        .ret_type = "lv_text_align_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", "char *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_center",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_center,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_check_type",
        .invoke = &invoke_BOOL_lv_obj_t_p_lv_obj_class_t_p,
        .func_ptr = (void*)&lv_obj_check_type,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "lv_obj_class_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_clean",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_clean,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_obj_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_delete",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_delete,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_delete_anim_completed_cb",
        .invoke = &invoke_void_lv_anim_t_p,
        .func_ptr = (void*)&lv_obj_delete_anim_completed_cb,
        .ret_type = "void",
        .arg_types = { "lv_anim_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_delete_async",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_delete_async,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_delete_delayed",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_delete_delayed,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_dump_tree",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_dump_tree,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_enable_style_refresh",
        .invoke = &invoke_void_BOOL,
        .func_ptr = (void*)&lv_obj_enable_style_refresh,
        .ret_type = "void",
        .arg_types = { "bool", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_event_base",
        .invoke = &invoke_INT_lv_obj_class_t_p_lv_event_t_p,
        .func_ptr = (void*)&lv_obj_event_base,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_obj_class_t *", "lv_event_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_fade_in",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_fade_in,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "uint32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_fade_out",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_fade_out,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "uint32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_child",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_child,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_child_by_type",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p_INT_lv_obj_class_t_p,
        .func_ptr = (void*)&lv_obj_get_child_by_type,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_obj_class_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_child_count",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_child_count,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_child_count_by_type",
        .invoke = &invoke_INT_lv_obj_t_p_lv_obj_class_t_p,
        .func_ptr = (void*)&lv_obj_get_child_count_by_type,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", "lv_obj_class_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_class",
        .invoke = &invoke_lv_obj_class_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_class,
        .ret_type = "lv_obj_class_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_click_area",
        .invoke = &invoke_void_lv_obj_t_p_lv_area_t_p,
        .func_ptr = (void*)&lv_obj_get_click_area,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_area_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_content_coords",
        .invoke = &invoke_void_lv_obj_t_p_lv_area_t_p,
        .func_ptr = (void*)&lv_obj_get_content_coords,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_area_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_content_height",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_content_height,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_content_width",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_content_width,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_coords",
        .invoke = &invoke_void_lv_obj_t_p_lv_area_t_p,
        .func_ptr = (void*)&lv_obj_get_coords,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_area_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_display",
        .invoke = &invoke_lv_display_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_display,
        .ret_type = "lv_display_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_event_count",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_event_count,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_event_dsc",
        .invoke = &invoke_lv_event_dsc_t_p_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_event_dsc,
        .ret_type = "lv_event_dsc_t *",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_group",
        .invoke = &invoke_lv_group_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_group,
        .ret_type = "lv_group_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_height",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_height,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_index",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_index,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_index_by_type",
        .invoke = &invoke_INT_lv_obj_t_p_lv_obj_class_t_p,
        .func_ptr = (void*)&lv_obj_get_index_by_type,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_obj_class_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_local_style_prop",
        .invoke = &invoke_INT_lv_obj_t_p_INT_lv_style_value_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_local_style_prop,
        .ret_type = "lv_style_res_t",
        .arg_types = { "lv_obj_t *", "lv_style_prop_t", "lv_style_value_t *", "lv_style_selector_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_parent",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_parent,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_screen",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_screen,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_scroll_bottom",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_scroll_bottom,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_scroll_dir",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_scroll_dir,
        .ret_type = "lv_dir_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_scroll_end",
        .invoke = &invoke_void_lv_obj_t_p_lv_point_t_p,
        .func_ptr = (void*)&lv_obj_get_scroll_end,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_point_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_scroll_left",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_scroll_left,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_scroll_right",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_scroll_right,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_scroll_snap_x",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_scroll_snap_x,
        .ret_type = "lv_scroll_snap_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_scroll_snap_y",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_scroll_snap_y,
        .ret_type = "lv_scroll_snap_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_scroll_top",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_scroll_top,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_scroll_x",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_scroll_x,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_scroll_y",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_scroll_y,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_scrollbar_area",
        .invoke = &invoke_void_lv_obj_t_p_lv_area_t_p_lv_area_t_p,
        .func_ptr = (void*)&lv_obj_get_scrollbar_area,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_area_t *", "lv_area_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_scrollbar_mode",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_scrollbar_mode,
        .ret_type = "lv_scrollbar_mode_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_self_height",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_self_height,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_self_width",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_self_width,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_sibling",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_sibling,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_sibling_by_type",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p_INT_lv_obj_class_t_p,
        .func_ptr = (void*)&lv_obj_get_sibling_by_type,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_obj_class_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_state",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_state,
        .ret_type = "lv_state_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_align",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_align,
        .ret_type = "lv_align_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_anim",
        .invoke = &invoke_lv_anim_t_p_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_anim,
        .ret_type = "lv_anim_t *",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_anim_duration",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_anim_duration,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_arc_color",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_arc_color,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_arc_color_filtered",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_arc_color_filtered,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_arc_image_src",
        .invoke = &invoke_POINTER_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_arc_image_src,
        .ret_type = "void *",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_arc_opa",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_arc_opa,
        .ret_type = "lv_opa_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_arc_rounded",
        .invoke = &invoke_BOOL_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_arc_rounded,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_arc_width",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_arc_width,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_base_dir",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_base_dir,
        .ret_type = "lv_base_dir_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_bg_color",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_bg_color,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_bg_color_filtered",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_bg_color_filtered,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_bg_grad",
        .invoke = &invoke_lv_grad_dsc_t_p_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_bg_grad,
        .ret_type = "lv_grad_dsc_t *",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_bg_grad_color",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_bg_grad_color,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_bg_grad_color_filtered",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_bg_grad_color_filtered,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_bg_grad_dir",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_bg_grad_dir,
        .ret_type = "lv_grad_dir_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_bg_grad_opa",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_bg_grad_opa,
        .ret_type = "lv_opa_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_bg_grad_stop",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_bg_grad_stop,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_bg_image_opa",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_bg_image_opa,
        .ret_type = "lv_opa_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_bg_image_recolor",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_bg_image_recolor,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_bg_image_recolor_filtered",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_bg_image_recolor_filtered,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_bg_image_recolor_opa",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_bg_image_recolor_opa,
        .ret_type = "lv_opa_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_bg_image_src",
        .invoke = &invoke_POINTER_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_bg_image_src,
        .ret_type = "void *",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_bg_image_tiled",
        .invoke = &invoke_BOOL_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_bg_image_tiled,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_bg_main_opa",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_bg_main_opa,
        .ret_type = "lv_opa_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_bg_main_stop",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_bg_main_stop,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_bg_opa",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_bg_opa,
        .ret_type = "lv_opa_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_bitmap_mask_src",
        .invoke = &invoke_POINTER_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_bitmap_mask_src,
        .ret_type = "void *",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_blend_mode",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_blend_mode,
        .ret_type = "lv_blend_mode_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_border_color",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_border_color,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_border_color_filtered",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_border_color_filtered,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_border_opa",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_border_opa,
        .ret_type = "lv_opa_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_border_post",
        .invoke = &invoke_BOOL_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_border_post,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_border_side",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_border_side,
        .ret_type = "lv_border_side_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_border_width",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_border_width,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_clip_corner",
        .invoke = &invoke_BOOL_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_clip_corner,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_color_filter_dsc",
        .invoke = &invoke_lv_color_filter_dsc_t_p_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_color_filter_dsc,
        .ret_type = "lv_color_filter_dsc_t *",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_color_filter_opa",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_color_filter_opa,
        .ret_type = "lv_opa_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_flex_cross_place",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_flex_cross_place,
        .ret_type = "lv_flex_align_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_flex_flow",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_flex_flow,
        .ret_type = "lv_flex_flow_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_flex_grow",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_flex_grow,
        .ret_type = "uint8_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_flex_main_place",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_flex_main_place,
        .ret_type = "lv_flex_align_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_flex_track_place",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_flex_track_place,
        .ret_type = "lv_flex_align_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_grid_cell_column_pos",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_grid_cell_column_pos,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_grid_cell_column_span",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_grid_cell_column_span,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_grid_cell_row_pos",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_grid_cell_row_pos,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_grid_cell_row_span",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_grid_cell_row_span,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_grid_cell_x_align",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_grid_cell_x_align,
        .ret_type = "lv_grid_align_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_grid_cell_y_align",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_grid_cell_y_align,
        .ret_type = "lv_grid_align_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_grid_column_align",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_grid_column_align,
        .ret_type = "lv_grid_align_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_grid_column_dsc_array",
        .invoke = &invoke_POINTER_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_grid_column_dsc_array,
        .ret_type = "int32_t *",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_grid_row_align",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_grid_row_align,
        .ret_type = "lv_grid_align_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_grid_row_dsc_array",
        .invoke = &invoke_POINTER_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_grid_row_dsc_array,
        .ret_type = "int32_t *",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_height",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_height,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_image_opa",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_image_opa,
        .ret_type = "lv_opa_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_image_recolor",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_image_recolor,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_image_recolor_filtered",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_image_recolor_filtered,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_image_recolor_opa",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_image_recolor_opa,
        .ret_type = "lv_opa_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_layout",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_layout,
        .ret_type = "uint16_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_length",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_length,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_line_color",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_line_color,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_line_color_filtered",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_line_color_filtered,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_line_dash_gap",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_line_dash_gap,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_line_dash_width",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_line_dash_width,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_line_opa",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_line_opa,
        .ret_type = "lv_opa_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_line_rounded",
        .invoke = &invoke_BOOL_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_line_rounded,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_line_width",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_line_width,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_margin_bottom",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_margin_bottom,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_margin_left",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_margin_left,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_margin_right",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_margin_right,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_margin_top",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_margin_top,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_max_height",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_max_height,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_max_width",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_max_width,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_min_height",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_min_height,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_min_width",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_min_width,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_opa",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_opa,
        .ret_type = "lv_opa_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_opa_layered",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_opa_layered,
        .ret_type = "lv_opa_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_opa_recursive",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_opa_recursive,
        .ret_type = "lv_opa_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_outline_color",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_outline_color,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_outline_color_filtered",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_outline_color_filtered,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_outline_opa",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_outline_opa,
        .ret_type = "lv_opa_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_outline_pad",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_outline_pad,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_outline_width",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_outline_width,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_pad_bottom",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_pad_bottom,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_pad_column",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_pad_column,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_pad_left",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_pad_left,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_pad_radial",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_pad_radial,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_pad_right",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_pad_right,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_pad_row",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_pad_row,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_pad_top",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_pad_top,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_prop",
        .invoke = &invoke_INT_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_get_style_prop,
        .ret_type = "lv_style_value_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", "lv_style_prop_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_radial_offset",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_radial_offset,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_radius",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_radius,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_recolor",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_recolor,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_recolor_opa",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_recolor_opa,
        .ret_type = "lv_opa_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_recolor_recursive",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_recolor_recursive,
        .ret_type = "lv_color32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_rotary_sensitivity",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_rotary_sensitivity,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_shadow_color",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_shadow_color,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_shadow_color_filtered",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_shadow_color_filtered,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_shadow_offset_x",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_shadow_offset_x,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_shadow_offset_y",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_shadow_offset_y,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_shadow_opa",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_shadow_opa,
        .ret_type = "lv_opa_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_shadow_spread",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_shadow_spread,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_shadow_width",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_shadow_width,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_space_bottom",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_space_bottom,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_space_left",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_space_left,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_space_right",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_space_right,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_space_top",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_space_top,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_text_align",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_text_align,
        .ret_type = "lv_text_align_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_text_color",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_text_color,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_text_color_filtered",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_text_color_filtered,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_text_decor",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_text_decor,
        .ret_type = "lv_text_decor_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_text_font",
        .invoke = &invoke_lv_font_t_p_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_text_font,
        .ret_type = "lv_font_t *",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_text_letter_space",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_text_letter_space,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_text_line_space",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_text_line_space,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_text_opa",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_text_opa,
        .ret_type = "lv_opa_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_text_outline_stroke_color",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_text_outline_stroke_color,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_text_outline_stroke_color_filtered",
        .invoke = &invoke_lv_color_t_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_text_outline_stroke_color_filtered,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_text_outline_stroke_opa",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_text_outline_stroke_opa,
        .ret_type = "lv_opa_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_text_outline_stroke_width",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_text_outline_stroke_width,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_transform_height",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_transform_height,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_transform_pivot_x",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_transform_pivot_x,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_transform_pivot_y",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_transform_pivot_y,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_transform_rotation",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_transform_rotation,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_transform_scale_x",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_transform_scale_x,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_transform_scale_x_safe",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_transform_scale_x_safe,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_transform_scale_y",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_transform_scale_y,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_transform_scale_y_safe",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_transform_scale_y_safe,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_transform_skew_x",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_transform_skew_x,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_transform_skew_y",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_transform_skew_y,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_transform_width",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_transform_width,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_transition",
        .invoke = &invoke_lv_style_transition_dsc_t_p_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_transition,
        .ret_type = "lv_style_transition_dsc_t *",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_translate_radial",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_translate_radial,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_translate_x",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_translate_x,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_translate_y",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_translate_y,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_width",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_width,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_x",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_x,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_style_y",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_style_y,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_transform",
        .invoke = &invoke_lv_matrix_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_transform,
        .ret_type = "lv_matrix_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_transformed_area",
        .invoke = &invoke_void_lv_obj_t_p_lv_area_t_p_INT,
        .func_ptr = (void*)&lv_obj_get_transformed_area,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_area_t *", "lv_obj_point_transform_flag_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_user_data",
        .invoke = &invoke_POINTER_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_user_data,
        .ret_type = "void *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_width",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_width,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_x",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_x,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_x2",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_x2,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_x_aligned",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_x_aligned,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_y",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_y,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_y2",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_y2,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_get_y_aligned",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_get_y_aligned,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_has_class",
        .invoke = &invoke_BOOL_lv_obj_t_p_lv_obj_class_t_p,
        .func_ptr = (void*)&lv_obj_has_class,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "lv_obj_class_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_has_flag",
        .invoke = &invoke_BOOL_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_has_flag,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "lv_obj_flag_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_has_flag_any",
        .invoke = &invoke_BOOL_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_has_flag_any,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "lv_obj_flag_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_has_state",
        .invoke = &invoke_BOOL_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_has_state,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "lv_state_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_has_style_prop",
        .invoke = &invoke_BOOL_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_has_style_prop,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "lv_style_selector_t", "lv_style_prop_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_hit_test",
        .invoke = &invoke_BOOL_lv_obj_t_p_lv_point_t_p,
        .func_ptr = (void*)&lv_obj_hit_test,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "lv_point_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_init_draw_arc_dsc",
        .invoke = &invoke_void_lv_obj_t_p_INT_lv_draw_arc_dsc_t_p,
        .func_ptr = (void*)&lv_obj_init_draw_arc_dsc,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_part_t", "lv_draw_arc_dsc_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_init_draw_image_dsc",
        .invoke = &invoke_void_lv_obj_t_p_INT_lv_draw_image_dsc_t_p,
        .func_ptr = (void*)&lv_obj_init_draw_image_dsc,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_part_t", "lv_draw_image_dsc_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_init_draw_label_dsc",
        .invoke = &invoke_void_lv_obj_t_p_INT_lv_draw_label_dsc_t_p,
        .func_ptr = (void*)&lv_obj_init_draw_label_dsc,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_part_t", "lv_draw_label_dsc_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_init_draw_line_dsc",
        .invoke = &invoke_void_lv_obj_t_p_INT_lv_draw_line_dsc_t_p,
        .func_ptr = (void*)&lv_obj_init_draw_line_dsc,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_part_t", "lv_draw_line_dsc_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_init_draw_rect_dsc",
        .invoke = &invoke_void_lv_obj_t_p_INT_lv_draw_rect_dsc_t_p,
        .func_ptr = (void*)&lv_obj_init_draw_rect_dsc,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_part_t", "lv_draw_rect_dsc_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_invalidate",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_invalidate,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_invalidate_area",
        .invoke = &invoke_void_lv_obj_t_p_lv_area_t_p,
        .func_ptr = (void*)&lv_obj_invalidate_area,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_area_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_is_editable",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_is_editable,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_is_group_def",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_is_group_def,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_is_layout_positioned",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_is_layout_positioned,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_is_scrolling",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_is_scrolling,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_is_valid",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_is_valid,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_is_visible",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_is_visible,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_mark_layout_as_dirty",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_mark_layout_as_dirty,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_move_background",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_move_background,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_move_children_by",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT_BOOL,
        .func_ptr = (void*)&lv_obj_move_children_by,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "int32_t", "bool", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_move_foreground",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_move_foreground,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_move_to",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_move_to,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_move_to_index",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_move_to_index,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_null_on_delete",
        .invoke = &invoke_void_POINTER,
        .func_ptr = (void*)&lv_obj_null_on_delete,
        .ret_type = "void",
        .arg_types = { "lv_obj_t **", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_readjust_scroll",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_readjust_scroll,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_anim_enable_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_redraw",
        .invoke = &invoke_void_lv_layer_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_redraw,
        .ret_type = "void",
        .arg_types = { "lv_layer_t *", "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_refr_pos",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_refr_pos,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_refr_size",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_refr_size,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_refresh_ext_draw_size",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_refresh_ext_draw_size,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_refresh_self_size",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_refresh_self_size,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_refresh_style",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_refresh_style,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_part_t", "lv_style_prop_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_remove_event",
        .invoke = &invoke_BOOL_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_remove_event,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_remove_event_cb",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_remove_event_cb,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", "lv_event_cb_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_remove_event_cb_with_user_data",
        .invoke = &invoke_INT_lv_obj_t_p_INT_POINTER,
        .func_ptr = (void*)&lv_obj_remove_event_cb_with_user_data,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", "lv_event_cb_t", "void *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_remove_event_dsc",
        .invoke = &invoke_BOOL_lv_obj_t_p_lv_event_dsc_t_p,
        .func_ptr = (void*)&lv_obj_remove_event_dsc,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "lv_event_dsc_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_remove_flag",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_remove_flag,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_obj_flag_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_remove_from_subject",
        .invoke = &invoke_void_lv_obj_t_p_lv_subject_t_p,
        .func_ptr = (void*)&lv_obj_remove_from_subject,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_subject_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_remove_local_style_prop",
        .invoke = &invoke_BOOL_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_remove_local_style_prop,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "lv_style_prop_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_remove_state",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_remove_state,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_state_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_remove_style",
        .invoke = &invoke_void_lv_obj_t_p_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_obj_remove_style,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_style_t *", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_remove_style_all",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_remove_style_all,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_replace_style",
        .invoke = &invoke_BOOL_lv_obj_t_p_lv_style_t_p_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_obj_replace_style,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "lv_style_t *", "lv_style_t *", "lv_style_selector_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_report_style_change",
        .invoke = &invoke_void_lv_style_t_p,
        .func_ptr = (void*)&lv_obj_report_style_change,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_reset_transform",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_reset_transform,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_scroll_by",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT_INT,
        .func_ptr = (void*)&lv_obj_scroll_by,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "int32_t", "lv_anim_enable_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_scroll_by_bounded",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT_INT,
        .func_ptr = (void*)&lv_obj_scroll_by_bounded,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "int32_t", "lv_anim_enable_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_scroll_to",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT_INT,
        .func_ptr = (void*)&lv_obj_scroll_to,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "int32_t", "lv_anim_enable_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_scroll_to_view",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_scroll_to_view,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_anim_enable_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_scroll_to_view_recursive",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_scroll_to_view_recursive,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_anim_enable_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_scroll_to_x",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_scroll_to_x,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_anim_enable_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_scroll_to_y",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_scroll_to_y,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_anim_enable_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_scrollbar_invalidate",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_scrollbar_invalidate,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_send_event",
        .invoke = &invoke_INT_lv_obj_t_p_INT_POINTER,
        .func_ptr = (void*)&lv_obj_send_event,
        .ret_type = "lv_result_t",
        .arg_types = { "lv_obj_t *", "lv_event_code_t", "void *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_align",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_align,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_align_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_content_height",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_content_height,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_content_width",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_content_width,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_ext_click_area",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_ext_click_area,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_flag",
        .invoke = &invoke_void_lv_obj_t_p_INT_BOOL,
        .func_ptr = (void*)&lv_obj_set_flag,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_obj_flag_t", "bool", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_flex_align",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT_INT,
        .func_ptr = (void*)&lv_obj_set_flex_align,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_flex_align_t", "lv_flex_align_t", "lv_flex_align_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_flex_flow",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_flex_flow,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_flex_flow_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_flex_grow",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_flex_grow,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint8_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_grid_align",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_grid_align,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_grid_align_t", "lv_grid_align_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_grid_cell",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT_INT_INT_INT_INT,
        .func_ptr = (void*)&lv_obj_set_grid_cell,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_grid_align_t", "int32_t", "int32_t", "lv_grid_align_t", "int32_t", "int32_t", NULL }
    },
    {
        .name = "lv_obj_set_grid_dsc_array",
        .invoke = &invoke_void_lv_obj_t_p_POINTER_POINTER,
        .func_ptr = (void*)&lv_obj_set_grid_dsc_array,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t *", "int32_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_height",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_height,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_layout",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_layout,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_local_style_prop",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT_INT,
        .func_ptr = (void*)&lv_obj_set_local_style_prop,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_style_prop_t", "lv_style_value_t", "lv_style_selector_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_parent",
        .invoke = &invoke_void_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_set_parent,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_pos",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_pos,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_scroll_dir",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_scroll_dir,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_dir_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_scroll_snap_x",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_scroll_snap_x,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_scroll_snap_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_scroll_snap_y",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_scroll_snap_y,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_scroll_snap_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_scrollbar_mode",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_scrollbar_mode,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_scrollbar_mode_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_size",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_size,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_state",
        .invoke = &invoke_void_lv_obj_t_p_INT_BOOL,
        .func_ptr = (void*)&lv_obj_set_state,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_state_t", "bool", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_align",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_align,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_align_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_anim",
        .invoke = &invoke_void_lv_obj_t_p_lv_anim_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_style_anim,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_anim_t *", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_anim_duration",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_anim_duration,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_arc_color",
        .invoke = &invoke_void_lv_obj_t_p_lv_color_t_INT,
        .func_ptr = (void*)&lv_obj_set_style_arc_color,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_color_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_arc_image_src",
        .invoke = &invoke_void_lv_obj_t_p_POINTER_INT,
        .func_ptr = (void*)&lv_obj_set_style_arc_image_src,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "void *", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_arc_opa",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_arc_opa,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_opa_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_arc_rounded",
        .invoke = &invoke_void_lv_obj_t_p_BOOL_INT,
        .func_ptr = (void*)&lv_obj_set_style_arc_rounded,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "bool", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_arc_width",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_arc_width,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_base_dir",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_base_dir,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_base_dir_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_bg_color",
        .invoke = &invoke_void_lv_obj_t_p_lv_color_t_INT,
        .func_ptr = (void*)&lv_obj_set_style_bg_color,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_color_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_bg_grad",
        .invoke = &invoke_void_lv_obj_t_p_lv_grad_dsc_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_style_bg_grad,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_grad_dsc_t *", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_bg_grad_color",
        .invoke = &invoke_void_lv_obj_t_p_lv_color_t_INT,
        .func_ptr = (void*)&lv_obj_set_style_bg_grad_color,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_color_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_bg_grad_dir",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_bg_grad_dir,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_grad_dir_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_bg_grad_opa",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_bg_grad_opa,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_opa_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_bg_grad_stop",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_bg_grad_stop,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_bg_image_opa",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_bg_image_opa,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_opa_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_bg_image_recolor",
        .invoke = &invoke_void_lv_obj_t_p_lv_color_t_INT,
        .func_ptr = (void*)&lv_obj_set_style_bg_image_recolor,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_color_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_bg_image_recolor_opa",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_bg_image_recolor_opa,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_opa_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_bg_image_src",
        .invoke = &invoke_void_lv_obj_t_p_POINTER_INT,
        .func_ptr = (void*)&lv_obj_set_style_bg_image_src,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "void *", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_bg_image_tiled",
        .invoke = &invoke_void_lv_obj_t_p_BOOL_INT,
        .func_ptr = (void*)&lv_obj_set_style_bg_image_tiled,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "bool", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_bg_main_opa",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_bg_main_opa,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_opa_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_bg_main_stop",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_bg_main_stop,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_bg_opa",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_bg_opa,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_opa_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_bitmap_mask_src",
        .invoke = &invoke_void_lv_obj_t_p_POINTER_INT,
        .func_ptr = (void*)&lv_obj_set_style_bitmap_mask_src,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "void *", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_blend_mode",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_blend_mode,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_blend_mode_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_border_color",
        .invoke = &invoke_void_lv_obj_t_p_lv_color_t_INT,
        .func_ptr = (void*)&lv_obj_set_style_border_color,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_color_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_border_opa",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_border_opa,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_opa_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_border_post",
        .invoke = &invoke_void_lv_obj_t_p_BOOL_INT,
        .func_ptr = (void*)&lv_obj_set_style_border_post,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "bool", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_border_side",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_border_side,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_border_side_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_border_width",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_border_width,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_clip_corner",
        .invoke = &invoke_void_lv_obj_t_p_BOOL_INT,
        .func_ptr = (void*)&lv_obj_set_style_clip_corner,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "bool", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_color_filter_dsc",
        .invoke = &invoke_void_lv_obj_t_p_lv_color_filter_dsc_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_style_color_filter_dsc,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_color_filter_dsc_t *", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_color_filter_opa",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_color_filter_opa,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_opa_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_flex_cross_place",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_flex_cross_place,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_flex_align_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_flex_flow",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_flex_flow,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_flex_flow_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_flex_grow",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_flex_grow,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint8_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_flex_main_place",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_flex_main_place,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_flex_align_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_flex_track_place",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_flex_track_place,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_flex_align_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_grid_cell_column_pos",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_grid_cell_column_pos,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_grid_cell_column_span",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_grid_cell_column_span,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_grid_cell_row_pos",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_grid_cell_row_pos,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_grid_cell_row_span",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_grid_cell_row_span,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_grid_cell_x_align",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_grid_cell_x_align,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_grid_align_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_grid_cell_y_align",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_grid_cell_y_align,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_grid_align_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_grid_column_align",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_grid_column_align,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_grid_align_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_grid_column_dsc_array",
        .invoke = &invoke_void_lv_obj_t_p_POINTER_INT,
        .func_ptr = (void*)&lv_obj_set_style_grid_column_dsc_array,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t *", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_grid_row_align",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_grid_row_align,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_grid_align_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_grid_row_dsc_array",
        .invoke = &invoke_void_lv_obj_t_p_POINTER_INT,
        .func_ptr = (void*)&lv_obj_set_style_grid_row_dsc_array,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t *", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_height",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_height,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_image_opa",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_image_opa,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_opa_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_image_recolor",
        .invoke = &invoke_void_lv_obj_t_p_lv_color_t_INT,
        .func_ptr = (void*)&lv_obj_set_style_image_recolor,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_color_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_image_recolor_opa",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_image_recolor_opa,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_opa_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_layout",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_layout,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint16_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_length",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_length,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_line_color",
        .invoke = &invoke_void_lv_obj_t_p_lv_color_t_INT,
        .func_ptr = (void*)&lv_obj_set_style_line_color,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_color_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_line_dash_gap",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_line_dash_gap,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_line_dash_width",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_line_dash_width,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_line_opa",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_line_opa,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_opa_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_line_rounded",
        .invoke = &invoke_void_lv_obj_t_p_BOOL_INT,
        .func_ptr = (void*)&lv_obj_set_style_line_rounded,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "bool", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_line_width",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_line_width,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_margin_all",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_margin_all,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_margin_bottom",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_margin_bottom,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_margin_hor",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_margin_hor,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_margin_left",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_margin_left,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_margin_right",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_margin_right,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_margin_top",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_margin_top,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_margin_ver",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_margin_ver,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_max_height",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_max_height,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_max_width",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_max_width,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_min_height",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_min_height,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_min_width",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_min_width,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_opa",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_opa,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_opa_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_opa_layered",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_opa_layered,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_opa_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_outline_color",
        .invoke = &invoke_void_lv_obj_t_p_lv_color_t_INT,
        .func_ptr = (void*)&lv_obj_set_style_outline_color,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_color_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_outline_opa",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_outline_opa,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_opa_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_outline_pad",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_outline_pad,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_outline_width",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_outline_width,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_pad_all",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_pad_all,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_pad_bottom",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_pad_bottom,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_pad_column",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_pad_column,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_pad_gap",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_pad_gap,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_pad_hor",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_pad_hor,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_pad_left",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_pad_left,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_pad_radial",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_pad_radial,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_pad_right",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_pad_right,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_pad_row",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_pad_row,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_pad_top",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_pad_top,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_pad_ver",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_pad_ver,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_radial_offset",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_radial_offset,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_radius",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_radius,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_recolor",
        .invoke = &invoke_void_lv_obj_t_p_lv_color_t_INT,
        .func_ptr = (void*)&lv_obj_set_style_recolor,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_color_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_recolor_opa",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_recolor_opa,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_opa_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_rotary_sensitivity",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_rotary_sensitivity,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_shadow_color",
        .invoke = &invoke_void_lv_obj_t_p_lv_color_t_INT,
        .func_ptr = (void*)&lv_obj_set_style_shadow_color,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_color_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_shadow_offset_x",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_shadow_offset_x,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_shadow_offset_y",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_shadow_offset_y,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_shadow_opa",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_shadow_opa,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_opa_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_shadow_spread",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_shadow_spread,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_shadow_width",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_shadow_width,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_size",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_size,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_text_align",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_text_align,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_text_align_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_text_color",
        .invoke = &invoke_void_lv_obj_t_p_lv_color_t_INT,
        .func_ptr = (void*)&lv_obj_set_style_text_color,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_color_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_text_decor",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_text_decor,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_text_decor_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_text_font",
        .invoke = &invoke_void_lv_obj_t_p_lv_font_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_style_text_font,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_font_t *", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_text_letter_space",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_text_letter_space,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_text_line_space",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_text_line_space,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_text_opa",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_text_opa,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_opa_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_text_outline_stroke_color",
        .invoke = &invoke_void_lv_obj_t_p_lv_color_t_INT,
        .func_ptr = (void*)&lv_obj_set_style_text_outline_stroke_color,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_color_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_text_outline_stroke_opa",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_text_outline_stroke_opa,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_opa_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_text_outline_stroke_width",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_text_outline_stroke_width,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_transform_height",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_transform_height,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_transform_pivot_x",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_transform_pivot_x,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_transform_pivot_y",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_transform_pivot_y,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_transform_rotation",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_transform_rotation,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_transform_scale",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_transform_scale,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_transform_scale_x",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_transform_scale_x,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_transform_scale_y",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_transform_scale_y,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_transform_skew_x",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_transform_skew_x,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_transform_skew_y",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_transform_skew_y,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_transform_width",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_transform_width,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_transition",
        .invoke = &invoke_void_lv_obj_t_p_lv_style_transition_dsc_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_style_transition,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_style_transition_dsc_t *", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_translate_radial",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_translate_radial,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_translate_x",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_translate_x,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_translate_y",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_translate_y,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_width",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_width,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_x",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_x,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_style_y",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_set_style_y,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_transform",
        .invoke = &invoke_void_lv_obj_t_p_lv_matrix_t_p,
        .func_ptr = (void*)&lv_obj_set_transform,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_matrix_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_user_data",
        .invoke = &invoke_void_lv_obj_t_p_POINTER,
        .func_ptr = (void*)&lv_obj_set_user_data,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_width",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_width,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_x",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_x,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_set_y",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_set_y,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_stop_scroll_anim",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_stop_scroll_anim,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_style_apply_color_filter",
        .invoke = &invoke_INT_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_style_apply_color_filter,
        .ret_type = "lv_style_value_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", "lv_style_value_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_style_apply_recolor",
        .invoke = &invoke_INT_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_style_apply_recolor,
        .ret_type = "lv_color32_t",
        .arg_types = { "lv_obj_t *", "lv_part_t", "lv_color32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_style_get_selector_part",
        .invoke = &invoke_INT_INT,
        .func_ptr = (void*)&lv_obj_style_get_selector_part,
        .ret_type = "lv_part_t",
        .arg_types = { "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_style_get_selector_state",
        .invoke = &invoke_INT_INT,
        .func_ptr = (void*)&lv_obj_style_get_selector_state,
        .ret_type = "lv_state_t",
        .arg_types = { "lv_style_selector_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_swap",
        .invoke = &invoke_void_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_swap,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_transform_point",
        .invoke = &invoke_void_lv_obj_t_p_lv_point_t_p_INT,
        .func_ptr = (void*)&lv_obj_transform_point,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_point_t *", "lv_obj_point_transform_flag_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_transform_point_array",
        .invoke = &invoke_void_lv_obj_t_p_lv_point_t_p_INT_INT,
        .func_ptr = (void*)&lv_obj_transform_point_array,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_point_t *", "size_t", "lv_obj_point_transform_flag_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_tree_walk",
        .invoke = &invoke_void_lv_obj_t_p_INT_POINTER,
        .func_ptr = (void*)&lv_obj_tree_walk,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_obj_tree_walk_cb_t", "void *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_update_layout",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_obj_update_layout,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_obj_update_snap",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_obj_update_snap,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_anim_enable_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_observer_get_target",
        .invoke = &invoke_POINTER_lv_observer_t_p,
        .func_ptr = (void*)&lv_observer_get_target,
        .ret_type = "void *",
        .arg_types = { "lv_observer_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_observer_get_target_obj",
        .invoke = &invoke_lv_obj_t_p_lv_observer_t_p,
        .func_ptr = (void*)&lv_observer_get_target_obj,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_observer_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_observer_get_user_data",
        .invoke = &invoke_POINTER_lv_observer_t_p,
        .func_ptr = (void*)&lv_observer_get_user_data,
        .ret_type = "void *",
        .arg_types = { "lv_observer_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_observer_remove",
        .invoke = &invoke_void_lv_observer_t_p,
        .func_ptr = (void*)&lv_observer_remove,
        .ret_type = "void",
        .arg_types = { "lv_observer_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_palette_darken",
        .invoke = &invoke_lv_color_t_INT_INT,
        .func_ptr = (void*)&lv_palette_darken,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_palette_t", "uint8_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_palette_lighten",
        .invoke = &invoke_lv_color_t_INT_INT,
        .func_ptr = (void*)&lv_palette_lighten,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_palette_t", "uint8_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_palette_main",
        .invoke = &invoke_lv_color_t_INT,
        .func_ptr = (void*)&lv_palette_main,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_palette_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_pct",
        .invoke = &invoke_INT_INT,
        .func_ptr = (void*)&lv_pct,
        .ret_type = "int32_t",
        .arg_types = { "int32_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_pct_to_px",
        .invoke = &invoke_INT_INT_INT,
        .func_ptr = (void*)&lv_pct_to_px,
        .ret_type = "int32_t",
        .arg_types = { "int32_t", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_point_array_transform",
        .invoke = &invoke_void_lv_point_t_p_INT_INT_INT_INT_lv_point_t_p_BOOL,
        .func_ptr = (void*)&lv_point_array_transform,
        .ret_type = "void",
        .arg_types = { "lv_point_t *", "size_t", "int32_t", "int32_t", "int32_t", "lv_point_t *", "bool", NULL }
    },
    {
        .name = "lv_point_from_precise",
        .invoke = &invoke_INT_lv_point_precise_t_p,
        .func_ptr = (void*)&lv_point_from_precise,
        .ret_type = "lv_point_t",
        .arg_types = { "lv_point_precise_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_point_precise_set",
        .invoke = &invoke_void_lv_point_precise_t_p_INT_INT,
        .func_ptr = (void*)&lv_point_precise_set,
        .ret_type = "void",
        .arg_types = { "lv_point_precise_t *", "lv_value_precise_t", "lv_value_precise_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_point_precise_swap",
        .invoke = &invoke_void_lv_point_precise_t_p_lv_point_precise_t_p,
        .func_ptr = (void*)&lv_point_precise_swap,
        .ret_type = "void",
        .arg_types = { "lv_point_precise_t *", "lv_point_precise_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_point_set",
        .invoke = &invoke_void_lv_point_t_p_INT_INT,
        .func_ptr = (void*)&lv_point_set,
        .ret_type = "void",
        .arg_types = { "lv_point_t *", "int32_t", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_point_swap",
        .invoke = &invoke_void_lv_point_t_p_lv_point_t_p,
        .func_ptr = (void*)&lv_point_swap,
        .ret_type = "void",
        .arg_types = { "lv_point_t *", "lv_point_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_point_to_precise",
        .invoke = &invoke_INT_lv_point_t_p,
        .func_ptr = (void*)&lv_point_to_precise,
        .ret_type = "lv_point_precise_t",
        .arg_types = { "lv_point_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_point_transform",
        .invoke = &invoke_void_lv_point_t_p_INT_INT_INT_lv_point_t_p_BOOL,
        .func_ptr = (void*)&lv_point_transform,
        .ret_type = "void",
        .arg_types = { "lv_point_t *", "int32_t", "int32_t", "int32_t", "lv_point_t *", "bool", NULL, NULL }
    },
    {
        .name = "lv_pow",
        .invoke = &invoke_INT_INT_INT,
        .func_ptr = (void*)&lv_pow,
        .ret_type = "int64_t",
        .arg_types = { "int64_t", "int8_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_rand",
        .invoke = &invoke_INT_INT_INT,
        .func_ptr = (void*)&lv_rand,
        .ret_type = "uint32_t",
        .arg_types = { "uint32_t", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_rand_set_seed",
        .invoke = &invoke_void_INT,
        .func_ptr = (void*)&lv_rand_set_seed,
        .ret_type = "void",
        .arg_types = { "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_rb_destroy",
        .invoke = &invoke_void_lv_rb_t_p,
        .func_ptr = (void*)&lv_rb_destroy,
        .ret_type = "void",
        .arg_types = { "lv_rb_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_rb_drop",
        .invoke = &invoke_BOOL_lv_rb_t_p_POINTER,
        .func_ptr = (void*)&lv_rb_drop,
        .ret_type = "bool",
        .arg_types = { "lv_rb_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_rb_drop_node",
        .invoke = &invoke_BOOL_lv_rb_t_p_lv_rb_node_t_p,
        .func_ptr = (void*)&lv_rb_drop_node,
        .ret_type = "bool",
        .arg_types = { "lv_rb_t *", "lv_rb_node_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_rb_find",
        .invoke = &invoke_lv_rb_node_t_p_lv_rb_t_p_POINTER,
        .func_ptr = (void*)&lv_rb_find,
        .ret_type = "lv_rb_node_t *",
        .arg_types = { "lv_rb_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_rb_init",
        .invoke = &invoke_BOOL_lv_rb_t_p_INT_INT,
        .func_ptr = (void*)&lv_rb_init,
        .ret_type = "bool",
        .arg_types = { "lv_rb_t *", "lv_rb_compare_t", "size_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_rb_insert",
        .invoke = &invoke_lv_rb_node_t_p_lv_rb_t_p_POINTER,
        .func_ptr = (void*)&lv_rb_insert,
        .ret_type = "lv_rb_node_t *",
        .arg_types = { "lv_rb_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_rb_maximum",
        .invoke = &invoke_lv_rb_node_t_p_lv_rb_t_p,
        .func_ptr = (void*)&lv_rb_maximum,
        .ret_type = "lv_rb_node_t *",
        .arg_types = { "lv_rb_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_rb_maximum_from",
        .invoke = &invoke_lv_rb_node_t_p_lv_rb_node_t_p,
        .func_ptr = (void*)&lv_rb_maximum_from,
        .ret_type = "lv_rb_node_t *",
        .arg_types = { "lv_rb_node_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_rb_minimum",
        .invoke = &invoke_lv_rb_node_t_p_lv_rb_t_p,
        .func_ptr = (void*)&lv_rb_minimum,
        .ret_type = "lv_rb_node_t *",
        .arg_types = { "lv_rb_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_rb_minimum_from",
        .invoke = &invoke_lv_rb_node_t_p_lv_rb_node_t_p,
        .func_ptr = (void*)&lv_rb_minimum_from,
        .ret_type = "lv_rb_node_t *",
        .arg_types = { "lv_rb_node_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_rb_remove",
        .invoke = &invoke_POINTER_lv_rb_t_p_POINTER,
        .func_ptr = (void*)&lv_rb_remove,
        .ret_type = "void *",
        .arg_types = { "lv_rb_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_rb_remove_node",
        .invoke = &invoke_POINTER_lv_rb_t_p_lv_rb_node_t_p,
        .func_ptr = (void*)&lv_rb_remove_node,
        .ret_type = "void *",
        .arg_types = { "lv_rb_t *", "lv_rb_node_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_realloc",
        .invoke = &invoke_POINTER_POINTER_INT,
        .func_ptr = (void*)&lv_realloc,
        .ret_type = "void *",
        .arg_types = { "void *", "size_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_realloc_core",
        .invoke = &invoke_POINTER_POINTER_INT,
        .func_ptr = (void*)&lv_realloc_core,
        .ret_type = "void *",
        .arg_types = { "void *", "size_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_reallocf",
        .invoke = &invoke_POINTER_POINTER_INT,
        .func_ptr = (void*)&lv_reallocf,
        .ret_type = "void *",
        .arg_types = { "void *", "size_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_refr_now",
        .invoke = &invoke_void_lv_display_t_p,
        .func_ptr = (void*)&lv_refr_now,
        .ret_type = "void",
        .arg_types = { "lv_display_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_roller_bind_value",
        .invoke = &invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p,
        .func_ptr = (void*)&lv_roller_bind_value,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_obj_t *", "lv_subject_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_roller_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_roller_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_roller_get_option_count",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_roller_get_option_count,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_roller_get_options",
        .invoke = &invoke_const_char_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_roller_get_options,
        .ret_type = "char *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_roller_get_selected",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_roller_get_selected,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_roller_get_selected_str",
        .invoke = &invoke_void_lv_obj_t_p_const_char_p_INT,
        .func_ptr = (void*)&lv_roller_get_selected_str,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "char *", "uint32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_roller_set_options",
        .invoke = &invoke_void_lv_obj_t_p_const_char_p_INT,
        .func_ptr = (void*)&lv_roller_set_options,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "char *", "lv_roller_mode_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_roller_set_selected",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_roller_set_selected,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "lv_anim_enable_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_roller_set_selected_str",
        .invoke = &invoke_BOOL_lv_obj_t_p_const_char_p_INT,
        .func_ptr = (void*)&lv_roller_set_selected_str,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "char *", "lv_anim_enable_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_roller_set_visible_row_count",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_roller_set_visible_row_count,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_add_section",
        .invoke = &invoke_lv_scale_section_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_scale_add_section,
        .ret_type = "lv_scale_section_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_scale_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_get_angle_range",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_scale_get_angle_range,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_get_label_show",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_scale_get_label_show,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_get_major_tick_every",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_scale_get_major_tick_every,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_get_mode",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_scale_get_mode,
        .ret_type = "lv_scale_mode_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_get_range_max_value",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_scale_get_range_max_value,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_get_range_min_value",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_scale_get_range_min_value,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_get_rotation",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_scale_get_rotation,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_get_total_tick_count",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_scale_get_total_tick_count,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_section_set_range",
        .invoke = &invoke_void_lv_scale_section_t_p_INT_INT,
        .func_ptr = (void*)&lv_scale_section_set_range,
        .ret_type = "void",
        .arg_types = { "lv_scale_section_t *", "int32_t", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_section_set_style",
        .invoke = &invoke_void_lv_scale_section_t_p_INT_lv_style_t_p,
        .func_ptr = (void*)&lv_scale_section_set_style,
        .ret_type = "void",
        .arg_types = { "lv_scale_section_t *", "lv_part_t", "lv_style_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_set_angle_range",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_scale_set_angle_range,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_set_draw_ticks_on_top",
        .invoke = &invoke_void_lv_obj_t_p_BOOL,
        .func_ptr = (void*)&lv_scale_set_draw_ticks_on_top,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_set_image_needle_value",
        .invoke = &invoke_void_lv_obj_t_p_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_scale_set_image_needle_value,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_set_label_show",
        .invoke = &invoke_void_lv_obj_t_p_BOOL,
        .func_ptr = (void*)&lv_scale_set_label_show,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_set_line_needle_value",
        .invoke = &invoke_void_lv_obj_t_p_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_scale_set_line_needle_value,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_obj_t *", "int32_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_set_major_tick_every",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_scale_set_major_tick_every,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_set_mode",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_scale_set_mode,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_scale_mode_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_set_post_draw",
        .invoke = &invoke_void_lv_obj_t_p_BOOL,
        .func_ptr = (void*)&lv_scale_set_post_draw,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_set_range",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_scale_set_range,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_set_rotation",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_scale_set_rotation,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_set_section_range",
        .invoke = &invoke_void_lv_obj_t_p_lv_scale_section_t_p_INT_INT,
        .func_ptr = (void*)&lv_scale_set_section_range,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_scale_section_t *", "int32_t", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_set_section_style_indicator",
        .invoke = &invoke_void_lv_obj_t_p_lv_scale_section_t_p_lv_style_t_p,
        .func_ptr = (void*)&lv_scale_set_section_style_indicator,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_scale_section_t *", "lv_style_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_set_section_style_items",
        .invoke = &invoke_void_lv_obj_t_p_lv_scale_section_t_p_lv_style_t_p,
        .func_ptr = (void*)&lv_scale_set_section_style_items,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_scale_section_t *", "lv_style_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_set_section_style_main",
        .invoke = &invoke_void_lv_obj_t_p_lv_scale_section_t_p_lv_style_t_p,
        .func_ptr = (void*)&lv_scale_set_section_style_main,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_scale_section_t *", "lv_style_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_scale_set_total_tick_count",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_scale_set_total_tick_count,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_screen_active",
        .invoke = &invoke_lv_obj_t_p,
        .func_ptr = (void*)&lv_screen_active,
        .ret_type = "lv_obj_t *",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_screen_load",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_screen_load,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_screen_load_anim",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT_INT_BOOL,
        .func_ptr = (void*)&lv_screen_load_anim,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_screen_load_anim_t", "uint32_t", "uint32_t", "bool", NULL, NULL, NULL }
    },
    {
        .name = "lv_slider_bind_value",
        .invoke = &invoke_lv_observer_t_p_lv_obj_t_p_lv_subject_t_p,
        .func_ptr = (void*)&lv_slider_bind_value,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_obj_t *", "lv_subject_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_slider_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_slider_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_slider_get_left_value",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_slider_get_left_value,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_slider_get_max_value",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_slider_get_max_value,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_slider_get_min_value",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_slider_get_min_value,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_slider_get_mode",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_slider_get_mode,
        .ret_type = "lv_slider_mode_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_slider_get_orientation",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_slider_get_orientation,
        .ret_type = "lv_slider_orientation_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_slider_get_value",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_slider_get_value,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_slider_is_dragged",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_slider_is_dragged,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_slider_is_symmetrical",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_slider_is_symmetrical,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_slider_set_mode",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_slider_set_mode,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_slider_mode_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_slider_set_orientation",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_slider_set_orientation,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_slider_orientation_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_slider_set_range",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_slider_set_range,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_slider_set_start_value",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_slider_set_start_value,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_anim_enable_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_slider_set_value",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_slider_set_value,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "lv_anim_enable_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_span_get_style",
        .invoke = &invoke_lv_style_t_p_lv_span_t_p,
        .func_ptr = (void*)&lv_span_get_style,
        .ret_type = "lv_style_t *",
        .arg_types = { "lv_span_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_span_get_text",
        .invoke = &invoke_const_char_p_lv_span_t_p,
        .func_ptr = (void*)&lv_span_get_text,
        .ret_type = "char *",
        .arg_types = { "lv_span_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_span_set_text",
        .invoke = &invoke_void_lv_span_t_p_const_char_p,
        .func_ptr = (void*)&lv_span_set_text,
        .ret_type = "void",
        .arg_types = { "lv_span_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_span_set_text_static",
        .invoke = &invoke_void_lv_span_t_p_const_char_p,
        .func_ptr = (void*)&lv_span_set_text_static,
        .ret_type = "void",
        .arg_types = { "lv_span_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_span_set_text_static",
        .invoke = &invoke_void_lv_span_t_p_const_char_p,
        .func_ptr = (void*)&lv_span_set_text_static,
        .ret_type = "void",
        .arg_types = { "lv_span_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_span_stack_deinit",
        .invoke = &invoke_void,
        .func_ptr = (void*)&lv_span_stack_deinit,
        .ret_type = "void",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_span_stack_init",
        .invoke = &invoke_void,
        .func_ptr = (void*)&lv_span_stack_init,
        .ret_type = "void",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_add_span",
        .invoke = &invoke_lv_span_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_spangroup_add_span,
        .ret_type = "lv_span_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_spangroup_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_delete_span",
        .invoke = &invoke_void_lv_obj_t_p_lv_span_t_p,
        .func_ptr = (void*)&lv_spangroup_delete_span,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_span_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_get_align",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_spangroup_get_align,
        .ret_type = "lv_text_align_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_get_child",
        .invoke = &invoke_lv_span_t_p_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_spangroup_get_child,
        .ret_type = "lv_span_t *",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_get_expand_height",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_spangroup_get_expand_height,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_get_expand_width",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_spangroup_get_expand_width,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_get_indent",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_spangroup_get_indent,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_get_max_line_height",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_spangroup_get_max_line_height,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_get_max_lines",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_spangroup_get_max_lines,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_get_mode",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_spangroup_get_mode,
        .ret_type = "lv_span_mode_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_get_overflow",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_spangroup_get_overflow,
        .ret_type = "lv_span_overflow_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_get_span_by_point",
        .invoke = &invoke_lv_span_t_p_lv_obj_t_p_lv_point_t_p,
        .func_ptr = (void*)&lv_spangroup_get_span_by_point,
        .ret_type = "lv_span_t *",
        .arg_types = { "lv_obj_t *", "lv_point_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_get_span_coords",
        .invoke = &invoke_INT_lv_obj_t_p_lv_span_t_p,
        .func_ptr = (void*)&lv_spangroup_get_span_coords,
        .ret_type = "lv_span_coords_t",
        .arg_types = { "lv_obj_t *", "lv_span_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_get_span_count",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_spangroup_get_span_count,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_refresh",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_spangroup_refresh,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_set_align",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_spangroup_set_align,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_text_align_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_set_indent",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_spangroup_set_indent,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_set_max_lines",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_spangroup_set_max_lines,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_set_mode",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_spangroup_set_mode,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_span_mode_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_set_overflow",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_spangroup_set_overflow,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_span_overflow_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_set_span_style",
        .invoke = &invoke_void_lv_obj_t_p_lv_span_t_p_lv_style_t_p,
        .func_ptr = (void*)&lv_spangroup_set_span_style,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_span_t *", "lv_style_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_set_span_text",
        .invoke = &invoke_void_lv_obj_t_p_lv_span_t_p_const_char_p,
        .func_ptr = (void*)&lv_spangroup_set_span_text,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_span_t *", "char *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spangroup_set_span_text_static",
        .invoke = &invoke_void_lv_obj_t_p_lv_span_t_p_const_char_p,
        .func_ptr = (void*)&lv_spangroup_set_span_text_static,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_span_t *", "char *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spinbox_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_spinbox_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spinbox_decrement",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_spinbox_decrement,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spinbox_get_rollover",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_spinbox_get_rollover,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spinbox_get_step",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_spinbox_get_step,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spinbox_get_value",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_spinbox_get_value,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spinbox_increment",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_spinbox_increment,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spinbox_set_cursor_pos",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_spinbox_set_cursor_pos,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spinbox_set_digit_format",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_spinbox_set_digit_format,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "uint32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spinbox_set_digit_step_direction",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_spinbox_set_digit_step_direction,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_dir_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spinbox_set_range",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_spinbox_set_range,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spinbox_set_rollover",
        .invoke = &invoke_void_lv_obj_t_p_BOOL,
        .func_ptr = (void*)&lv_spinbox_set_rollover,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spinbox_set_step",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_spinbox_set_step,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spinbox_set_value",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_spinbox_set_value,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spinbox_step_next",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_spinbox_step_next,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spinbox_step_prev",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_spinbox_step_prev,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spinner_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_spinner_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_spinner_set_anim_params",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_spinner_set_anim_params,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "uint32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_sqr",
        .invoke = &invoke_INT_INT,
        .func_ptr = (void*)&lv_sqr,
        .ret_type = "int32_t",
        .arg_types = { "int32_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_sqrt",
        .invoke = &invoke_void_INT_lv_sqrt_res_t_p_INT,
        .func_ptr = (void*)&lv_sqrt,
        .ret_type = "void",
        .arg_types = { "uint32_t", "lv_sqrt_res_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_sqrt32",
        .invoke = &invoke_INT_INT,
        .func_ptr = (void*)&lv_sqrt32,
        .ret_type = "int32_t",
        .arg_types = { "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_strcat",
        .invoke = &invoke_const_char_p_const_char_p_const_char_p,
        .func_ptr = (void*)&lv_strcat,
        .ret_type = "char *",
        .arg_types = { "char *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_strchr",
        .invoke = &invoke_const_char_p_const_char_p_INT,
        .func_ptr = (void*)&lv_strchr,
        .ret_type = "char *",
        .arg_types = { "char *", "int", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_strcmp",
        .invoke = &invoke_INT_const_char_p_const_char_p,
        .func_ptr = (void*)&lv_strcmp,
        .ret_type = "int",
        .arg_types = { "char *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_strcpy",
        .invoke = &invoke_const_char_p_const_char_p_const_char_p,
        .func_ptr = (void*)&lv_strcpy,
        .ret_type = "char *",
        .arg_types = { "char *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_strdup",
        .invoke = &invoke_const_char_p_const_char_p,
        .func_ptr = (void*)&lv_strdup,
        .ret_type = "char *",
        .arg_types = { "char *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_streq",
        .invoke = &invoke_BOOL_const_char_p_const_char_p,
        .func_ptr = (void*)&lv_streq,
        .ret_type = "bool",
        .arg_types = { "char *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_strlcpy",
        .invoke = &invoke_INT_const_char_p_const_char_p_INT,
        .func_ptr = (void*)&lv_strlcpy,
        .ret_type = "size_t",
        .arg_types = { "char *", "char *", "size_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_strlen",
        .invoke = &invoke_INT_const_char_p,
        .func_ptr = (void*)&lv_strlen,
        .ret_type = "size_t",
        .arg_types = { "char *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_strncat",
        .invoke = &invoke_const_char_p_const_char_p_const_char_p_INT,
        .func_ptr = (void*)&lv_strncat,
        .ret_type = "char *",
        .arg_types = { "char *", "char *", "size_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_strncmp",
        .invoke = &invoke_INT_const_char_p_const_char_p_INT,
        .func_ptr = (void*)&lv_strncmp,
        .ret_type = "int",
        .arg_types = { "char *", "char *", "size_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_strncpy",
        .invoke = &invoke_const_char_p_const_char_p_const_char_p_INT,
        .func_ptr = (void*)&lv_strncpy,
        .ret_type = "char *",
        .arg_types = { "char *", "char *", "size_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_strndup",
        .invoke = &invoke_const_char_p_const_char_p_INT,
        .func_ptr = (void*)&lv_strndup,
        .ret_type = "char *",
        .arg_types = { "char *", "size_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_strnlen",
        .invoke = &invoke_INT_const_char_p_INT,
        .func_ptr = (void*)&lv_strnlen,
        .ret_type = "size_t",
        .arg_types = { "char *", "size_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_copy",
        .invoke = &invoke_void_lv_style_t_p_lv_style_t_p,
        .func_ptr = (void*)&lv_style_copy,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_style_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_get_num_custom_props",
        .invoke = &invoke_INT,
        .func_ptr = (void*)&lv_style_get_num_custom_props,
        .ret_type = "lv_style_prop_t",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_get_prop",
        .invoke = &invoke_INT_lv_style_t_p_INT_lv_style_value_t_p,
        .func_ptr = (void*)&lv_style_get_prop,
        .ret_type = "lv_style_res_t",
        .arg_types = { "lv_style_t *", "lv_style_prop_t", "lv_style_value_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_get_prop_group",
        .invoke = &invoke_INT_INT,
        .func_ptr = (void*)&lv_style_get_prop_group,
        .ret_type = "uint32_t",
        .arg_types = { "lv_style_prop_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_get_prop_inlined",
        .invoke = &invoke_INT_lv_style_t_p_INT_lv_style_value_t_p,
        .func_ptr = (void*)&lv_style_get_prop_inlined,
        .ret_type = "lv_style_res_t",
        .arg_types = { "lv_style_t *", "lv_style_prop_t", "lv_style_value_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_init",
        .invoke = &invoke_void_lv_style_t_p,
        .func_ptr = (void*)&lv_style_init,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_is_const",
        .invoke = &invoke_BOOL_lv_style_t_p,
        .func_ptr = (void*)&lv_style_is_const,
        .ret_type = "bool",
        .arg_types = { "lv_style_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_is_empty",
        .invoke = &invoke_BOOL_lv_style_t_p,
        .func_ptr = (void*)&lv_style_is_empty,
        .ret_type = "bool",
        .arg_types = { "lv_style_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_prop_get_default",
        .invoke = &invoke_INT_INT,
        .func_ptr = (void*)&lv_style_prop_get_default,
        .ret_type = "lv_style_value_t",
        .arg_types = { "lv_style_prop_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_prop_has_flag",
        .invoke = &invoke_BOOL_INT_INT,
        .func_ptr = (void*)&lv_style_prop_has_flag,
        .ret_type = "bool",
        .arg_types = { "lv_style_prop_t", "uint8_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_prop_lookup_flags",
        .invoke = &invoke_INT_INT,
        .func_ptr = (void*)&lv_style_prop_lookup_flags,
        .ret_type = "uint8_t",
        .arg_types = { "lv_style_prop_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_register_prop",
        .invoke = &invoke_INT_INT,
        .func_ptr = (void*)&lv_style_register_prop,
        .ret_type = "lv_style_prop_t",
        .arg_types = { "uint8_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_remove_prop",
        .invoke = &invoke_BOOL_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_remove_prop,
        .ret_type = "bool",
        .arg_types = { "lv_style_t *", "lv_style_prop_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_reset",
        .invoke = &invoke_void_lv_style_t_p,
        .func_ptr = (void*)&lv_style_reset,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_align",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_align,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_align_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_anim",
        .invoke = &invoke_void_lv_style_t_p_lv_anim_t_p,
        .func_ptr = (void*)&lv_style_set_anim,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_anim_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_anim_duration",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_anim_duration,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_arc_color",
        .invoke = &invoke_void_lv_style_t_p_lv_color_t,
        .func_ptr = (void*)&lv_style_set_arc_color,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_arc_image_src",
        .invoke = &invoke_void_lv_style_t_p_POINTER,
        .func_ptr = (void*)&lv_style_set_arc_image_src,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_arc_opa",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_arc_opa,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_arc_rounded",
        .invoke = &invoke_void_lv_style_t_p_BOOL,
        .func_ptr = (void*)&lv_style_set_arc_rounded,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_arc_width",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_arc_width,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_base_dir",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_base_dir,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_base_dir_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_bg_color",
        .invoke = &invoke_void_lv_style_t_p_lv_color_t,
        .func_ptr = (void*)&lv_style_set_bg_color,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_bg_grad",
        .invoke = &invoke_void_lv_style_t_p_lv_grad_dsc_t_p,
        .func_ptr = (void*)&lv_style_set_bg_grad,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_grad_dsc_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_bg_grad_color",
        .invoke = &invoke_void_lv_style_t_p_lv_color_t,
        .func_ptr = (void*)&lv_style_set_bg_grad_color,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_bg_grad_dir",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_bg_grad_dir,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_grad_dir_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_bg_grad_opa",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_bg_grad_opa,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_bg_grad_stop",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_bg_grad_stop,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_bg_image_opa",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_bg_image_opa,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_bg_image_recolor",
        .invoke = &invoke_void_lv_style_t_p_lv_color_t,
        .func_ptr = (void*)&lv_style_set_bg_image_recolor,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_bg_image_recolor_opa",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_bg_image_recolor_opa,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_bg_image_src",
        .invoke = &invoke_void_lv_style_t_p_POINTER,
        .func_ptr = (void*)&lv_style_set_bg_image_src,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_bg_image_tiled",
        .invoke = &invoke_void_lv_style_t_p_BOOL,
        .func_ptr = (void*)&lv_style_set_bg_image_tiled,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_bg_main_opa",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_bg_main_opa,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_bg_main_stop",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_bg_main_stop,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_bg_opa",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_bg_opa,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_bitmap_mask_src",
        .invoke = &invoke_void_lv_style_t_p_POINTER,
        .func_ptr = (void*)&lv_style_set_bitmap_mask_src,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_blend_mode",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_blend_mode,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_blend_mode_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_border_color",
        .invoke = &invoke_void_lv_style_t_p_lv_color_t,
        .func_ptr = (void*)&lv_style_set_border_color,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_border_opa",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_border_opa,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_border_post",
        .invoke = &invoke_void_lv_style_t_p_BOOL,
        .func_ptr = (void*)&lv_style_set_border_post,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_border_side",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_border_side,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_border_side_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_border_width",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_border_width,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_clip_corner",
        .invoke = &invoke_void_lv_style_t_p_BOOL,
        .func_ptr = (void*)&lv_style_set_clip_corner,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_color_filter_dsc",
        .invoke = &invoke_void_lv_style_t_p_lv_color_filter_dsc_t_p,
        .func_ptr = (void*)&lv_style_set_color_filter_dsc,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_color_filter_dsc_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_color_filter_opa",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_color_filter_opa,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_flex_cross_place",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_flex_cross_place,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_flex_align_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_flex_flow",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_flex_flow,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_flex_flow_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_flex_grow",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_flex_grow,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "uint8_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_flex_main_place",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_flex_main_place,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_flex_align_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_flex_track_place",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_flex_track_place,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_flex_align_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_grid_cell_column_pos",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_grid_cell_column_pos,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_grid_cell_column_span",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_grid_cell_column_span,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_grid_cell_row_pos",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_grid_cell_row_pos,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_grid_cell_row_span",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_grid_cell_row_span,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_grid_cell_x_align",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_grid_cell_x_align,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_grid_align_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_grid_cell_y_align",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_grid_cell_y_align,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_grid_align_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_grid_column_align",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_grid_column_align,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_grid_align_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_grid_column_dsc_array",
        .invoke = &invoke_void_lv_style_t_p_POINTER,
        .func_ptr = (void*)&lv_style_set_grid_column_dsc_array,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_grid_row_align",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_grid_row_align,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_grid_align_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_grid_row_dsc_array",
        .invoke = &invoke_void_lv_style_t_p_POINTER,
        .func_ptr = (void*)&lv_style_set_grid_row_dsc_array,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_height",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_height,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_image_opa",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_image_opa,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_image_recolor",
        .invoke = &invoke_void_lv_style_t_p_lv_color_t,
        .func_ptr = (void*)&lv_style_set_image_recolor,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_image_recolor_opa",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_image_recolor_opa,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_layout",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_layout,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "uint16_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_length",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_length,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_line_color",
        .invoke = &invoke_void_lv_style_t_p_lv_color_t,
        .func_ptr = (void*)&lv_style_set_line_color,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_line_dash_gap",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_line_dash_gap,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_line_dash_width",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_line_dash_width,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_line_opa",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_line_opa,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_line_rounded",
        .invoke = &invoke_void_lv_style_t_p_BOOL,
        .func_ptr = (void*)&lv_style_set_line_rounded,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_line_width",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_line_width,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_margin_all",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_margin_all,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_margin_bottom",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_margin_bottom,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_margin_hor",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_margin_hor,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_margin_left",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_margin_left,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_margin_right",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_margin_right,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_margin_top",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_margin_top,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_margin_ver",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_margin_ver,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_max_height",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_max_height,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_max_width",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_max_width,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_min_height",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_min_height,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_min_width",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_min_width,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_opa",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_opa,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_opa_layered",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_opa_layered,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_outline_color",
        .invoke = &invoke_void_lv_style_t_p_lv_color_t,
        .func_ptr = (void*)&lv_style_set_outline_color,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_outline_opa",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_outline_opa,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_outline_pad",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_outline_pad,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_outline_width",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_outline_width,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_pad_all",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_pad_all,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_pad_bottom",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_pad_bottom,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_pad_column",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_pad_column,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_pad_gap",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_pad_gap,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_pad_hor",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_pad_hor,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_pad_left",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_pad_left,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_pad_radial",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_pad_radial,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_pad_right",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_pad_right,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_pad_row",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_pad_row,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_pad_top",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_pad_top,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_pad_ver",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_pad_ver,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_prop",
        .invoke = &invoke_void_lv_style_t_p_INT_INT,
        .func_ptr = (void*)&lv_style_set_prop,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_style_prop_t", "lv_style_value_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_radial_offset",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_radial_offset,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_radius",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_radius,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_recolor",
        .invoke = &invoke_void_lv_style_t_p_lv_color_t,
        .func_ptr = (void*)&lv_style_set_recolor,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_recolor_opa",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_recolor_opa,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_rotary_sensitivity",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_rotary_sensitivity,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_shadow_color",
        .invoke = &invoke_void_lv_style_t_p_lv_color_t,
        .func_ptr = (void*)&lv_style_set_shadow_color,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_shadow_offset_x",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_shadow_offset_x,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_shadow_offset_y",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_shadow_offset_y,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_shadow_opa",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_shadow_opa,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_shadow_spread",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_shadow_spread,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_shadow_width",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_shadow_width,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_size",
        .invoke = &invoke_void_lv_style_t_p_INT_INT,
        .func_ptr = (void*)&lv_style_set_size,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_text_align",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_text_align,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_text_align_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_text_color",
        .invoke = &invoke_void_lv_style_t_p_lv_color_t,
        .func_ptr = (void*)&lv_style_set_text_color,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_text_decor",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_text_decor,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_text_decor_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_text_font",
        .invoke = &invoke_void_lv_style_t_p_lv_font_t_p,
        .func_ptr = (void*)&lv_style_set_text_font,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_font_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_text_letter_space",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_text_letter_space,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_text_line_space",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_text_line_space,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_text_opa",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_text_opa,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_text_outline_stroke_color",
        .invoke = &invoke_void_lv_style_t_p_lv_color_t,
        .func_ptr = (void*)&lv_style_set_text_outline_stroke_color,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_text_outline_stroke_opa",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_text_outline_stroke_opa,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_opa_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_text_outline_stroke_width",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_text_outline_stroke_width,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_transform_height",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_transform_height,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_transform_pivot_x",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_transform_pivot_x,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_transform_pivot_y",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_transform_pivot_y,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_transform_rotation",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_transform_rotation,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_transform_scale",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_transform_scale,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_transform_scale_x",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_transform_scale_x,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_transform_scale_y",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_transform_scale_y,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_transform_skew_x",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_transform_skew_x,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_transform_skew_y",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_transform_skew_y,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_transform_width",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_transform_width,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_transition",
        .invoke = &invoke_void_lv_style_t_p_lv_style_transition_dsc_t_p,
        .func_ptr = (void*)&lv_style_set_transition,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "lv_style_transition_dsc_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_translate_radial",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_translate_radial,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_translate_x",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_translate_x,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_translate_y",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_translate_y,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_width",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_width,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_x",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_x,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_set_y",
        .invoke = &invoke_void_lv_style_t_p_INT,
        .func_ptr = (void*)&lv_style_set_y,
        .ret_type = "void",
        .arg_types = { "lv_style_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_style_transition_dsc_init",
        .invoke = &invoke_void_lv_style_transition_dsc_t_p_lv_style_prop_t_p_INT_INT_INT_POINTER,
        .func_ptr = (void*)&lv_style_transition_dsc_init,
        .ret_type = "void",
        .arg_types = { "lv_style_transition_dsc_t *", "lv_style_prop_t *", "lv_anim_path_cb_t", "uint32_t", "uint32_t", "void *", NULL, NULL }
    },
    {
        .name = "lv_subject_add_observer",
        .invoke = &invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER,
        .func_ptr = (void*)&lv_subject_add_observer,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_subject_t *", "lv_observer_cb_t", "void *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_add_observer_obj",
        .invoke = &invoke_lv_observer_t_p_lv_subject_t_p_INT_lv_obj_t_p_POINTER,
        .func_ptr = (void*)&lv_subject_add_observer_obj,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_subject_t *", "lv_observer_cb_t", "lv_obj_t *", "void *", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_add_observer_with_target",
        .invoke = &invoke_lv_observer_t_p_lv_subject_t_p_INT_POINTER_POINTER,
        .func_ptr = (void*)&lv_subject_add_observer_with_target,
        .ret_type = "lv_observer_t *",
        .arg_types = { "lv_subject_t *", "lv_observer_cb_t", "void *", "void *", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_copy_string",
        .invoke = &invoke_void_lv_subject_t_p_const_char_p,
        .func_ptr = (void*)&lv_subject_copy_string,
        .ret_type = "void",
        .arg_types = { "lv_subject_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_deinit",
        .invoke = &invoke_void_lv_subject_t_p,
        .func_ptr = (void*)&lv_subject_deinit,
        .ret_type = "void",
        .arg_types = { "lv_subject_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_get_color",
        .invoke = &invoke_lv_color_t_lv_subject_t_p,
        .func_ptr = (void*)&lv_subject_get_color,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_subject_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_get_group_element",
        .invoke = &invoke_lv_subject_t_p_lv_subject_t_p_INT,
        .func_ptr = (void*)&lv_subject_get_group_element,
        .ret_type = "lv_subject_t *",
        .arg_types = { "lv_subject_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_get_int",
        .invoke = &invoke_INT_lv_subject_t_p,
        .func_ptr = (void*)&lv_subject_get_int,
        .ret_type = "int32_t",
        .arg_types = { "lv_subject_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_get_pointer",
        .invoke = &invoke_POINTER_lv_subject_t_p,
        .func_ptr = (void*)&lv_subject_get_pointer,
        .ret_type = "void *",
        .arg_types = { "lv_subject_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_get_previous_color",
        .invoke = &invoke_lv_color_t_lv_subject_t_p,
        .func_ptr = (void*)&lv_subject_get_previous_color,
        .ret_type = "lv_color_t",
        .arg_types = { "lv_subject_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_get_previous_int",
        .invoke = &invoke_INT_lv_subject_t_p,
        .func_ptr = (void*)&lv_subject_get_previous_int,
        .ret_type = "int32_t",
        .arg_types = { "lv_subject_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_get_previous_pointer",
        .invoke = &invoke_POINTER_lv_subject_t_p,
        .func_ptr = (void*)&lv_subject_get_previous_pointer,
        .ret_type = "void *",
        .arg_types = { "lv_subject_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_get_previous_string",
        .invoke = &invoke_const_char_p_lv_subject_t_p,
        .func_ptr = (void*)&lv_subject_get_previous_string,
        .ret_type = "char *",
        .arg_types = { "lv_subject_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_get_string",
        .invoke = &invoke_const_char_p_lv_subject_t_p,
        .func_ptr = (void*)&lv_subject_get_string,
        .ret_type = "char *",
        .arg_types = { "lv_subject_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_init_color",
        .invoke = &invoke_void_lv_subject_t_p_lv_color_t,
        .func_ptr = (void*)&lv_subject_init_color,
        .ret_type = "void",
        .arg_types = { "lv_subject_t *", "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_init_int",
        .invoke = &invoke_void_lv_subject_t_p_INT,
        .func_ptr = (void*)&lv_subject_init_int,
        .ret_type = "void",
        .arg_types = { "lv_subject_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_init_pointer",
        .invoke = &invoke_void_lv_subject_t_p_POINTER,
        .func_ptr = (void*)&lv_subject_init_pointer,
        .ret_type = "void",
        .arg_types = { "lv_subject_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_init_string",
        .invoke = &invoke_void_lv_subject_t_p_const_char_p_const_char_p_INT_const_char_p,
        .func_ptr = (void*)&lv_subject_init_string,
        .ret_type = "void",
        .arg_types = { "lv_subject_t *", "char *", "char *", "size_t", "char *", NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_notify",
        .invoke = &invoke_void_lv_subject_t_p,
        .func_ptr = (void*)&lv_subject_notify,
        .ret_type = "void",
        .arg_types = { "lv_subject_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_set_color",
        .invoke = &invoke_void_lv_subject_t_p_lv_color_t,
        .func_ptr = (void*)&lv_subject_set_color,
        .ret_type = "void",
        .arg_types = { "lv_subject_t *", "lv_color_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_set_int",
        .invoke = &invoke_void_lv_subject_t_p_INT,
        .func_ptr = (void*)&lv_subject_set_int,
        .ret_type = "void",
        .arg_types = { "lv_subject_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_subject_set_pointer",
        .invoke = &invoke_void_lv_subject_t_p_POINTER,
        .func_ptr = (void*)&lv_subject_set_pointer,
        .ret_type = "void",
        .arg_types = { "lv_subject_t *", "void *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_switch_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_switch_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_switch_get_orientation",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_switch_get_orientation,
        .ret_type = "lv_switch_orientation_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_switch_set_orientation",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_switch_set_orientation,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_switch_orientation_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_table_clear_cell_ctrl",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT_INT,
        .func_ptr = (void*)&lv_table_clear_cell_ctrl,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "uint32_t", "lv_table_cell_ctrl_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_table_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_table_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_table_get_cell_user_data",
        .invoke = &invoke_POINTER_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_table_get_cell_user_data,
        .ret_type = "void *",
        .arg_types = { "lv_obj_t *", "uint16_t", "uint16_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_table_get_cell_value",
        .invoke = &invoke_const_char_p_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_table_get_cell_value,
        .ret_type = "char *",
        .arg_types = { "lv_obj_t *", "uint32_t", "uint32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_table_get_column_count",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_table_get_column_count,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_table_get_column_width",
        .invoke = &invoke_INT_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_table_get_column_width,
        .ret_type = "int32_t",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_table_get_row_count",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_table_get_row_count,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_table_get_selected_cell",
        .invoke = &invoke_void_lv_obj_t_p_POINTER_POINTER,
        .func_ptr = (void*)&lv_table_get_selected_cell,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t *", "uint32_t *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_table_has_cell_ctrl",
        .invoke = &invoke_BOOL_lv_obj_t_p_INT_INT_INT,
        .func_ptr = (void*)&lv_table_has_cell_ctrl,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", "uint32_t", "uint32_t", "lv_table_cell_ctrl_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_table_set_cell_ctrl",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT_INT,
        .func_ptr = (void*)&lv_table_set_cell_ctrl,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "uint32_t", "lv_table_cell_ctrl_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_table_set_cell_user_data",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT_POINTER,
        .func_ptr = (void*)&lv_table_set_cell_user_data,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint16_t", "uint16_t", "void *", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_table_set_cell_value",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT_const_char_p,
        .func_ptr = (void*)&lv_table_set_cell_value,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "uint32_t", "char *", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_table_set_column_count",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_table_set_column_count,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_table_set_column_width",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_table_set_column_width,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_table_set_row_count",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_table_set_row_count,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_table_set_selected_cell",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_table_set_selected_cell,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint16_t", "uint16_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tabview_add_tab",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_tabview_add_tab,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tabview_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_tabview_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tabview_get_content",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_tabview_get_content,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tabview_get_tab_active",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_tabview_get_tab_active,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tabview_get_tab_bar",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_tabview_get_tab_bar,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tabview_get_tab_count",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_tabview_get_tab_count,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tabview_rename_tab",
        .invoke = &invoke_void_lv_obj_t_p_INT_const_char_p,
        .func_ptr = (void*)&lv_tabview_rename_tab,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "char *", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tabview_set_active",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT,
        .func_ptr = (void*)&lv_tabview_set_active,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "lv_anim_enable_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tabview_set_tab_bar_position",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_tabview_set_tab_bar_position,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_dir_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tabview_set_tab_bar_size",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_tabview_set_tab_bar_size,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_task_handler",
        .invoke = &invoke_INT,
        .func_ptr = (void*)&lv_task_handler,
        .ret_type = "uint32_t",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_text_get_size",
        .invoke = &invoke_void_lv_point_t_p_const_char_p_lv_font_t_p_INT_INT_INT_INT,
        .func_ptr = (void*)&lv_text_get_size,
        .ret_type = "void",
        .arg_types = { "lv_point_t *", "char *", "lv_font_t *", "int32_t", "int32_t", "int32_t", "lv_text_flag_t", NULL }
    },
    {
        .name = "lv_text_get_width",
        .invoke = &invoke_INT_const_char_p_INT_lv_font_t_p_INT,
        .func_ptr = (void*)&lv_text_get_width,
        .ret_type = "int32_t",
        .arg_types = { "char *", "uint32_t", "lv_font_t *", "int32_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_text_get_width_with_flags",
        .invoke = &invoke_INT_const_char_p_INT_lv_font_t_p_INT_INT,
        .func_ptr = (void*)&lv_text_get_width_with_flags,
        .ret_type = "int32_t",
        .arg_types = { "char *", "uint32_t", "lv_font_t *", "int32_t", "lv_text_flag_t", NULL, NULL, NULL }
    },
    {
        .name = "lv_text_is_cmd",
        .invoke = &invoke_BOOL_lv_text_cmd_state_t_p_INT,
        .func_ptr = (void*)&lv_text_is_cmd,
        .ret_type = "bool",
        .arg_types = { "lv_text_cmd_state_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_add_char",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_textarea_add_char,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_add_text",
        .invoke = &invoke_void_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_textarea_add_text,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_clear_selection",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_clear_selection,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_textarea_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_cursor_down",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_cursor_down,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_cursor_left",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_cursor_left,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_cursor_right",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_cursor_right,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_cursor_up",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_cursor_up,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_delete_char",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_delete_char,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_delete_char_forward",
        .invoke = &invoke_void_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_delete_char_forward,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_get_accepted_chars",
        .invoke = &invoke_const_char_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_get_accepted_chars,
        .ret_type = "char *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_get_current_char",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_get_current_char,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_get_cursor_click_pos",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_get_cursor_click_pos,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_get_cursor_pos",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_get_cursor_pos,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_get_label",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_get_label,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_get_max_length",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_get_max_length,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_get_one_line",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_get_one_line,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_get_password_bullet",
        .invoke = &invoke_const_char_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_get_password_bullet,
        .ret_type = "char *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_get_password_mode",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_get_password_mode,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_get_password_show_time",
        .invoke = &invoke_INT_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_get_password_show_time,
        .ret_type = "uint32_t",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_get_placeholder_text",
        .invoke = &invoke_const_char_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_get_placeholder_text,
        .ret_type = "char *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_get_text",
        .invoke = &invoke_const_char_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_get_text,
        .ret_type = "char *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_get_text_selection",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_get_text_selection,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_set_accepted_chars",
        .invoke = &invoke_void_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_textarea_set_accepted_chars,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_set_align",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_textarea_set_align,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_text_align_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_set_cursor_click_pos",
        .invoke = &invoke_void_lv_obj_t_p_BOOL,
        .func_ptr = (void*)&lv_textarea_set_cursor_click_pos,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_set_cursor_pos",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_textarea_set_cursor_pos,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "int32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_set_insert_replace",
        .invoke = &invoke_void_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_textarea_set_insert_replace,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_set_max_length",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_textarea_set_max_length,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_set_one_line",
        .invoke = &invoke_void_lv_obj_t_p_BOOL,
        .func_ptr = (void*)&lv_textarea_set_one_line,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_set_password_bullet",
        .invoke = &invoke_void_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_textarea_set_password_bullet,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_set_password_mode",
        .invoke = &invoke_void_lv_obj_t_p_BOOL,
        .func_ptr = (void*)&lv_textarea_set_password_mode,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_set_password_show_time",
        .invoke = &invoke_void_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_textarea_set_password_show_time,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_set_placeholder_text",
        .invoke = &invoke_void_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_textarea_set_placeholder_text,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_set_text",
        .invoke = &invoke_void_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_textarea_set_text,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_set_text_selection",
        .invoke = &invoke_void_lv_obj_t_p_BOOL,
        .func_ptr = (void*)&lv_textarea_set_text_selection,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "bool", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_textarea_text_is_selected",
        .invoke = &invoke_BOOL_lv_obj_t_p,
        .func_ptr = (void*)&lv_textarea_text_is_selected,
        .ret_type = "bool",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tick_elaps",
        .invoke = &invoke_INT_INT,
        .func_ptr = (void*)&lv_tick_elaps,
        .ret_type = "uint32_t",
        .arg_types = { "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tick_get",
        .invoke = &invoke_INT,
        .func_ptr = (void*)&lv_tick_get,
        .ret_type = "uint32_t",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tick_inc",
        .invoke = &invoke_void_INT,
        .func_ptr = (void*)&lv_tick_inc,
        .ret_type = "void",
        .arg_types = { "uint32_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tick_set_cb",
        .invoke = &invoke_void_INT,
        .func_ptr = (void*)&lv_tick_set_cb,
        .ret_type = "void",
        .arg_types = { "lv_tick_get_cb_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tileview_add_tile",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p_INT_INT_INT,
        .func_ptr = (void*)&lv_tileview_add_tile,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", "uint8_t", "uint8_t", "lv_dir_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tileview_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_tileview_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tileview_get_tile_active",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_tileview_get_tile_active,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tileview_set_tile",
        .invoke = &invoke_void_lv_obj_t_p_lv_obj_t_p_INT,
        .func_ptr = (void*)&lv_tileview_set_tile,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "lv_obj_t *", "lv_anim_enable_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tileview_set_tile_by_index",
        .invoke = &invoke_void_lv_obj_t_p_INT_INT_INT,
        .func_ptr = (void*)&lv_tileview_set_tile_by_index,
        .ret_type = "void",
        .arg_types = { "lv_obj_t *", "uint32_t", "uint32_t", "lv_anim_enable_t", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tree_node_create",
        .invoke = &invoke_lv_tree_node_t_p_lv_tree_class_t_p_lv_tree_node_t_p,
        .func_ptr = (void*)&lv_tree_node_create,
        .ret_type = "lv_tree_node_t *",
        .arg_types = { "lv_tree_class_t *", "lv_tree_node_t *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tree_node_delete",
        .invoke = &invoke_void_lv_tree_node_t_p,
        .func_ptr = (void*)&lv_tree_node_delete,
        .ret_type = "void",
        .arg_types = { "lv_tree_node_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_tree_walk",
        .invoke = &invoke_BOOL_lv_tree_node_t_p_INT_INT_INT_INT_POINTER,
        .func_ptr = (void*)&lv_tree_walk,
        .ret_type = "bool",
        .arg_types = { "lv_tree_node_t *", "lv_tree_walk_mode_t", "lv_tree_traverse_cb_t", "lv_tree_before_cb_t", "lv_tree_after_cb_t", "void *", NULL, NULL }
    },
    {
        .name = "lv_trigo_cos",
        .invoke = &invoke_INT_INT,
        .func_ptr = (void*)&lv_trigo_cos,
        .ret_type = "int32_t",
        .arg_types = { "int16_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_trigo_sin",
        .invoke = &invoke_INT_INT,
        .func_ptr = (void*)&lv_trigo_sin,
        .ret_type = "int32_t",
        .arg_types = { "int16_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_utils_bsearch",
        .invoke = &invoke_POINTER_POINTER_POINTER_INT_INT_INT,
        .func_ptr = (void*)&lv_utils_bsearch,
        .ret_type = "void *",
        .arg_types = { "void *", "void *", "size_t", "size_t", "int", NULL, NULL, NULL }
    },
    {
        .name = "lv_version_info",
        .invoke = &invoke_const_char_p,
        .func_ptr = (void*)&lv_version_info,
        .ret_type = "char *",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_version_major",
        .invoke = &invoke_INT,
        .func_ptr = (void*)&lv_version_major,
        .ret_type = "int",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_version_minor",
        .invoke = &invoke_INT,
        .func_ptr = (void*)&lv_version_minor,
        .ret_type = "int",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_version_patch",
        .invoke = &invoke_INT,
        .func_ptr = (void*)&lv_version_patch,
        .ret_type = "int",
        .arg_types = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_vsnprintf",
        .invoke = &invoke_INT_const_char_p_INT_const_char_p_UNKNOWN,
        .func_ptr = (void*)&lv_vsnprintf,
        .ret_type = "int",
        .arg_types = { "char *", "size_t", "char *", "va_list", NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_win_add_button",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p_POINTER_INT,
        .func_ptr = (void*)&lv_win_add_button,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", "void *", "int32_t", NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_win_add_title",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p_const_char_p,
        .func_ptr = (void*)&lv_win_add_title,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", "char *", NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_win_create",
        .invoke = &invoke_widget_create,
        .func_ptr = (void*)&lv_win_create,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_win_get_content",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_win_get_content,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_win_get_header",
        .invoke = &invoke_lv_obj_t_p_lv_obj_t_p,
        .func_ptr = (void*)&lv_win_get_header,
        .ret_type = "lv_obj_t *",
        .arg_types = { "lv_obj_t *", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {
        .name = "lv_zalloc",
        .invoke = &invoke_POINTER_INT,
        .func_ptr = (void*)&lv_zalloc,
        .ret_type = "void *",
        .arg_types = { "size_t", NULL, NULL, NULL, NULL, NULL, NULL, NULL }
    },
    {NULL, NULL, NULL, NULL, {NULL}} // Sentinel
};

#define INVOKE_TABLE_SIZE 1295



// --- Function Lookup Implementation ---
// --- Function Lookup ---

// Finds an entry in the invocation table by function name.
static const invoke_table_entry_t* find_invoke_entry(const char *name) {
    if (!name) return NULL;
    for (int i = 0; g_invoke_table[i].name != NULL; ++i) {
        // Direct string comparison
        if (strcmp(g_invoke_table[i].name, name) == 0) {
            return &g_invoke_table[i];
        }
    }
    return NULL;
}



// --- Main Value Unmarshaler Implementation ---
// --- Main Value Unmarshaler ---

// Forward declarations for specific type unmarshalers
static const invoke_table_entry_t* find_invoke_entry(const char *name);
static bool unmarshal_enum_value(cJSON *json_value, const char *enum_type_name, int *dest);
static bool unmarshal_color(cJSON *node, lv_color_t *dest);
static bool unmarshal_coord(cJSON *node, lv_coord_t *dest);
static bool unmarshal_registered_ptr(cJSON *node, const char* expected_ptr_type, void **dest);
static bool unmarshal_int(cJSON *node, int *dest);
static bool unmarshal_int8(cJSON *node, int8_t *dest);
static bool unmarshal_uint8(cJSON *node, uint8_t *dest);
static bool unmarshal_int16(cJSON *node, int16_t *dest);
static bool unmarshal_uint16(cJSON *node, uint16_t *dest);
static bool unmarshal_int32(cJSON *node, int32_t *dest);
static bool unmarshal_uint32(cJSON *node, uint32_t *dest);
static bool unmarshal_int64(cJSON *node, int64_t *dest);
static bool unmarshal_uint64(cJSON *node, uint64_t *dest);
static bool unmarshal_size_t(cJSON *node, size_t *dest);
static bool unmarshal_opa(cJSON *node, lv_opa_t *dest);
static bool unmarshal_float(cJSON *node, float *dest);
static bool unmarshal_double(cJSON *node, double *dest);
static bool unmarshal_bool(cJSON *node, bool *dest);
static bool unmarshal_string_ptr(cJSON *node, const char **dest);
static bool unmarshal_char(cJSON *node, char *dest);

// The core dispatcher for unmarshaling any value from JSON based on expected C type.
static bool unmarshal_value(cJSON *json_value, const char *expected_c_type, void *dest) {
    if (!json_value || !expected_c_type || !dest) {
        LOG_ERR("Unmarshal Error: NULL argument passed to unmarshal_value (%p, %s, %p)", json_value, expected_c_type ? expected_c_type : "NULL", dest);
        return false;
     }

    // 1. Handle nested function calls { "call": "func_name", "args": [...] }
    if (cJSON_IsObject(json_value)) {
        cJSON *call_item = cJSON_GetObjectItemCaseSensitive(json_value, "call");
        cJSON *args_item = cJSON_GetObjectItemCaseSensitive(json_value, "args");
        if (call_item && cJSON_IsString(call_item) && args_item && cJSON_IsArray(args_item)) {
            const char *func_name = call_item->valuestring;
            const invoke_table_entry_t* entry = find_invoke_entry(func_name);
            if (!entry) {
                LOG_ERR_JSON(json_value, "Unmarshal Error: Nested call function '%s' not found in invoke table.", func_name);
                return false;
            }
            // Make the nested call. Result goes into 'dest'. target_obj_ptr is NULL.
            if (!entry->invoke(entry, NULL, dest, args_item)) {
                 LOG_ERR_JSON(json_value, "Unmarshal Error: Nested call to '%s' failed.", func_name);
                 return false;
            }
            return true; // Nested call successful
        }
        // If it's an object but not a 'call' object, it's an error unless expecting a specific struct type?
        // Currently, we don't handle passing structs directly via JSON objects other than 'call'.
    }

    // 2. Handle custom pre- and post-fixes in strings ('#', '@', '%')
    // Also handle non-prefixed strings that might be enums or regular strings.
    if (cJSON_IsString(json_value) && json_value->valuestring) {
        char *str_val = json_value->valuestring;
        size_t len = strlen(str_val);
        // Check for '#' color prefix
        if (len) {
            if (len > 2 && str_val[len - 1] == '%') {
               if (str_val[len - 2] != '%') {
                 if (strcmp(expected_c_type, "lv_coord_t") == 0 || strcmp(expected_c_type, "int32_t") == 0) {
                     return unmarshal_coord(json_value, (lv_coord_t *)dest);
                 } else {
                     LOG_ERR_JSON(json_value, "Unmarshal Error: Found percent string '%s' but expected type '%s'", str_val, expected_c_type);
                     //return false;
                 }
               } else {
                 str_val[--len] = '\0';
               }
            }
            if (str_val[0] == '#') {
               if (strcmp(expected_c_type, "lv_color_t") == 0) {
                   return unmarshal_color(json_value, (lv_color_t*)dest);
               } else {
                   LOG_ERR_JSON(json_value, "Unmarshal Error: Found color string '%s' but expected type '%s'", str_val, expected_c_type);
                   //return false;
               }
            }
            // Check for '@' pointer prefix
            if (str_val[0] == '@') {
               // Ensure expected type is some kind of pointer or a special component type
               if (strchr(expected_c_type, '*') || strcmp(expected_c_type, "component_json_node") == 0) {
                    return unmarshal_registered_ptr(json_value, expected_c_type, (void**)dest);
               } else {
                   LOG_ERR_JSON(json_value, "Unmarshal Error: Found registered pointer string '%s' but expected non-pointer type '%s'", str_val, expected_c_type);
                   //return false;
               }
            }
        }
        // If no prefix, it could be an enum name or a regular string.
        // Try enum first if the type looks like an LVGL type/typedef
        // Heuristic: Check if expected_c_type looks like an enum name (e.g. lv_align_t, LV_...)
        // We need a reliable way to know if expected_c_type IS an enum.
        // For now, let's try enum unmarshal if it looks like lv_..._t or LV_..._T
        bool maybe_enum = (strncmp(expected_c_type, "lv_", 3) == 0 && strstr(expected_c_type, "_t")) || 
                          (strncmp(expected_c_type, "LV_", 3) == 0 && strstr(expected_c_type, "_T")) || 
                          (strncmp(expected_c_type, "int", 3) == 0) || (strncmp(expected_c_type, "uint", 4) == 0);
        if (maybe_enum && strcmp(expected_c_type, "lv_obj_t") != 0 && strcmp(expected_c_type, "lv_style_t") != 0 /* add other known non-enums */) {
            if (unmarshal_enum_value(json_value, expected_c_type, (int*)dest)) {
                 return true; // Successfully parsed as enum string
            }
            // If unmarshal_enum_value failed, it logged the error. Fall through?
            // Maybe don't fall through, enum name was expected but invalid.
            LOG_WARN_JSON(json_value, "Enum parse failed for '%s' as type %s, falling back to string?", str_val, expected_c_type);
            // return false; // Strict: If it looked like an enum, it must parse as one.
        }

        // Finally, try as a regular string pointer if expected type is `const char *`
        if (strcmp(expected_c_type, "const char *") == 0 || strcmp(expected_c_type, "char *") == 0) {
             return unmarshal_string_ptr(json_value, (const char **)dest);
        }
        // If it's a string but none of the above matched, it's an error.
        // Except if expecting lv_coord_t, handled below.
        if (strcmp(expected_c_type, "lv_coord_t") != 0) { // Don't error here for coord % strings
           LOG_ERR_JSON(json_value, "Unmarshal Error: Got string '%s' but couldn't interpret as color, ptr, enum, or expected string type '%s'", str_val, expected_c_type);
           return false;
        }
    }

    // 3. Dispatch based on explicitly known C types
    if (strcmp(expected_c_type, "lv_coord_t") == 0) {
        return unmarshal_coord(json_value, (lv_coord_t*)dest);
    }
    else if (strcmp(expected_c_type, "lv_color_t") == 0) {
        return unmarshal_color(json_value, (lv_color_t*)dest);
    }
    else if (strcmp(expected_c_type, "int") == 0) {
        return unmarshal_int(json_value, (int*)dest);
    }
    else if (strcmp(expected_c_type, "int8_t") == 0) {
        return unmarshal_int8(json_value, (int8_t*)dest);
    }
    else if (strcmp(expected_c_type, "uint8_t") == 0) {
        return unmarshal_uint8(json_value, (uint8_t*)dest);
    }
    else if (strcmp(expected_c_type, "int16_t") == 0) {
        return unmarshal_int16(json_value, (int16_t*)dest);
    }
    else if (strcmp(expected_c_type, "uint16_t") == 0) {
        return unmarshal_uint16(json_value, (uint16_t*)dest);
    }
    else if (strcmp(expected_c_type, "int32_t") == 0) {
        return unmarshal_int32(json_value, (int32_t*)dest);
    }
    else if (strcmp(expected_c_type, "uint32_t") == 0) {
        return unmarshal_uint32(json_value, (uint32_t*)dest);
    }
    else if (strcmp(expected_c_type, "int64_t") == 0) {
        return unmarshal_int64(json_value, (int64_t*)dest);
    }
    else if (strcmp(expected_c_type, "uint64_t") == 0) {
        return unmarshal_uint64(json_value, (uint64_t*)dest);
    }
    else if (strcmp(expected_c_type, "size_t") == 0) {
        return unmarshal_size_t(json_value, (size_t*)dest);
    }
    else if (strcmp(expected_c_type, "lv_opa_t") == 0) {
        return unmarshal_uint8(json_value, (lv_opa_t*)dest);
    }
    else if (strcmp(expected_c_type, "float") == 0) {
        return unmarshal_float(json_value, (float*)dest);
    }
    else if (strcmp(expected_c_type, "double") == 0) {
        return unmarshal_double(json_value, (double*)dest);
    }
    else if (strcmp(expected_c_type, "bool") == 0) {
        return unmarshal_bool(json_value, (bool*)dest);
    }
    else if (strcmp(expected_c_type, "_Bool") == 0) {
        return unmarshal_bool(json_value, (_Bool*)dest);
    }
    else if (strcmp(expected_c_type, "char") == 0) {
        return unmarshal_char(json_value, (char*)dest);
    }
    else {
        // We might reach here if:
        // - expected_c_type is an enum not caught by the heuristic string check above.
        // - expected_c_type is a pointer not using '@' syntax.
        // - expected_c_type is an unhandled struct/union/etc.
        // Let's try one last time to parse as an enum if it looks like one.
        bool maybe_enum = (strncmp(expected_c_type, "lv_", 3) == 0 && strstr(expected_c_type, "_t")) || 
                          (strncmp(expected_c_type, "LV_", 3) == 0 && strstr(expected_c_type, "_T"))  || strcmp(expected_c_type, "uint32_t") == 0;
        if (maybe_enum && strcmp(expected_c_type, "lv_obj_t") != 0 /* add others */) {
             if (unmarshal_enum_value(json_value, expected_c_type, (int*)dest)) return true;
        }

        LOG_ERR_JSON(json_value, "Unmarshal Error: Unhandled expected C type '%s' or invalid JSON value type (%d)", expected_c_type, json_value->type);
        return false;
    }
}



// --- Custom Managed Object Creators ---
// --- Custom Managed Object Creators ---

#ifndef LV_MALLOC
#include <stdlib.h>
#define LV_MALLOC malloc
#define LV_FREE free
#endif

extern void lvgl_json_register_ptr(const char *name, const char *type_name, void *ptr);
extern void lv_fs_drv_init(lv_fs_drv_t *);
extern void lv_layer_init(lv_layer_t *);
extern void lv_style_init(lv_style_t *);

// Creator for lv_fs_drv_t using lv_fs_drv_init
lv_fs_drv_t* lv_fs_drv_create_managed(const char *name) {
    if (!name) {
        LOG_ERR("lv_fs_drv_create_managed: Name cannot be NULL.");
        return NULL;
    }
    LOG_INFO("Creating managed lv_fs_drv_t with name '%s'", name);
    lv_fs_drv_t *new_obj = (lv_fs_drv_t*)LV_MALLOC(sizeof(lv_fs_drv_t));
    if (!new_obj) {
        LOG_ERR("lv_fs_drv_create_managed: Failed to allocate memory for lv_fs_drv_t.");
        return NULL;
    }
    lv_fs_drv_init(new_obj);
    lvgl_json_register_ptr(name, "lv_fs_drv_t", (void*)new_obj);
    return new_obj;
}

// Creator for lv_layer_t using lv_layer_init
lv_layer_t* lv_layer_create_managed(const char *name) {
    if (!name) {
        LOG_ERR("lv_layer_create_managed: Name cannot be NULL.");
        return NULL;
    }
    LOG_INFO("Creating managed lv_layer_t with name '%s'", name);
    lv_layer_t *new_obj = (lv_layer_t*)LV_MALLOC(sizeof(lv_layer_t));
    if (!new_obj) {
        LOG_ERR("lv_layer_create_managed: Failed to allocate memory for lv_layer_t.");
        return NULL;
    }
    lv_layer_init(new_obj);
    lvgl_json_register_ptr(name, "lv_layer_t", (void*)new_obj);
    return new_obj;
}

// Creator for lv_style_t using lv_style_init
lv_style_t* lv_style_create_managed(const char *name) {
    if (!name) {
        LOG_ERR("lv_style_create_managed: Name cannot be NULL.");
        return NULL;
    }
    LOG_INFO("Creating managed lv_style_t with name '%s'", name);
    lv_style_t *new_obj = (lv_style_t*)LV_MALLOC(sizeof(lv_style_t));
    if (!new_obj) {
        LOG_ERR("lv_style_create_managed: Failed to allocate memory for lv_style_t.");
        return NULL;
    }
    lv_style_init(new_obj);
    lvgl_json_register_ptr(name, "lv_style_t", (void*)new_obj);
    return new_obj;
}



// --- JSON UI Renderer Implementation ---
// --- JSON UI Renderer ---

#include <stdio.h> // For debug prints

// Forward declarations
static bool render_json_node(cJSON *node, lv_obj_t *parent);
static const invoke_table_entry_t* find_invoke_entry(const char *name);
static bool unmarshal_value(cJSON *json_value, const char *expected_c_type, void *dest);
extern void* lvgl_json_get_registered_ptr(const char *name, const char *expected_type_name);
extern void lvgl_json_register_ptr(const char *name, const char *type_name, void *ptr);
extern lv_fs_drv_t* lv_fs_drv_create_managed(const char *name);
extern lv_layer_t* lv_layer_create_managed(const char *name);
extern lv_style_t* lv_style_create_managed(const char *name);

static bool render_json_node(cJSON *node, lv_obj_t *parent) {
    if (!cJSON_IsObject(node)) {
        LOG_ERR("Render Error: Expected JSON object for UI node.");
        return false;
    }


    // --- Handle Component Definition and Usage ---
    cJSON *type_item_comp_check = cJSON_GetObjectItemCaseSensitive(node, "type");
    if (type_item_comp_check && cJSON_IsString(type_item_comp_check)) {
        const char *type_str_comp_check_val = type_item_comp_check->valuestring;

        if (strcmp(type_str_comp_check_val, "component") == 0) {
            cJSON *id_item_comp = cJSON_GetObjectItemCaseSensitive(node, "id");
            cJSON *root_item_comp = cJSON_GetObjectItemCaseSensitive(node, "root");
            if (id_item_comp && cJSON_IsString(id_item_comp) && id_item_comp->valuestring && id_item_comp->valuestring[0] == '@' &&
                root_item_comp && cJSON_IsObject(root_item_comp)) {
                
                const char *comp_id_str = id_item_comp->valuestring + 1; // Skip '@'
                cJSON *duplicated_root = cJSON_Duplicate(root_item_comp, true);
                if (duplicated_root) {
                    lvgl_json_register_ptr(comp_id_str, "component_json_node", (void*)duplicated_root);
                    // LOG_INFO("Registered component '%s'", comp_id_str); // Logged by register_ptr
                    return true; // Component definition processed
                } else {
                    LOG_ERR_JSON(node, "Component Error: Failed to duplicate root for component '%s'", comp_id_str);
                    return false;
                }
            } else {
                LOG_ERR_JSON(node, "Component Error: Invalid 'component' definition. Requires 'id' (string starting with '@') and 'root' (object).");
                return false;
            }
        } else if (strcmp(type_str_comp_check_val, "use-view") == 0) {
            cJSON *id_item_use_view = cJSON_GetObjectItemCaseSensitive(node, "id");
            if (id_item_use_view && cJSON_IsString(id_item_use_view) && id_item_use_view->valuestring && id_item_use_view->valuestring[0] == '@') {
                const char *view_id_str = id_item_use_view->valuestring + 1; // Skip '@'
                cJSON *component_root_node = (cJSON*)lvgl_json_get_registered_ptr(view_id_str, "component_json_node");

                if (component_root_node) {
                    LOG_INFO("Using view '%s'", view_id_str);
                    return render_json_node(component_root_node, parent); // Render the component's root
                } else {
                    // lvgl_json_get_registered_ptr logs warning if not found or type mismatch
                    LOG_WARN_JSON(node, "Use-View Error: Component '%s' not found or type error. Creating fallback label.", view_id_str);
                    lv_obj_t *fallback_label = lv_label_create(parent);
                    if(fallback_label) {
                        char fallback_text[128];
                        snprintf(fallback_text, sizeof(fallback_text), "Component '%s' not found/error", view_id_str);
                        lv_label_set_text(fallback_label, fallback_text);
                        lv_obj_align(fallback_label, LV_ALIGN_CENTER, 0, 0);
                    }
                    return true; // Fallback created (or attempted)
                }
            } else {
                LOG_ERR_JSON(node, "Use-View Error: Invalid 'use-view' definition. Requires 'id' (string starting with '@').");
                return false;
            }
        }
    }
    // --- End Component Handling ---

    // 1. Determine Object Type and ID
    cJSON *type_item = cJSON_GetObjectItemCaseSensitive(node, "type");
    const char *type_str = "obj"; // Default type
    if (type_item && cJSON_IsString(type_item)) {
        type_str = type_item->valuestring;
    }
    cJSON *id_item = cJSON_GetObjectItemCaseSensitive(node, "id");
    const char *id_str = NULL;
    if (id_item && cJSON_IsString(id_item)) {
        if (id_item->valuestring[0] == '@') {
           id_str = id_item->valuestring + 1; // Get name part after '@'
        } else {
           LOG_WARN("Render Warning: 'id' property '%s' should start with '@' for registration. Ignoring registration.", id_item->valuestring);
           id_str = NULL; // Don't register if format is wrong
        }
    }

    // 2. Create the LVGL Object / Resource
    void *created_entity = NULL; // Can be lv_obj_t* or lv_style_t* etc.
    bool is_widget = true; // Is it an lv_obj_t based widget?
    const char *type_str_for_create = type_str;

    if (strcmp(type_str, "grid") == 0) {
        type_str_for_create = "obj"; // A 'grid' is a generic obj with grid layout
        LOG_INFO("Encountered 'grid' type, will create as 'lv_obj' and apply grid layout.");
    }

    // Check for custom creators (e.g., for styles)
    if (strcmp(type_str, "fs_drv") == 0) {
        if (!id_str) {
            LOG_ERR("Render Error: Type 'fs_drv' requires an 'id' property starting with '@'.");
            return false;
        }
        // Call custom creator which handles allocation, init, and registration
        created_entity = (void*)lv_fs_drv_create_managed(id_str);
        if (!created_entity) return false; // Error logged in creator
        is_widget = false; // Mark as non-widget (doesn't take parent, no children)
    }
    else if (strcmp(type_str, "layer") == 0) {
        if (!id_str) {
            LOG_ERR("Render Error: Type 'layer' requires an 'id' property starting with '@'.");
            return false;
        }
        // Call custom creator which handles allocation, init, and registration
        created_entity = (void*)lv_layer_create_managed(id_str);
        if (!created_entity) return false; // Error logged in creator
        is_widget = false; // Mark as non-widget (doesn't take parent, no children)
    }
    else if (strcmp(type_str, "style") == 0) {
        if (!id_str) {
            LOG_ERR("Render Error: Type 'style' requires an 'id' property starting with '@'.");
            return false;
        }
        // Call custom creator which handles allocation, init, and registration
        created_entity = (void*)lv_style_create_managed(id_str);
        if (!created_entity) return false; // Error logged in creator
        is_widget = false; // Mark as non-widget (doesn't take parent, no children)
    }
    else {
        // Default: Assume it's a widget type (lv_obj_t based)
        char create_func_name[64];
        snprintf(create_func_name, sizeof(create_func_name), "lv_%s_create", type_str_for_create);
        const invoke_table_entry_t* create_entry = find_invoke_entry(create_func_name);
        if (!create_entry) {
            LOG_ERR_JSON(node, "Render Error: Create function '%s' not found.", create_func_name);
            return false;
        }

        // Prepare arguments for creator (just the parent obj)
        cJSON *create_args_json = cJSON_CreateArray();
        if (!create_args_json) { LOG_ERR("Memory error creating args for %s", create_func_name); return false; }

        // How to pass the parent lv_obj_t*? 
        // Option A: Register parent temporarily? Seems complex.
        // Option B: Modify invoke_fn_t signature? Chosen earlier to avoid.
        // Option C: Assume create functions take exactly one lv_obj_t* arg 
        //           and handle it specially here or in the invoke func?
        // Let's assume the invoker for lv_..._create(lv_obj_t*) handles this.
        // The generated invoker needs to know its first arg is lv_obj_t* and get it from `parent`.
        // -- RETHINK invoke_fn_t signature --
        // Let's assume invoke_fn_t takes target_obj_ptr which is the parent here.
        // We pass NULL for json args as lv_..._create only takes parent.
        lv_obj_t* new_widget = NULL;
        // We need the invoker to place the result into &new_widget.
        if (!create_entry->invoke(create_entry, (void*)parent, &new_widget, NULL)) { 
            LOG_ERR_JSON(node, "Render Error: Failed to invoke %s.", create_func_name);
            // cJSON_Delete(create_args_json); // Not needed if passing NULL
            return false;
        }
        // cJSON_Delete(create_args_json); // Not needed if passing NULL
        if (!new_widget) { LOG_ERR("Render Error: %s returned NULL.", create_func_name); return false; }
        created_entity = (void*)new_widget;
        is_widget = true;

        // Register if ID is provided and it wasn't a custom-created type
        if (id_str) {
            char entity_type_name_buf[64];
            // For widgets, type_str_for_create holds the base type like "obj", "label"
            // For custom created (e.g. styles), type_str holds "style"
            // We need to construct the C type name like "lv_label_t", "lv_style_t"
            const char* base_type_for_reg = is_widget ? type_str_for_create : type_str;
            snprintf(entity_type_name_buf, sizeof(entity_type_name_buf), "lv_%s_t", base_type_for_reg);
            lvgl_json_register_ptr(id_str, entity_type_name_buf, created_entity);
        }
    }


    // Special handling for "grid" type to set up column and row descriptors
    if (created_entity && is_widget && strcmp(type_str, "grid") == 0) { // type_str is original JSON type
        lv_obj_t* grid_obj = (lv_obj_t*)created_entity;
        cJSON *cols_item_json = cJSON_GetObjectItemCaseSensitive(node, "cols");
        cJSON *rows_item_json = cJSON_GetObjectItemCaseSensitive(node, "rows");

        int32_t* col_dsc_array = NULL;
        int32_t* row_dsc_array = NULL;
        bool grid_setup_ok = true;

        if (cols_item_json && cJSON_IsArray(cols_item_json)) {
            int num_cols = cJSON_GetArraySize(cols_item_json);
            col_dsc_array = (int32_t*)LV_MALLOC(sizeof(int32_t) * (num_cols + 1));
            if (col_dsc_array) {
                for (int i = 0; i < num_cols; i++) {
                    cJSON *val_item = cJSON_GetArrayItem(cols_item_json, i);
                    if (!unmarshal_value(val_item, "int32_t", &col_dsc_array[i])) { // Use unmarshal_value
                        LOG_ERR_JSON(val_item, "Grid Error: Failed to parse 'cols' array item %d as int32_t.", i);
                        LV_FREE(col_dsc_array); col_dsc_array = NULL; grid_setup_ok = false;
                        break;
                    }
                }
                if (col_dsc_array) col_dsc_array[num_cols] = LV_GRID_TEMPLATE_LAST;
            } else {
                LOG_ERR("Grid Error: Failed to allocate memory for column descriptors.");
                grid_setup_ok = false;
            }
        } else {
            LOG_ERR_JSON(node, "Grid Error: 'cols' array is missing or not an array for grid type.");
            grid_setup_ok = false;
        }

        // Only proceed with rows if cols were OK and rows_item_json is valid
        if (grid_setup_ok && rows_item_json && cJSON_IsArray(rows_item_json)) {
            int num_rows = cJSON_GetArraySize(rows_item_json);
            row_dsc_array = (int32_t*)LV_MALLOC(sizeof(int32_t) * (num_rows + 1));
            if (row_dsc_array) {
                for (int i = 0; i < num_rows; i++) {
                    cJSON *val_item = cJSON_GetArrayItem(rows_item_json, i);
                    if (!unmarshal_value(val_item, "int32_t", &row_dsc_array[i])) { // Use unmarshal_value
                        LOG_ERR_JSON(val_item, "Grid Error: Failed to parse 'rows' array item %d as int32_t.", i);
                        LV_FREE(row_dsc_array); row_dsc_array = NULL; grid_setup_ok = false;
                        break;
                    }
                }
                if (row_dsc_array) row_dsc_array[num_rows] = LV_GRID_TEMPLATE_LAST;
            } else {
                LOG_ERR("Grid Error: Failed to allocate memory for row descriptors.");
                grid_setup_ok = false;
            }
        } else if (grid_setup_ok) { // This implies rows_item_json was missing/invalid
             LOG_ERR_JSON(node, "Grid Error: 'rows' array is missing or not an array for grid type.");
             grid_setup_ok = false;
        }

        if (grid_setup_ok && col_dsc_array && row_dsc_array) {
            char temp_name_buf[64]; // For snprintf

            snprintf(temp_name_buf, sizeof(temp_name_buf), "grid_col_dsc_%p", (void*)grid_obj);
            lvgl_json_register_ptr(temp_name_buf, "lv_coord_array", (void*)col_dsc_array); // Registry will lv_strdup the name

            snprintf(temp_name_buf, sizeof(temp_name_buf), "grid_row_dsc_%p", (void*)grid_obj);
            lvgl_json_register_ptr(temp_name_buf, "lv_coord_array", (void*)row_dsc_array); // Registry will lv_strdup the name
            
            lv_obj_set_grid_dsc_array(grid_obj, col_dsc_array, row_dsc_array);
            // Note: Memory for col_dsc_array and row_dsc_array should ideally be freed on LV_EVENT_DELETE of grid_obj.
            // This is not added here to keep changes minimal as per request.
        } else {
            if (col_dsc_array) { LV_FREE(col_dsc_array); } // Free if allocated but not used
            if (row_dsc_array) { LV_FREE(row_dsc_array); } // Free if allocated but not used
            LOG_ERR_JSON(node, "Grid Error: Failed to set up complete grid descriptors. Grid layout will not apply.");
        }
    }
    // 3. Set Properties
    cJSON *prop = NULL;
    for (prop = node->child; prop != NULL; prop = prop->next) {
        const char *prop_name = prop->string;
        if (!prop_name) continue;
        // Skip known control properties OR grid-specific setup properties handled earlier
        if (strcmp(prop_name, "type") == 0 || strcmp(prop_name, "id") == 0 || strcmp(prop_name, "children") == 0 || 
            (strcmp(type_str, "grid") == 0 && (strcmp(prop_name, "cols") == 0 || strcmp(prop_name, "rows") == 0))) {
            continue;
        }
        // Property value must be an array of arguments
        cJSON *old_prop = NULL;
        if (!cJSON_IsArray(prop)) {
            old_prop = prop;
            prop = cJSON_CreateArray();
            cJSON_AddItemToArray(prop, cJSON_Duplicate(old_prop, true));
        }

        // Find the setter function: lv_<type>_set_<prop> or lv_obj_set_<prop>
        char setter_name[128];
        const invoke_table_entry_t* setter_entry = NULL;

        // Try specific type setter first (only if it's a widget)
        if (is_widget) {
           snprintf(setter_name, sizeof(setter_name), "lv_%s_set_%s", type_str, prop_name);
           setter_entry = find_invoke_entry(setter_name);
        }

        // Try generic lv_obj setter if specific not found or not applicable
        if (!setter_entry && is_widget) { // Only widgets have generic obj setters
            snprintf(setter_name, sizeof(setter_name), "lv_obj_set_%s", prop_name);
            setter_entry = find_invoke_entry(setter_name);
        }

        // Try generic lv_obj method if not found or not applicable
        if (!setter_entry && is_widget) { // Only widgets have generic obj setters
            snprintf(setter_name, sizeof(setter_name), "lv_obj_%s", prop_name);
            setter_entry = find_invoke_entry(setter_name);
        }

        // Try generic lv_obj style setter if specific not found or not applicable
        if (!setter_entry && is_widget) { // Only widgets have generic obj setters
            snprintf(setter_name, sizeof(setter_name), "lv_obj_set_style_%s", prop_name);
            setter_entry = find_invoke_entry(setter_name);
            if (setter_entry && cJSON_GetArraySize(prop) == 1) { cJSON_AddItemToArray(prop, cJSON_CreateNumber(0)); }
        }

        // Try style-setter (e.g., lv_style_set_...)
        if (!setter_entry) {
            snprintf(setter_name, sizeof(setter_name), "lv_style_set_%s", prop_name);
            setter_entry = find_invoke_entry(setter_name);
            //if (!setter_entry) { LOG_ERR_JSON(node, "no style setter for %s\n", setter_name); }
        }

        // Try style-method (e.g., lv_style_...)
        if (!setter_entry) {
            snprintf(setter_name, sizeof(setter_name), "lv_style_%s", prop_name);
            setter_entry = find_invoke_entry(setter_name);
            //if (!setter_entry) { LOG_ERR_JSON(node, "no style setter for %s\n", setter_name); }
        }

        if (!setter_entry) {
            LOG_ERR_JSON(node, "Render Warning: No setter function found for property '%s' on type '%s'. Searched lv_%s_set_..., lv_obj_set_..., lv_obj_set_style_....", prop_name, type_str, type_str);
            continue;
        }

        // Invoke the setter
        // Pass the created_entity as target_obj_ptr, NULL for dest (setters usually return void)
        // Pass the property's JSON array value as args_array
        if (!setter_entry->invoke(setter_entry, created_entity, NULL, prop)) {
             LOG_ERR_JSON(prop, "Render Error: Failed to set property '%s' using %s.", prop_name, setter_name);
             // Continue or return false? Let's continue for now.
        }
        if (old_prop) { cJSON_Delete(prop); prop = old_prop; } // Delete prop if we had to create it (old-prop is set)
    }

    // 4. Process Children (only for widgets)
    if (is_widget) {
        cJSON *children_item = cJSON_GetObjectItemCaseSensitive(node, "children");
        if (children_item) {
            if (!cJSON_IsArray(children_item)) {
                LOG_ERR("Render Error: 'children' property must be an array.");
                // Cleanup created widget?
                return false;
            }
            cJSON *child_node = NULL;
            cJSON_ArrayForEach(child_node, children_item) {
                 if (!render_json_node(child_node, (lv_obj_t*)created_entity)) {
                     // Error rendering child, stop processing siblings? Or continue?
                     LOG_ERR("Render Error: Failed to render child node. Aborting sibling processing for this parent.");
                     // Cleanup? Difficult to manage partial tree creation.
                     return false; // Propagate failure
                 }
            }
        }
    }
    return true;
}

// --- Public API --- 

/**
 * @brief Renders a UI described by a cJSON object.
 *
 * @param root_json The root cJSON object (should be an array of UI nodes or a single node object).
 * @param implicit_root_parent The LVGL parent object for top-level UI elements.
 * @return true on success, false on failure.
 */
bool lvgl_json_render_ui(cJSON *root_json, lv_obj_t *implicit_root_parent) {
    if (!root_json) {
        LOG_ERR("Render Error: root_json is NULL.");
        return false;
    }
    if (!implicit_root_parent) {
        LOG_WARN("Render Warning: implicit_root_parent is NULL. Using lv_screen_active().");
        implicit_root_parent = lv_screen_active();
        if (!implicit_root_parent) {
             LOG_ERR("Render Error: Cannot get active screen.");
             return false;
        }
    }

    // Clear registry before starting? Optional, depends on desired behavior.
    // lvgl_json_registry_clear();

    bool success = true;
    if (cJSON_IsArray(root_json)) {
        cJSON *node = NULL;
        cJSON_ArrayForEach(node, root_json) {
            if (!render_json_node(node, implicit_root_parent)) {
                success = false;
                LOG_ERR("Render Error: Failed to render top-level node. Aborting.");
                break; // Stop processing further nodes on failure
            }
        }
    } else if (cJSON_IsObject(root_json)) {
        success = render_json_node(root_json, implicit_root_parent);
    } else {
        LOG_ERR("Render Error: root_json must be a JSON object or array.");
        success = false;
    }

    if (!success) {
         LOG_ERR("UI Rendering failed.");
         // Potential cleanup logic here?
    } else {
         LOG_INFO("UI Rendering completed successfully.");
    }
    return success;
}



