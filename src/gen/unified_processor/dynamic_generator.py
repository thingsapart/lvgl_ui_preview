import json
import logging
from .base_processor import BaseUIProcessor
# from ..code_gen import invocation, registry, unmarshal # Will be refactored into this class

logger = logging.getLogger(__name__)

# Moved from generator.py
DEFAULT_MACRO_NAMES_TO_EXPORT = [
    "LV_SIZE_CONTENT",
    "LV_COORD_MAX",
    "LV_COORD_MIN",
    "LV_GRID_CONTENT",
    "LV_FLEX_CONTENT",
    "LV_CHART_POINT_NONE",
    "LV_RADIUS_CIRCLE",
    "LV_IMG_ZOOM_NONE",
    "LV_BTNMATRIX_BTN_ID_NONE",
    "LV_ANIM_REPEAT_INFINITE",
    "LV_ANIM_PLAYTIME_INFINITE",
    "LV_OPA_TRANSP", "LV_OPA_COVER",
    "LV_ALIGN_DEFAULT", "LV_ALIGN_CENTER", "LV_ALIGN_OUT_TOP_LEFT",
    "LV_STATE_DEFAULT", "LV_STATE_FOCUSED", "LV_STATE_ANY",
    "LV_PART_MAIN", "LV_PART_ANY",
    "LV_GRID_TEMPLATE_LAST", "LV_GRID_FR_1", "LV_GRID_FR_2", "LV_GRID_FR_3", "LV_GRID_FR_4",
    "LV_GRID_FR_5", "LV_GRID_FR_10"
]

class DynamicUIGenerator(BaseUIProcessor):
    DEFAULT_MACRO_NAMES_TO_EXPORT = DEFAULT_MACRO_NAMES_TO_EXPORT # Class attribute

    def __init__(self, api_info, lv_def_json_path, str_vals_json_path):
        super().__init__(api_info, lv_def_json_path, str_vals_json_path)
        self.var_counter = 0
        self.c_header_lines = []
        self.c_source_lines = []
        
        # More specific lists for better organization
        self.c_forward_declarations = [] # For function prototypes, extern var declarations
        self.c_global_vars = [] # For global variable definitions
        self.c_static_vars = [] # For file-scope static variables
        self.c_type_defs = [] # For struct/enum typedefs if any generated by this tool
        self.c_function_implementations = [] # For actual function bodies
        self.c_widget_declarations = [] # e.g. lv_obj_t *my_button;
        self.c_style_declarations = [] # e.g. lv_style_t my_style; (or pointers)
        self.c_setup_code = [] # Code that runs once, e.g., in a setup_ui() function

        # Mappings to store C variable names for IDs and named attributes
        self._id_to_c_var = {}
        self._named_attr_to_c_var = {}


    def _generate_unique_var_name(self, base="obj"):
        self.var_counter += 1
        return f"{base}{self.var_counter}"

    # --- Implementation of Abstract Methods ---

    def _resolve_value(self, json_value_node, expected_type_hint=None, current_context=None, target_entity_ref_for_pct=None):
        """
        Generates a C code *string* that, when executed/parsed by the C runtime, 
        will produce the desired value.
        This string is typically passed to a C function like unmarshal_value.
        """
        if isinstance(json_value_node, (int, float)):
            return str(json_value_node) # Numbers are direct C literals
        elif isinstance(json_value_node, bool):
            return "true" if json_value_node else "false" # C-style boolean
        elif isinstance(json_value_node, str):
            # Handle special prefixes
            if json_value_node.startswith("$"): # Variable lookup
                var_name = json_value_node[1:]
                # The C unmarshal_value will look for '$' prefix.
                return f'"${var_name}"' # Pass as a string "$var_name"
            elif json_value_node.startswith("@"): # Pointer/ID lookup
                ptr_name = json_value_node[1:]
                # The C unmarshal_value will look for '@' prefix.
                return f'"@{ptr_name}"' # Pass as a string "@ptr_name"
            elif json_value_node.startswith("#"): # Hex color
                hex_val = json_value_node[1:]
                # The C unmarshal_value will look for '#' prefix.
                return f'"#{hex_val}"' # Pass as a string "#hex_val"
            elif json_value_node.endswith("%") and json_value_node[:-1].isdigit(): # Percentage
                # The C unmarshal_value will handle "N%" strings.
                # If target_entity_ref_for_pct is needed, it must be passed separately to the C call.
                # This function only returns the value representation.
                return f'"{json_value_node}"'
            elif json_value_node.startswith("!"): # Explicit String literal
                str_val = json_value_node[1:]
                # The C unmarshal_value will look for '!' prefix.
                # Escape quotes within the string for C representation
                escaped_str_val = str_val.replace('"', '\\"')
                return f'"!{escaped_str_val}"' # Pass as string "!str_val"
            else: # Regular string literal
                # Escape quotes for C representation
                escaped_json_value_node = json_value_node.replace('"', '\\"')
                return f'"{escaped_json_value_node}"' # Standard string literal
        elif isinstance(json_value_node, dict):
            if "call" in json_value_node:
                # For nested calls, pass the JSON structure as a string.
                # The C unmarshal_value will parse this JSON string.
                # Ensure compact JSON string, no newlines, escape internal quotes.
                call_json_str = json.dumps(json_value_node, separators=(',', ':'))
                escaped_call_json_str = call_json_str.replace('"', '\\"')
                return f'"{escaped_call_json_str}"' # Pass the JSON string as a C string literal
            else:
                logger.warning(f"Cannot resolve complex dict value directly to C string: {json_value_node}")
                return '"NULL"' # Or some other error indicator
        elif json_value_node is None:
            return "NULL"
        else:
            logger.warning(f"Unsupported value type for _resolve_value: {type(json_value_node)}, value: {json_value_node}")
            return '"UNRESOLVED_VALUE"'

    def _handle_widget_creation(self, json_node, parent_c_var_name, context_at_creation):
        widget_type_json = json_node.get("type", "obj") # e.g. "button", "label", "grid"
        widget_id = json_node.get("id")

        # Determine LVGL type string (e.g. "lv_button", "lv_label")
        # This might need mapping if json_node["type"] isn't directly the LVGL object prefix
        lvgl_base_type = f"lv_{widget_type_json}" if widget_type_json != "obj" else "lv_obj"
        
        # Generate a unique C variable name for the widget
        c_var_name = self._generate_unique_var_name(base=widget_type_json)
        
        self.c_widget_declarations.append(f"lv_obj_t *{c_var_name};")

        # LVGL creation function name, e.g., "lv_button_create"
        # This relies on api_info to find the actual function.
        # For now, assume a convention or direct mapping.
        # Let's find the creator function from api_info.
        # This is a simplified lookup. Actual lookup would be more robust.
        creator_func_name = f"{lvgl_base_type}_create"
        
        # Find the function entry in api_info (this is a placeholder for actual lookup)
        # creator_func_entry = self.api_info.get_function(creator_func_name) # Pseudocode
        # For now, we'll construct the call string directly.
        # The C side will use the invocation table.
        # The string passed to C `invoke_function_by_name` would be creator_func_name.

        # Code to create the widget via the invocation system
        # Args for create: parent (obj), copy (NULL usually for create)
        # The C function `lvgl_json_invoke_function` will handle finding and calling.
        # It needs: func_name_str, parent_obj_str, out_widget_ptr_str, args_json_str
        parent_arg = parent_c_var_name if parent_c_var_name else "NULL"
        
        # For widget creation, the 'args' for lv_obj_create(parent) is just the parent.
        # If the json_node has specific 'constructor_args', they would be resolved here.
        # For now, assume standard create(parent)
        
        # The C side's `lvgl_json_invoke_function` will take the function name,
        # the parent object, a pointer to where the new object should be stored, and args.
        # For create functions like lv_obj_create(parent), there are no further 'args' in the JSON sense.
        # The parent is specially handled.
        self.c_setup_code.append(
            f"lvgl_json_invoke_function(\"{creator_func_name}\", {parent_arg}, &{c_var_name}, NULL);"
        )
        
        logger.info(f"Generated C for creating widget: {c_var_name} of type {lvgl_base_type} with parent {parent_arg}")

        # Store C var name for later reference by ID
        if widget_id and not widget_id.startswith("@"):
            self._id_to_c_var[widget_id] = c_var_name
            # Also call _register_entity_by_id to generate C code for runtime registration
            # This is done after _apply_attributes in the base class flow typically.
            # Here we are just creating it. Registration happens via _register_entity_by_id.

        # Return: C variable name, LVGL type string (e.g. "lv_button"), original JSON type
        return c_var_name, lvgl_base_type, widget_type_json


    def _handle_style_creation(self, json_node, context_at_creation):
        style_id = json_node.get("id") # e.g. "@my_style" or "my_concrete_style"
        c_var_name = self._generate_unique_var_name(base="style")

        style_id_for_registry = ""
        if style_id and style_id.startswith("@"): # Component definition style template
            style_id_for_registry = style_id[1:] # "my_style" -> will be used by C side to manage/cache
        elif style_id: # Concrete style instance with an ID
            style_id_for_registry = style_id
        else: # Anonymous style
            style_id_for_registry = self._generate_unique_var_name(base="managed_style_reg")
            
        # Styles are managed as pointers
        self.c_style_declarations.append(f"lv_style_t *{c_var_name};")
        
        # Assumes a C helper function that finds or creates a style by a unique registry name and returns its pointer.
        # This C function handles lv_style_init internally and registers the style if newly created.
        self.c_setup_code.append(
            f"{c_var_name} = lvgl_json_create_style(\"{style_id_for_registry}\");"
        )
        
        logger.info(f"Generated C for style pointer: {c_var_name} (managed by name: '{style_id_for_registry}')")
        
        # If the original json_node had an "id" (not starting with @),
        # that ID should also be mapped to this c_var_name for direct lookup.
        if style_id and not style_id.startswith("@"):
            self._id_to_c_var[style_id] = c_var_name
            # The actual C side registration `lvgl_json_register_ptr` for this specific ID
            # will be called by the base class's `process_node` via `_register_entity_by_id`.

        # Return the C variable name (which holds the pointer) and its LVGL type
        return c_var_name, "lv_style_t*" # LVGL type for style pointers


    def _apply_property(self, entity_c_var_name, entity_lvgl_type_str, prop_name, prop_value_json, current_context):
        # Resolve the property value into a C-compatible string representation
        c_value_str = self._resolve_value(prop_value_json, None, current_context, entity_c_var_name)

        # Simplified assumption for setter func name determination (not directly used in the C call string)
        # setter_func_name = ""
        # if entity_lvgl_type_str.startswith("lv_style"):
        #      setter_func_name = f"lv_style_set_{prop_name}"
        # else:
        #      setter_func_name = f"{entity_lvgl_type_str}_set_{prop_name}"
        
        # The C function `lvgl_json_set_property` will take the entity pointer, its LVGL type string (for context),
        # the property name, and the string representation of the value.
        # It will then find the correct C function from the invocation table and manage unmarshaling.
        
        # entity_c_var_name is now always a pointer for both objects (lv_obj_t*) and styles (lv_style_t*).
        target_ref_for_c = entity_c_var_name

        self.c_setup_code.append(
            f"lvgl_json_set_property({target_ref_for_c}, \"{entity_lvgl_type_str}\", \"{prop_name}\", {c_value_str});"
        )
        logger.info(f"Generated C for setting property '{prop_name}' on '{entity_c_var_name}' to {c_value_str}")

    def _register_entity_by_id(self, entity_c_var_name, id_str, entity_type_str_for_registry, lvgl_type_str):
        # entity_type_str_for_registry is "widget", "style", "component_instance", etc.
        # lvgl_type_str is "lv_obj_t*", "lv_style_t*", etc.
        # The C variable `entity_c_var_name` now always holds a pointer.
        
        ptr_to_register = entity_c_var_name # This is already a pointer e.g. lv_obj_t* or lv_style_t*
        
        self.c_setup_code.append(
            f"lvgl_json_register_ptr(\"{id_str}\", \"{entity_type_str_for_registry}\", (void*){ptr_to_register});"
        )
        self._id_to_c_var[id_str] = entity_c_var_name # Keep track Python side too

    def _register_entity_by_named_attr(self, entity_c_var_name, named_str, entity_type_str_for_registry, lvgl_type_str, current_path_prefix):
        if current_path_prefix:
            if current_path_prefix.endswith(":"):
                full_name = f"{current_path_prefix}{named_str}"
            else:
                full_name = f"{current_path_prefix}:{named_str}"
        else:
            full_name = named_str
            
        ptr_to_register = entity_c_var_name # This is already a pointer

        self.c_setup_code.append(
            f"lvgl_json_register_ptr(\"{full_name}\", \"{entity_type_str_for_registry}\", (void*){ptr_to_register});"
        )
        self._named_attr_to_c_var[full_name] = entity_c_var_name

    def _get_entity_ref_from_id(self, id_str, expected_type_hint=None):
        # This returns a C *expression string* that evaluates to the pointer at runtime.
        # The expected_type_hint should be a C type string like "lv_obj_t*" or "lv_style_t*".
        if not expected_type_hint:
            logger.warning(f"Missing expected_type_hint for _get_entity_ref_from_id for ID '{id_str}'. Defaulting to 'void*'.")
            c_type_cast = "(void*)"
        else:
            c_type_cast = f"({expected_type_hint})"

        # The C function `lvgl_json_get_registered_ptr` will take the ID and maybe a type hint.
        # For now, assume it returns void* and we cast it.
        return f"{c_type_cast}lvgl_json_get_registered_ptr(\"{id_str}\", \"{expected_type_hint if expected_type_hint else ''}\")"

    def _perform_do_block_on_entity(self, entity_c_var_name, entity_lvgl_type_str, entity_original_json_type, 
                                   do_block_json, context_for_do_block, path_prefix_for_do_block_attrs, 
                                   type_for_named_in_do_block):
        # Save and set context for the duration of this 'do' block
        original_context = self.current_context
        self.current_context = context_for_do_block
        
        original_path_prefix = self.current_path_prefix
        self.current_path_prefix = path_prefix_for_do_block_attrs

        logger.info(f"Performing 'do' block on entity '{entity_c_var_name}' (type: {entity_lvgl_type_str})")

        # entity_lvgl_type_str might be None if called from use-view before type is known.
        # This is a known limitation being worked on. For now, assume it's available or _apply_property can handle.
        if not entity_lvgl_type_str and entity_original_json_type:
             # Try to infer LVGL type for _apply_property if full type unknown
             entity_lvgl_type_str = f"lv_{entity_original_json_type}" if entity_original_json_type != "obj" else "lv_obj"
             logger.debug(f"Inferred LVGL type as {entity_lvgl_type_str} for 'do' block on {entity_c_var_name}")


        for key, value in do_block_json.items():
            if key == "named":
                if isinstance(value, str) and entity_c_var_name:
                    # type_for_named_in_do_block is original json type like "button"
                    # entity_lvgl_type_str is like "lv_button"
                    self._register_entity_by_named_attr(entity_c_var_name, value, type_for_named_in_do_block, entity_lvgl_type_str, path_prefix_for_do_block_attrs)
                else:
                    logger.warning(f"'named' in 'do' block expects a string value. Got {type(value)}. Entity: {entity_c_var_name}")
            elif key == "children": # Children in a 'do' block? Unusual, but technically possible.
                if isinstance(value, list) and entity_c_var_name:
                    self._handle_children(value, entity_c_var_name, self.current_context, path_prefix_for_do_block_attrs)
                else:
                    logger.warning(f"'children' in 'do' block expects a list. Got {type(value)}. Entity: {entity_c_var_name}")
            # 'id', 'type', 'context' are not typical in a 'do' block's direct attributes.
            # 'with' could be, but implies recursion not handled here yet.
            else: # Assume it's a property to apply
                if entity_c_var_name and entity_lvgl_type_str:
                    self._apply_property(entity_c_var_name, entity_lvgl_type_str, key, value, self.current_context)
                else:
                    logger.error(f"Cannot apply property '{key}' in 'do' block: missing entity ref ('{entity_c_var_name}') or type ('{entity_lvgl_type_str}').")
        
        # Restore context
        self.current_context = original_context
        self.current_path_prefix = original_path_prefix

    # --- Orchestration of C Code Generation ---

    def _generate_c_invocation_system(self):
        """Generates C code for function invocation (refactor of invocation.py)."""
        # Placeholder: This will involve populating self.c_header_lines and self.c_source_lines
        # with C code for the invocation table, lookup functions, etc.
        # Based on self.api_info.
        logger.info("Generating C invocation system (placeholder)")
        # Example:
        # inv_h_code, inv_c_code = invocation.generate_invocation_c_code(self.api_info, self.str_vals)
        # self.c_header_lines.append(inv_h_code)
        # self.c_source_lines.append(inv_c_code)
        pass

    def _generate_c_registry_system(self):
        """Generates C code for pointer registry (refactor of registry.py)."""
        logger.info("Generating C registry system (placeholder)")
        # reg_h_code, reg_c_code = registry.generate_registry_c_code()
        # self.c_header_lines.append(reg_h_code)
        # self.c_source_lines.append(reg_c_code)
        pass

    def _generate_c_unmarshal_system(self):
        """Generates C code for unmarshaling values (refactor of unmarshal.py)."""
        logger.info("Generating C unmarshal system (placeholder)")
        # unmarshal_h_code, unmarshal_c_code = unmarshal.generate_unmarshal_c_code(self.api_info) # Needs api_info for enum lookups etc.
        # self.c_header_lines.append(unmarshal_h_code)
        # self.c_source_lines.append(unmarshal_c_code)
        # This method would also generate g_generated_enum_table, djb2_hash_c, compare_generated_enum_hash
        # which are needed by _generate_macro_values_exporter_c_code
        logger.info("Generating C unmarshal system (placeholder - includes enum table for macro exporter)")
        # For now, let's assume it populates some common list like self.c_source_lines
        # For example:
        # enum_unmarshal_c = unmarshal.generate_enum_unmarshalers(
        #    self.api_info['hashed_and_sorted_enum_members'],
        #    self.api_info['enum_members'] 
        # )
        # self.c_source_lines.append(enum_unmarshal_c) # This would contain enum table defs
        pass

    def _generate_macro_values_exporter_c_code(self, macro_names_list):
        """
        Generates C code for a function that can output a JSON string of macro values.
        Relies on enum unmarshaling code (g_generated_enum_table, etc.) being generated first.
        """
        helper_is_enum_c_code = """
// Helper to check if a name is a known generated enum member
static bool is_name_an_enum(const char *name_to_check) {
    if (!name_to_check) return false;
    // Ensure djb2_hash_c and compare_generated_enum_hash are available (defined earlier as static)
    uint32_t input_hash = djb2_hash_c(name_to_check);

    if (G_GENERATED_ENUM_TABLE_SIZE == 0) return false; // No enums to check against

    const generated_enum_entry_t *entry_ptr = (const generated_enum_entry_t *)bsearch(
        &input_hash,
        g_generated_enum_table,
        G_GENERATED_ENUM_TABLE_SIZE,
        sizeof(generated_enum_entry_t),
        compare_generated_enum_hash);

    if (!entry_ptr) return false; // No matching hash

    // Hash matches, now check name. Collisions are contiguous.
    // Go to the start of the hash collision block
    while (entry_ptr > g_generated_enum_table && (entry_ptr - 1)->hash == input_hash) {
        entry_ptr--;
    }
    // Iterate through all entries with the same hash
    while (entry_ptr < (g_generated_enum_table + G_GENERATED_ENUM_TABLE_SIZE) && entry_ptr->hash == input_hash) {
        if (strcmp(entry_ptr->original_name, name_to_check) == 0) {
            return true; // Exact name match
        }
        entry_ptr++;
    }
    return false; // Hash matched, but no exact name match in collision group
}
"""

        main_func_c_code_parts = [
            helper_is_enum_c_code,
            "\nchar* lvgl_json_generate_values_json(void) {",
            "    cJSON *json_root = cJSON_CreateObject();",
            "    if (!json_root) {",
            "        LVGL_LOG_ERROR(\"Failed to create cJSON root for macro values.\");", # Using LVGL_LOG if available
            "        return NULL;",
            "    }\n",
        ]

        for macro_name in macro_names_list:
            if not all(c.isalnum() or c == '_' for c in macro_name) or not macro_name:
                logger.warning(f"Skipping potentially invalid macro name for C code generation: '{macro_name}'")
                continue
            
            main_func_c_code_parts.append(f"    #ifdef {macro_name}")
            main_func_c_code_parts.append(f"    if (!is_name_an_enum(\"{macro_name}\")) {{")
            main_func_c_code_parts.append(f"        cJSON_AddNumberToObject(json_root, \"{macro_name}\", (double)({macro_name}));")
            main_func_c_code_parts.append(f"    }}")
            main_func_c_code_parts.append(f"    #else")
            main_func_c_code_parts.append(f"    // LVGL_LOG_TRACE(\"Macro {macro_name} not defined, skipped for JSON output.\");")
            main_func_c_code_parts.append(f"    #endif // {macro_name}")
            main_func_c_code_parts.append("") 

        main_func_c_code_parts.extend([
            "    char *json_string = cJSON_PrintUnformatted(json_root);",
            "    cJSON_Delete(json_root);",
            "",
            "    if (!json_string) {",
            "        LVGL_LOG_ERROR(\"Failed to print cJSON object for macro values.\");",
            "        char *err_str = (char*)lv_malloc(30);", # Assuming lv_malloc
            "        if(err_str) snprintf(err_str, 30, \"{{\\\"error\\\":\\\"print_failed\\\"}}\");",
            "        return err_str;", 
            "    }",
            "    return json_string;",
            "}\n"
        ])
        # This function's output should be added to self.c_source_lines
        # And its prototype to self.c_header_lines
        self.c_header_lines.append("char* lvgl_json_generate_values_json(void);")
        self.c_source_lines.extend(main_func_c_code_parts)
        logger.info("Generated C code for macro_values_exporter.")


    def _generate_c_main_render_function(self, root_ui_spec_node=None):
        """
        Generates the main C `lvgl_json_render_ui_from_spec` function and supporting UI setup code.
        If `root_ui_spec_node` is provided, it processes it to generate default UI.
        Otherwise, it generates an empty setup function or one that waits for dynamic spec.
        """
        logger.info("Generating C main render function.")
        
        # Header for the main render function
        self.c_header_lines.append("\n// Main UI Rendering Function");
        self.c_header_lines.append("void lvgl_json_render_ui_from_spec(const char* json_spec_str, lv_obj_t* parent_obj);")
        self.c_header_lines.append("void lvgl_json_setup_default_ui(lv_obj_t* default_parent); // If pre-defined UI exists")

        # Implementation
        self.c_function_implementations.append("\n// --- Widget Declarations ---")
        self.c_function_implementations.extend(self.c_widget_declarations)
        self.c_function_implementations.append("\n// --- Style Declarations ---")
        self.c_function_implementations.extend(self.c_style_declarations)
        
        self.c_function_implementations.append("\nvoid lvgl_json_setup_default_ui(lv_obj_t* default_parent) {")
        if root_ui_spec_node:
            # Process the pre-defined UI spec.
            # This will populate self.c_setup_code via the _handle_xxx methods.
            logger.info("Processing pre-defined UI specification for default UI.")
            # The initial parent for a default UI is typically passed to lvgl_json_setup_default_ui.
            # We need to ensure that variable `default_parent` is used.
            # For process_ui_spec, the parent_ref is a C variable name string.
            self.process_ui_spec(root_ui_spec_node, initial_parent_ref="default_parent") 
        else:
            logger.info("No pre-defined UI specification found for default UI.")
            self.c_setup_code.append("    // No default UI elements to create.");

        self.c_function_implementations.extend([f"    {line}" for line in self.c_setup_code])
        self.c_function_implementations.append("}\n")

        # The dynamic rendering function
        self.c_function_implementations.append(
            "void lvgl_json_render_ui_from_spec(const char* json_spec_str, lv_obj_t* parent_obj) {"
        )
        self.c_function_implementations.append("    // 1. Parse json_spec_str into a CJSON object (or similar).")
        self.c_function_implementations.append("    //    cJSON* root = cJSON_Parse(json_spec_str); if (!root) return;")
        self.c_function_implementations.append("    // 2. Clear any existing dynamic UI elements if necessary.")
        self.c_function_implementations.append("    //    lvgl_json_clear_dynamic_ui(); // Custom function to implement")
        self.c_function_implementations.append("    // 3. Traverse the CJSON structure and call creation/property functions.")
        self.c_function_implementations.append("    //    This would mirror the logic in BaseUIProcessor.process_node,")
        self.c_function_implementations.append("    //    but implemented in C, using the generated invocation table,")
        self.c_function_implementations.append("    //    registry, and unmarshalers.")
        self.c_function_implementations.append("    //    For example, a C function like:")
        self.c_function_implementations.append("    //    process_json_node_in_c(root, parent_obj, initial_context_c_side);")
        self.c_function_implementations.append("    // 4. Free CJSON object.")
        self.c_function_implementations.append("    //    cJSON_Delete(root);")
        self.c_function_implementations.append("    LVGL_LOG_INFO(\"lvgl_json_render_ui_from_spec called (dynamic rendering part not yet implemented in C).\");")
        self.c_function_implementations.append("}\n")


    def generate_interpreter_c_files(self, output_dir_path, root_ui_spec_node=None, base_filename="lvgl_json_renderer", debug_mode=False, macro_names_list_override=None):
        """
        Orchestrates the generation of all C code and writes it to files.
        `root_ui_spec_node` is the Python dict for a UI spec to pre-render into a setup function.
        `macro_names_list_override` is an optional list of macro names to export.
        """
        # Reset all code lists
        self.c_header_lines = ["#ifndef LVGL_JSON_RENDERER_H", "#define LVGL_JSON_RENDERER_H", "\n#include \"lvgl.h\"", "// Potentially include cJSON.h or other parser here\n"]
        if debug_mode:
            self.c_header_lines.append("#define LVGL_JSON_RENDERER_DEBUG 1") # Add debug flag if enabled

        self.c_source_lines = [f"#include \"{base_filename}.h\"", "#include <string.h>", "#include <stdio.h>", "#include <stdlib.h> // For strtoul, strtol, malloc, free", "// For cJSON or other parser's includes\n", "// For lvgl_json_utils.h (invocation, registry, unmarshal helpers)\n"]
        
        self.c_forward_declarations = []
        self.c_global_vars = []
        self.c_static_vars = []
        self.c_type_defs = []
        self.c_function_implementations = []
        self.c_widget_declarations = []
        self.c_style_declarations = []
        self.c_setup_code = []
        self.var_counter = 0 # Reset for fresh generation pass
        self._id_to_c_var.clear()
        self._named_attr_to_c_var.clear()

        # --- Generate various C code components ---
        # These will populate the c_xxx lists by calling methods that were previously
        # in invocation.py, registry.py, unmarshal.py, but are now part of this class.
        
        # 1. Invocation System (Function call dispatcher)
        self._generate_c_invocation_system() # Populates self.c_header_lines, self.c_source_lines (or more specific lists)

        # 2. Registry System (ID/Name to Pointer mapping)
        self._generate_c_registry_system()

        # 3. Unmarshal System (JSON value to C value conversion)
        # This MUST be called before _generate_macro_values_exporter_c_code as it defines
        # g_generated_enum_table and related functions used by the macro exporter.
        self._generate_c_unmarshal_system() # Populates self.c_source_lines with enum tables etc.

        # 4. Macro Values Exporter
        final_macro_names_list = macro_names_list_override if macro_names_list_override is not None else self.DEFAULT_MACRO_NAMES_TO_EXPORT
        if final_macro_names_list: # Only generate if there are macros to export
            logger.info(f"Using list of {len(final_macro_names_list)} macros for JSON value exporter.")
            self._generate_macro_values_exporter_c_code(final_macro_names_list)
        else:
            logger.info("No macros specified for JSON value exporter.")


        # 5. Main UI Rendering Logic / Default UI Setup
        # This call will use the process_node, _handle_widget_creation etc. to populate
        # self.c_widget_declarations, self.c_style_declarations, self.c_setup_code
        # if a root_ui_spec_node is provided.
        self._generate_c_main_render_function(root_ui_spec_node)


        # --- Assemble Header File ---
        self.c_header_lines.append("\n// Forward declarations from generation")
        self.c_header_lines.extend(self.c_forward_declarations)
        self.c_header_lines.append("\n#endif // LVGL_JSON_RENDERER_H")

        # --- Assemble Source File ---
        self.c_source_lines.append("\n// Type definitions from generation")
        self.c_source_lines.extend(self.c_type_defs)
        self.c_source_lines.append("\n// Global variables from generation")
        self.c_source_lines.extend(self.c_global_vars)
        self.c_source_lines.append("\n// Static variables from generation")
        self.c_source_lines.extend(self.c_static_vars)
        self.c_source_lines.append("\n// Function implementations from generation")
        self.c_source_lines.extend(self.c_function_implementations)


        # --- Write to files ---
        header_path = f"{output_dir_path}/{base_filename}.h"
        source_path = f"{output_dir_path}/{base_filename}.c"

        try:
            # For now, just log the content that would be written.
            # In a real scenario, use file writing operations.
            logger.info(f"--- Header file: {header_path} ---")
            for line in self.c_header_lines:
                logger.debug(line)
            
            logger.info(f"--- Source file: {source_path} ---")
            for line in self.c_source_lines:
                logger.debug(line)

            # Actual file writing (example, replace with proper tool if available, or direct write)
            # self._write_file(header_path, "\n".join(self.c_header_lines))
            # self._write_file(source_path, "\n".join(self.c_source_lines))
            logger.info(f"C code generation structure complete. Files {header_path} and {source_path} would be written.")

        except IOError as e:
            logger.error(f"Failed to write C files: {e}")
            return False
        return True

    # Helper for direct file writing if no tool is used (for local testing)
    # def _write_file(self, filepath, content):
    #     import os
    #     os.makedirs(os.path.dirname(filepath), exist_ok=True)
    #     with open(filepath, 'w') as f:
    #         f.write(content)

# Example of how it might be used (conceptual)
# if __name__ == '__main__':
#     logging.basicConfig(level=logging.INFO)
#     # Mock api_info, paths - replace with actual loaded data
#     mock_api_info = { 
#         "functions": [], "enums": [], "enum_members": {}, 
#         "typedefs": [], "variables": [] 
#     } 
#     generator = DynamicUIGenerator(mock_api_info, "lv_def.json", "str_vals.json")
    
#     # Example UI spec to pre-render (optional)
#     sample_ui_spec = {
#         "type": "obj", "id": "main_screen",
#         "children": [
#             {"type": "label", "id": "my_label", "text": "Hello World!"}
#         ]
#     }
    
#     generator.generate_interpreter_c_files("./generated_c_code", root_ui_spec_node=sample_ui_spec)

```
