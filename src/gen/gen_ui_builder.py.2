#!/usr/bin/env python3

import argparse
import os

# --- Configuration ---
BUILDER_PREFIX = "ui_builder_"
HEADER_FILENAME = f"{BUILDER_PREFIX}lvgl.h"
SOURCE_FILENAME = f"{BUILDER_PREFIX}lvgl.c"
CJSON_INCLUDE = "<cJSON.h>"
LVGL_INCLUDE = "<lvgl.h>" # Assuming lvgl.h is in include path

# Define resource types for registration
REG_TYPE_FONT = "Font"
REG_TYPE_IMAGE = "Image"
REG_TYPE_STYLE = "Style"
# Add other types if needed (e.g., REG_TYPE_CALLBACK)

# --- C Code Generation ---

def generate_builder_header():
    """Generates the ui_builder_lvgl.h file content."""
    header = f"""\
#ifndef {BUILDER_PREFIX.upper()}LVGL_H
#define {BUILDER_PREFIX.upper()}LVGL_H

#ifdef __cplusplus
extern "C" {{
#endif

#include {LVGL_INCLUDE}
#include <stdbool.h>

// --- Resource Registration ---

/**
 * @brief Registers a named pointer (font, image, style, etc.) for lookup during UI building.
 * The builder takes ownership of the 'name' string (makes a copy).
 * @param name A unique name for the resource (e.g., "font_montserrat_24", "my_custom_style").
 * @param ptr Pointer to the resource (e.g., const lv_font_t*, const lv_img_dsc_t*, lv_style_t*).
 * @param type_tag A string tag identifying the resource type (e.g., "{REG_TYPE_FONT}", "{REG_TYPE_IMAGE}", "{REG_TYPE_STYLE}"). Used for type safety during lookup.
 * @return true on success, false on failure (e.g., duplicate name, allocation error).
 */
bool {BUILDER_PREFIX}register_resource(const char *name, const void *ptr, const char *type_tag);

/**
 * @brief Helper macro to register a font.
 */
#define {BUILDER_PREFIX}register_font(name, font_ptr) \\
    {BUILDER_PREFIX}register_resource(name, (const void*)(font_ptr), "{REG_TYPE_FONT}")

/**
 * @brief Helper macro to register an image descriptor.
 */
#define {BUILDER_PREFIX}register_image(name, img_dsc_ptr) \\
    {BUILDER_PREFIX}register_resource(name, (const void*)(img_dsc_ptr), "{REG_TYPE_IMAGE}")

/**
 * @brief Helper macro to register a style.
 * Note: The style object itself should be initialized and properties set *before* registering.
 * The builder only stores the pointer; it doesn't manage the style's lifecycle or content.
 */
#define {BUILDER_PREFIX}register_style(name, style_ptr) \\
    {BUILDER_PREFIX}register_resource(name, (const void*)(style_ptr), "{REG_TYPE_STYLE}")


/**
 * @brief Removes all registered resources and frees associated memory.
 * Call this when the builder is no longer needed or before re-registering resources.
 */
void {BUILDER_PREFIX}cleanup_registrations(void);

// --- UI Building ---

/**
 * @brief Parses a JSON string and builds the corresponding LVGL UI hierarchy.
 *
 * @param parent The LVGL parent object under which the new UI will be created.
 * @param json_string A null-terminated string containing the JSON definition of the UI,
 *                    as generated by the emul_lvgl library.
 * @return A pointer to the top-level LVGL object created from the JSON root,
 *         or NULL if parsing or building fails.
 */
lv_obj_t* {BUILDER_PREFIX}load_ui_from_json(lv_obj_t *parent, const char *json_string);


#ifdef __cplusplus
}} /* extern "C" */
#endif

#endif /* {BUILDER_PREFIX.upper()}LVGL_H */
"""
    return header

def generate_builder_source():
    """Generates the ui_builder_lvgl.c file content."""
    source = f"""\
#include "{HEADER_FILENAME}"
#include {CJSON_INCLUDE}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// --- Type Definitions ---

// Simple linked list for resource registration
typedef struct RegisteredResource {{
    char *name;         // Owned by this struct (allocated copy)
    const void *ptr;
    char *type_tag;     // Owned by this struct (allocated copy)
    struct RegisteredResource *next;
}} RegisteredResource_t;

// --- Global State ---

static RegisteredResource_t *g_registered_resources = NULL;

// --- Forward Declarations ---

static lv_obj_t* build_object_from_json(lv_obj_t *parent, cJSON *json_obj);
static void apply_properties(lv_obj_t *obj, const char* obj_type, cJSON *props_json);
static void apply_styles(lv_obj_t *obj, cJSON *styles_json);
static const void* find_registered_ptr(const char *name, const char *expected_type_tag);
static lv_color_t parse_color(cJSON *color_json);
static lv_coord_t parse_coord(cJSON *coord_json);


// --- Resource Registration Implementation ---

bool {BUILDER_PREFIX}register_resource(const char *name, const void *ptr, const char *type_tag) {{
    if (!name || !ptr || !type_tag) {{
        fprintf(stderr, "UI Builder Error: Invalid arguments to register_resource.\\n");
        return false;
    }}

    // Check for duplicate names
    RegisteredResource_t *current = g_registered_resources;
    while (current) {{
        if (strcmp(current->name, name) == 0) {{
            fprintf(stderr, "UI Builder Error: Duplicate resource name registered: '%s'.\\n", name);
            return false; // Reject duplicates
        }}
        current = current->next;
    }}

    // Allocate memory for the new registration entry
    RegisteredResource_t *new_reg = (RegisteredResource_t*)malloc(sizeof(RegisteredResource_t));
    if (!new_reg) {{
        fprintf(stderr, "UI Builder Error: Failed to allocate memory for resource registration.\\n");
        return false;
    }}

    // Allocate memory and copy the name and type_tag strings
    new_reg->name = (char*)malloc(strlen(name) + 1);
    new_reg->type_tag = (char*)malloc(strlen(type_tag) + 1);

    if (!new_reg->name || !new_reg->type_tag) {{
        fprintf(stderr, "UI Builder Error: Failed to allocate memory for resource name/tag.\\n");
        free(new_reg->name); // Free potentially allocated name
        free(new_reg->type_tag); // Free potentially allocated tag
        free(new_reg);
        return false;
    }}

    strcpy(new_reg->name, name);
    strcpy(new_reg->type_tag, type_tag);
    new_reg->ptr = ptr;
    new_reg->next = g_registered_resources;
    g_registered_resources = new_reg;

    // printf("UI Builder Info: Registered resource '%s' (Type: %s)\\n", name, type_tag);
    return true;
}}

void {BUILDER_PREFIX}cleanup_registrations(void) {{
    RegisteredResource_t *current = g_registered_resources;
    while (current) {{
        RegisteredResource_t *next = current->next;
        free(current->name);
        free(current->type_tag);
        free(current);
        current = next;
    }}
    g_registered_resources = NULL;
    // printf("UI Builder Info: Cleaned up all registered resources.\\n");
}}

// --- Internal Helper Functions ---

static const void* find_registered_ptr(const char *name, const char *expected_type_tag) {{
    if (!name || !expected_type_tag) return NULL;

    RegisteredResource_t *current = g_registered_resources;
    while (current) {{
        if (strcmp(current->name, name) == 0) {{
            if (strcmp(current->type_tag, expected_type_tag) == 0) {{
                return current->ptr; // Found matching name and type
            }} else {{
                fprintf(stderr, "UI Builder Warning: Resource '%s' found, but type mismatch (Expected: %s, Actual: %s).\\n",
                        name, expected_type_tag, current->type_tag);
                return NULL; // Type mismatch
            }}
        }}
        current = current->next;
    }}

    fprintf(stderr, "UI Builder Warning: Resource '%s' (Type: %s) not found in registrations.\\n", name, expected_type_tag);
    return NULL; // Not found
}}

// Parses coordinate value which can be a number or special string
static lv_coord_t parse_coord(cJSON *coord_json) {{
    if (!coord_json) return 0;

    if (cJSON_IsNumber(coord_json)) {{
        return (lv_coord_t)coord_json->valuedouble;
    }} else if (cJSON_IsString(coord_json)) {{
        const char *str_val = coord_json->valuestring;
        if (strcmp(str_val, "SIZE_CONTENT") == 0) {{
            return LV_SIZE_CONTENT;
        }}
        // Add other special values if needed (e.g., "PCT(50)") - requires more complex parsing
        // For simplicity, only handle SIZE_CONTENT for now.
        fprintf(stderr, "UI Builder Warning: Unknown coordinate string value: '%s'. Using 0.\\n", str_val);
        return 0;
    }}
    return 0; // Default
}}

// Parses color value - assumes number format (e.g., 0xFF0000) for simplicity for now
// Could be extended to handle {{"r":..., "g":..., "b":...}} objects
static lv_color_t parse_color(cJSON *color_json) {{
    if (color_json && cJSON_IsNumber(color_json)) {{
        // Assuming the number represents the color in LVGL's native format or hex
        // Using lv_color_hex might interpret it as RRGGBB
        // return lv_color_hex((uint32_t)color_json->valuedouble);
        // Or, if emul_lvgl stored the raw lv_color_t uint32_t value:
         lv_color_t color;
         *(uint32_t*)&color = (uint32_t)color_json->valuedouble; // Direct assignment if format matches
         return color;

    }} else if (color_json && cJSON_IsObject(color_json)) {{
         // TODO: Handle {{"r": R, "g": G, "b": B, "a": A}} format if needed
         uint8_t r = cJSON_GetObjectItemCaseSensitive(color_json, "r") ? (uint8_t)cJSON_GetObjectItemCaseSensitive(color_json, "r")->valuedouble : 0;
         uint8_t g = cJSON_GetObjectItemCaseSensitive(color_json, "g") ? (uint8_t)cJSON_GetObjectItemCaseSensitive(color_json, "g")->valuedouble : 0;
         uint8_t b = cJSON_GetObjectItemCaseSensitive(color_json, "b") ? (uint8_t)cJSON_GetObjectItemCaseSensitive(color_json, "b")->valuedouble : 0;
         // uint8_t a = cJSON_GetObjectItemCaseSensitive(color_json, "a") ? (uint8_t)cJSON_GetObjectItemCaseSensitive(color_json, "a")->valuedouble : 255; // LV_OPA_COVER
         return lv_color_make(r, g, b); // Or lv_color_hex3 if alpha not present
    }}
    fprintf(stderr, "UI Builder Warning: Invalid or unhandled color format. Using black.\\n");
    return lv_color_black(); // Default color
}}


// --- Core Building Logic ---

static lv_obj_t* build_object_from_json(lv_obj_t *parent, cJSON *json_obj) {{
    if (!json_obj || !cJSON_IsObject(json_obj)) {{
        fprintf(stderr, "UI Builder Error: Invalid JSON object provided for building.\\n");
        return NULL;
    }}

    // 1. Get Object Type
    cJSON *type_item = cJSON_GetObjectItemCaseSensitive(json_obj, "type");
    if (!type_item || !cJSON_IsString(type_item)) {{
        fprintf(stderr, "UI Builder Error: JSON object missing or invalid 'type'.\\n");
        return NULL;
    }}
    const char *type_str = type_item->valuestring;

    // 2. Create LVGL Object based on type
    lv_obj_t *obj = NULL;
    if (strcmp(type_str, "obj") == 0) {{
        obj = lv_obj_create(parent);
    }} else if (strcmp(type_str, "label") == 0) {{
        obj = lv_label_create(parent);
    }} else if (strcmp(type_str, "btn") == 0) {{
        obj = lv_btn_create(parent);
    }} else if (strcmp(type_str, "img") == 0) {{
        obj = lv_img_create(parent);
    }} else if (strcmp(type_str, "cont") == 0) {{ // LVGL < v9 often used 'cont'
        obj = lv_obj_create(parent); // Map cont to obj
    }} else if (strcmp(type_str, "line") == 0) {{
        obj = lv_line_create(parent);
    }} else if (strcmp(type_str, "bar") == 0) {{
        obj = lv_bar_create(parent);
    }} else if (strcmp(type_str, "slider") == 0) {{
        obj = lv_slider_create(parent);
    }} else if (strcmp(type_str, "checkbox") == 0) {{
        obj = lv_checkbox_create(parent);
    }} else if (strcmp(type_str, "dropdown") == 0) {{
        obj = lv_dropdown_create(parent);
    }} else if (strcmp(type_str, "textarea") == 0) {{
         obj = lv_textarea_create(parent);
    }}
    // Add more widget types here...
    /* Example:
    else if (strcmp(type_str, "roller") == 0) {{
        obj = lv_roller_create(parent);
    }}
    */
    else {{
        fprintf(stderr, "UI Builder Warning: Unknown object type '%s'. Creating plain lv_obj_t.\\n", type_str);
        obj = lv_obj_create(parent); // Fallback to plain object
    }}

    if (!obj) {{
        fprintf(stderr, "UI Builder Error: Failed to create LVGL object of type '%s'.\\n", type_str);
        return NULL; // Failed to create object
    }}

    // 3. Apply Properties (using lv_obj_set_...)
    cJSON *props = cJSON_GetObjectItemCaseSensitive(json_obj, "properties");
    if (props && cJSON_IsObject(props)) {{
        apply_properties(obj, type_str, props);
    }}

    // 4. Apply Styles (using lv_obj_add_style with registered styles)
    cJSON *styles = cJSON_GetObjectItemCaseSensitive(json_obj, "styles");
    if (styles && cJSON_IsArray(styles)) {{
        apply_styles(obj, styles);
    }}

    // 5. Recursively Build Children
    cJSON *children = cJSON_GetObjectItemCaseSensitive(json_obj, "children");
    if (children && cJSON_IsArray(children)) {{
        cJSON *child_json = NULL;
        cJSON_ArrayForEach(child_json, children) {{
            build_object_from_json(obj, child_json); // Create child under the current object
            // We don't strictly need the return value here unless we link them differently
        }}
    }}

    return obj;
}}

// Helper to apply properties from the "properties" JSON object
static void apply_properties(lv_obj_t *obj, const char* obj_type, cJSON *props_json) {{
    cJSON *prop = NULL;
    cJSON_ArrayForEach(prop, props_json) {{ // Iterate through properties
        const char *prop_name = prop->string;
        if (!prop_name) continue;

        // --- Generic Object Properties (lv_obj_set_...) ---
        if (strcmp(prop_name, "width") == 0) {{
            lv_obj_set_width(obj, parse_coord(prop));
        }} else if (strcmp(prop_name, "height") == 0) {{
            lv_obj_set_height(obj, parse_coord(prop));
        }} else if (strcmp(prop_name, "x") == 0 && cJSON_IsNumber(prop)) {{
            lv_obj_set_x(obj, (lv_coord_t)prop->valuedouble);
        }} else if (strcmp(prop_name, "y") == 0 && cJSON_IsNumber(prop)) {{
            lv_obj_set_y(obj, (lv_coord_t)prop->valuedouble);
        }} else if (strcmp(prop_name, "align") == 0 && cJSON_IsNumber(prop)) {{
            // Assumes align enum values match numbers in JSON
            lv_obj_set_align(obj, (lv_align_t)prop->valuedouble);
        }} else if (strcmp(prop_name, "align_x") == 0 && cJSON_IsNumber(prop)) {{
             // lv_obj_set_align is preferred, but handle if separate x/y were stored
             lv_obj_set_x(obj, (lv_coord_t)prop->valuedouble);
             // TODO: Need Y align info too for lv_obj_align_to
        }} else if (strcmp(prop_name, "align_y") == 0 && cJSON_IsNumber(prop)) {{
             lv_obj_set_y(obj, (lv_coord_t)prop->valuedouble);
        }}
        // Add Flag/State Handling (more complex than simple set)
        else if (strcmp(prop_name, "flags") == 0 && cJSON_IsNumber(prop)) {{
             // This would likely require lv_obj_add_flag/clear_flag based on comparison
             // For simplicity, maybe store flags individually in JSON?
             // Or assume this number is the final state and use lv_obj_add_flag directly?
             // lv_obj_add_flag(obj, (lv_obj_flag_t)prop->valuedouble); // Might add flags not intended
             fprintf(stderr, "UI Builder Warning: Direct setting of 'flags' property not fully supported. Use add/clear functions in source UI.\\n");
        }} else if (strcmp(prop_name, "state") == 0 && cJSON_IsNumber(prop)) {{
            // Similar complexity for state as for flags
             fprintf(stderr, "UI Builder Warning: Direct setting of 'state' property not fully supported. Use add/clear functions in source UI.\\n");
        }}
        else if (strcmp(prop_name, "hidden") == 0 && cJSON_IsBool(prop)) {{
             if (cJSON_IsTrue(prop)) lv_obj_add_flag(obj, LV_OBJ_FLAG_HIDDEN);
             else lv_obj_clear_flag(obj, LV_OBJ_FLAG_HIDDEN);
        }} else if (strcmp(prop_name, "clickable") == 0 && cJSON_IsBool(prop)) {{
             if (cJSON_IsTrue(prop)) lv_obj_add_flag(obj, LV_OBJ_FLAG_CLICKABLE);
             else lv_obj_clear_flag(obj, LV_OBJ_FLAG_CLICKABLE);
        }}
        // Add more common flags like SCROLLABLE, CHECKABLE, etc.

        // --- Widget-Specific Properties ---
        else if (strcmp(obj_type, "label") == 0) {{
            if (strcmp(prop_name, "text") == 0 && cJSON_IsString(prop)) {{
                lv_label_set_text(obj, prop->valuestring);
            }} else if (strcmp(prop_name, "long_mode") == 0 && cJSON_IsNumber(prop)) {{
                 lv_label_set_long_mode(obj, (lv_label_long_mode_t)prop->valuedouble);
            }} else if (strcmp(prop_name, "recolor") == 0 && cJSON_IsBool(prop)) {{
                 lv_label_set_recolor(obj, cJSON_IsTrue(prop));
            }}
            // ... other label properties
        }} else if (strcmp(obj_type, "img") == 0) {{
            if (strcmp(prop_name, "src") == 0 && cJSON_IsString(prop)) {{
                 const lv_img_dsc_t* img_dsc = find_registered_ptr(prop->valuestring, "{REG_TYPE_IMAGE}");
                 if (img_dsc) lv_img_set_src(obj, img_dsc);
            }} else if (strcmp(prop_name, "angle") == 0 && cJSON_IsNumber(prop)) {{
                 lv_img_set_angle(obj, (int16_t)prop->valuedouble);
            }} else if (strcmp(prop_name, "zoom") == 0 && cJSON_IsNumber(prop)) {{
                 lv_img_set_zoom(obj, (uint16_t)prop->valuedouble);
            }}
            // ... other image properties (pivot, etc.)
        }} else if (strcmp(obj_type, "bar") == 0 || strcmp(obj_type, "slider") == 0) {{
             if (strcmp(prop_name, "value") == 0 && cJSON_IsNumber(prop)) {{
                 lv_bar_set_value(obj, (int32_t)prop->valuedouble, LV_ANIM_OFF); // No animation during build
             }} else if (strcmp(prop_name, "range_min") == 0 && cJSON_IsNumber(prop)) {{
                 // Requires knowing max too, use lv_bar_set_range
                 cJSON* max_prop = cJSON_GetObjectItem(props_json, "range_max");
                 if (max_prop && cJSON_IsNumber(max_prop)) {{
                    lv_bar_set_range(obj, (int32_t)prop->valuedouble, (int32_t)max_prop->valuedouble);
                 }}
             }} else if (strcmp(prop_name, "range_max") == 0) {{
                  // Handled by range_min case above
             }} else if (strcmp(prop_name, "mode") == 0 && cJSON_IsNumber(prop)) {{
                 // Assuming it's lv_bar_mode_t
                 lv_bar_set_mode(obj, (lv_bar_mode_t)prop->valuedouble);
             }}
             // Slider specific? Check type again if needed
             if(strcmp(obj_type, "slider") == 0) {{
                 // Add slider specific props if any differ from bar
             }}
        }} else if (strcmp(obj_type, "checkbox") == 0) {{
             if (strcmp(prop_name, "text") == 0 && cJSON_IsString(prop)) {{
                 lv_checkbox_set_text(obj, prop->valuestring);
             }}
             // Note: checked state is handled via LV_STATE_CHECKED flag/state, not usually a direct property set
        }} else if (strcmp(obj_type, "dropdown") == 0) {{
             if (strcmp(prop_name, "options") == 0 && cJSON_IsString(prop)) {{
                 lv_dropdown_set_options_static(obj, prop->valuestring); // Assuming newline separated string
             }} else if (strcmp(prop_name, "selected") == 0 && cJSON_IsNumber(prop)) {{
                 lv_dropdown_set_selected(obj, (uint16_t)prop->valuedouble);
             }} else if (strcmp(prop_name, "text") == 0 && cJSON_IsString(prop)) {{
                 // Text is often generated from selection, but can be set
                 lv_dropdown_set_text(obj, prop->valuestring);
             }}
             // ... other dropdown properties (symbol, direction etc)
        }} else if (strcmp(obj_type, "textarea") == 0) {{
             if (strcmp(prop_name, "text") == 0 && cJSON_IsString(prop)) {{
                 lv_textarea_set_text(obj, prop->valuestring);
             }} else if (strcmp(prop_name, "placeholder_text") == 0 && cJSON_IsString(prop)) {{
                 lv_textarea_set_placeholder_text(obj, prop->valuestring);
             }} else if (strcmp(prop_name, "one_line") == 0 && cJSON_IsBool(prop)) {{
                 lv_textarea_set_one_line(obj, cJSON_IsTrue(prop));
             }} else if (strcmp(prop_name, "password_mode") == 0 && cJSON_IsBool(prop)) {{
                  lv_textarea_set_password_mode(obj, cJSON_IsTrue(prop));
             }}
             // ... other textarea props (accepted chars, max length)
        }}

        // Add more widget-specific property handlers here...

        else {{
            // Optional: Warn about unhandled properties
            // fprintf(stderr, "UI Builder Info: Property '%s' on type '%s' not explicitly handled by builder.\\n", prop_name, obj_type);
        }}
    }}
}}


// Helper to apply styles from the "styles" JSON array
static void apply_styles(lv_obj_t *obj, cJSON *styles_json) {{
    cJSON *style_ref = NULL;
    cJSON_ArrayForEach(style_ref, styles_json) {{
        if (!cJSON_IsObject(style_ref)) continue;

        cJSON *name_item = cJSON_GetObjectItemCaseSensitive(style_ref, "style_name");
        cJSON *selector_item = cJSON_GetObjectItemCaseSensitive(style_ref, "selector");

        if (name_item && cJSON_IsString(name_item) && selector_item && cJSON_IsNumber(selector_item)) {{
            const char *style_name = name_item->valuestring;
            lv_style_selector_t selector = (lv_style_selector_t)selector_item->valuedouble;

            // Look up the style pointer by name
            lv_style_t* style_ptr = (lv_style_t*)find_registered_ptr(style_name, "{REG_TYPE_STYLE}");

            if (style_ptr) {{
                lv_obj_add_style(obj, style_ptr, selector);
            }} else {{
                fprintf(stderr, "UI Builder Warning: Failed to find registered style named '%s'. Cannot apply style.\\n", style_name);
            }}
        }} else {{
             fprintf(stderr, "UI Builder Warning: Invalid style reference format found in JSON.\\n");
        }}
    }}
}}


// --- Public API Implementation ---

lv_obj_t* {BUILDER_PREFIX}load_ui_from_json(lv_obj_t *parent, const char *json_string) {{
    if (!parent || !json_string) {{
        fprintf(stderr, "UI Builder Error: NULL parent or JSON string provided.\\n");
        return NULL;
    }}

    cJSON *root_json = cJSON_Parse(json_string);
    if (!root_json) {{
        const char *error_ptr = cJSON_GetErrorPtr();
        fprintf(stderr, "UI Builder Error: Failed to parse JSON string.");
        if (error_ptr) {{
            fprintf(stderr, " Error near: %s\\n", error_ptr);
        }} else {{
            fprintf(stderr, "\\n");
        }}
        return NULL;
    }}

    // Assume the top-level element in the JSON is the root object to build
    lv_obj_t *created_root_obj = build_object_from_json(parent, root_json);

    // Clean up parsed JSON
    cJSON_Delete(root_json);

    if (!created_root_obj) {{
        fprintf(stderr, "UI Builder Error: Failed to build UI from JSON root object.\\n");
        // Note: Partial UI might have been created before failure. Consider cleanup?
    }}

    return created_root_obj;
}}

// --- End of Source ---
"""
    return source

# --- Main Script Logic ---

def main():
    parser = argparse.ArgumentParser(description="Generate ui_builder C library for LVGL from JSON.")
    parser.add_argument("-o", "--output-dir", required=True, help="Directory to save the generated ui_builder_lvgl.h and ui_builder_lvgl.c files.")
    args = parser.parse_args()

    # Create output directory if it doesn't exist
    os.makedirs(args.output_dir, exist_ok=True)

    print("Generating ui_builder library...")

    # --- Generate Header File ---
    header_path = os.path.join(args.output_dir, HEADER_FILENAME)
    print(f"Generating {header_path}...")
    try:
        with open(header_path, 'w') as f:
            f.write(generate_builder_header())
        print(f"Successfully generated {header_path}")
    except Exception as e:
        print(f"Error writing header file {header_path}: {e}")
        import traceback
        traceback.print_exc()
        return

    # --- Generate Source File ---
    source_path = os.path.join(args.output_dir, SOURCE_FILENAME)
    print(f"Generating {source_path}...")
    try:
        with open(source_path, 'w') as f:
            f.write(generate_builder_source())
        print(f"Successfully generated {source_path}")
    except Exception as e:
        print(f"Error writing source file {source_path}: {e}")
        import traceback
        traceback.print_exc()
        return

    print("ui_builder generation complete.")
    print(f"Remember to link against the LVGL and cJSON libraries when compiling {SOURCE_FILENAME}.")
    print("Ensure you register required fonts, images, and styles using ui_builder_register_resource() or helper macros before calling ui_builder_load_ui_from_json().")


if __name__ == "__main__":
    main()
