#!/usr/bin/env python3

import json
import argparse
import os
import re
from collections import defaultdict

# --- Configuration ---
EMUL_PREFIX = ""
HEADER_FILENAME = f"{EMUL_PREFIX}lvgl.h"
SOURCE_FILENAME = f"{EMUL_PREFIX}lvgl.c"
CJSON_INCLUDE = "<cJSON.h>"
DEFAULT_RETURN_MAP = {
    "void": "",
    "int": "return 0;",
    "bool": "return false;",
    "char *": "return NULL;",
    "const char *": "return NULL;",
    "lv_res_t": "return LV_RES_OK;", # Assuming LV_RES_OK is defined
    # Add more default returns as needed, especially for pointer types
}

# --- Type Mapping and Helper Functions ---

# Store known typedefs globally for lookup
typedef_map = {}
enum_names = set()
struct_names = set()
func_ptr_names = set()

def sanitize_name(name):
    """Sanitizes names that might be C keywords or invalid identifiers."""
    if name is None:
        return "_unnamed_"
    # Simple check, might need expansion
    keywords = {"struct", "union", "enum", "case", "default", "char", "int", "float", "double", "void"}
    if name in keywords:
        return f"_{name}"
    return name

def get_base_type_name(type_info):
    """Recursively find the base name of a type (e.g., int, lv_obj_t)."""
    if not isinstance(type_info, dict):
        return "unknown" # Should not happen with valid JSON
    json_type = type_info.get("json_type")

    if json_type == "pointer":
        return get_base_type_name(type_info.get("type"))
    elif json_type in ["lvgl_type", "stdlib_type", "primitive_type", "enum", "struct", "union", "forward_decl", "function_pointer", "typedef"]:
        return type_info.get("name")
    elif json_type == "ret_type":
         return get_base_type_name(type_info.get("type"))
    elif json_type == "special_type" and type_info.get("name") == "ellipsis":
        return "..."
    else:
        # Handle other types like 'array' if necessary
        # print(f"Warning: Unhandled base type extraction for json_type: {json_type}, info: {type_info}")
        return type_info.get("name", "unknown_base")

def map_type_to_emul(type_info, is_return_type=False, level=0):
    """Maps a JSON type description to its C equivalent for the emulator."""
    if not isinstance(type_info, dict):
        # print(f"Warning: Invalid type_info format: {type_info}")
        return "void /* unknown */"

    json_type = type_info.get("json_type")
    name = type_info.get("name")
    quals = type_info.get("quals", [])
    qual_str = " ".join(quals) + (" " if quals else "")

    # Limit recursion depth
    if level > 10:
        # print(f"Warning: Recursion depth limit exceeded for type: {type_info}")
        return f"{qual_str}void* /* recursion_limit */"

    # Handle specific known LVGL types that need mapping
    if name == "lv_obj_t" and json_type != "struct": # Pointers to lv_obj_t
         return f"{qual_str}{EMUL_PREFIX}lv_obj_t *"
    if name == "lv_style_t" and json_type != "struct": # Pointers to lv_style_t
        return f"{qual_str}{EMUL_PREFIX}lv_style_t *"

    # Handle fundamental types directly
    if json_type in ["stdlib_type", "primitive_type"]:
        # Use stdint types for fixed-size integers if needed, C99 types are good
        c_type = name
        if c_type == 'bool': # Ensure bool is available
             c_type = 'bool'
        elif c_type == '_Bool':
             c_type = 'bool'
        # Heuristic for size_t, uintptr_t etc. Requires stdint/stddef
        if c_type in ["size_t", "uintptr_t", "intptr_t"]:
             c_type = f"/* {c_type} */ uintptr_t" # Map to common int type for simplicity? Or keep?
        return f"{qual_str}{c_type}"

    if json_type == "pointer":
        pointee_type = type_info.get("type")
        # Check for void* separately
        if isinstance(pointee_type, dict) and pointee_type.get("json_type") == "primitive_type" and pointee_type.get("name") == "void":
            return f"{qual_str}void *"
        # Check for char* (strings)
        if isinstance(pointee_type, dict) and pointee_type.get("json_type") == "primitive_type" and pointee_type.get("name") == "char":
            # Distinguish const char* from char*
            pointee_quals = pointee_type.get("quals", [])
            if "const" in pointee_quals:
                 return f"{qual_str}const char *"
            else:
                 return f"{qual_str}char *"

        # Recursive call for other pointers
        inner_type = map_type_to_emul(pointee_type, is_return_type, level + 1)
        # Avoid adding '*' if inner type already ends with '*' (double pointers etc)
        if inner_type.endswith("*"):
             # This check might be too simple for complex types like function pointers returning pointers
             return f"{qual_str}{inner_type}" # Assumes inner type includes '*'
        else:
             # Check if inner type is a function pointer typedef name
             base_inner = get_base_type_name(pointee_type)
             if base_inner in func_ptr_names:
                 # If it's a function pointer type name, don't add another '*'
                 return f"{qual_str}{inner_type}"
             else:
                return f"{qual_str}{inner_type} *"

    if json_type == "lvgl_type":
        # Check if it's a typedef'd pointer that we already handled
        if name in ["lv_obj_t", "lv_style_t"]: # Already mapped special cases
             return f"{qual_str}{EMUL_PREFIX}{name} *" # Should be pointer usually handled above
        # Check if it's an enum or struct defined elsewhere
        if name in enum_names:
            return f"{qual_str}{EMUL_PREFIX}{name}" # Use emulated enum name
        if name in struct_names:
            # If it's a struct used by value (less common in LVGL API args)
            # We might need to define a simplified emul_ struct
            # For now, assume it's mostly used via pointers (handled above)
            # Or it's a simple struct like lv_color_t that we might define
             base_name = name.replace("_lv_", f"_{EMUL_PREFIX}lv_") if name.startswith("_lv_") else f"{EMUL_PREFIX}{name}"
             return f"{qual_str}{base_name}" # Use emulated struct name
        # Check typedefs
        if name in typedef_map:
             return map_type_to_emul(typedef_map[name]['type'], is_return_type, level + 1)

        # Default LVGL type handling (may need prefix)
        # Most lv_..._t are typedefs for primitives, enums, structs, or pointers
        # print(f"Warning: Potentially unhandled lvgl_type: {name}. Treating as opaque.")
        # Fallback: Use original name, possibly prefixed
        base_name = name.replace("_lv_", f"_{EMUL_PREFIX}lv_") if name.startswith("_lv_") else f"{EMUL_PREFIX}{name}"
        return f"{qual_str}{base_name}"

    if json_type == "enum":
         # Enums are usually named via typedef, handle via lvgl_type or typedefs
         # If an unnamed enum type is directly used, this might need adjustment
         enum_name = type_info.get("name", "anonymous_enum") # Usually has a name if typedef'd
         base_name = enum_name.replace("_lv_", f"_{EMUL_PREFIX}lv_") if enum_name.startswith("_lv_") else f"{EMUL_PREFIX}{enum_name}"
         return f"{qual_str}{base_name}" # Assume it's defined elsewhere

    if json_type == "struct" or json_type == "union":
         struct_name = type_info.get("name", "anonymous_struct_union")
         base_name = struct_name.replace("_lv_", f"_{EMUL_PREFIX}lv_") if struct_name.startswith("_lv_") else f"{EMUL_PREFIX}{struct_name}"
         # Usually used via pointers, handled above. If by value, needs definition.
         return f"{qual_str}struct {base_name}" # Or just base_name if typedef'd

    if json_type == "typedef":
        # Resolve the underlying type
        return map_type_to_emul(type_info.get("type"), is_return_type, level + 1)

    if json_type == "function_pointer":
         fp_name = type_info.get("name", f"unnamed_func_ptr_{level}")
         base_name = fp_name.replace("_lv_", f"_{EMUL_PREFIX}lv_") if fp_name.startswith("_lv_") else f"{EMUL_PREFIX}{fp_name}"
         return f"{qual_str}{base_name}" # Return the typedef'd name

    if json_type == "ret_type":
        # Extract the actual return type object
        return map_type_to_emul(type_info.get("type"), True, level + 1)

    if json_type == "forward_decl":
        fwd_name = type_info.get("name")
        base_name = fwd_name.replace("_lv_", f"_{EMUL_PREFIX}lv_") if fwd_name.startswith("_lv_") else f"{EMUL_PREFIX}{fwd_name}"
        # Forward declared are often pointers, treat as opaque struct pointer for now
        return f"{qual_str}struct {base_name} *" # Assume pointer usage

    if json_type == "array":
        # C generation for array types in function signatures is complex.
        # Often decays to pointer. Return pointer type for now.
        element_type = map_type_to_emul(type_info.get("type"), is_return_type, level + 1)
        return f"{qual_str}{element_type} *" # Treat as pointer in function args

    if json_type == "special_type" and name == "ellipsis":
        return "..."

    # Fallback for unhandled types
    # print(f"Warning: Unhandled type json_type: {json_type}, name: {name}. Returning void*.")
    return f"{qual_str}void * /* unhandled: {json_type} {name} */"

def get_c_primitive_for_json(c_type_str):
    """Determine the C primitive category for cJSON function calls."""
    c_type_str = c_type_str.strip()
    if "const " in c_type_str:
        c_type_str = c_type_str.replace("const ", "").strip()
    if "struct " in c_type_str:
         c_type_str = c_type_str.replace("struct ", "").strip()
    if "enum " in c_type_str:
         c_type_str = c_type_str.replace("enum ", "").strip()

    # Check for pointers first
    if c_type_str.endswith('*'):
        if c_type_str in ["char *", "const char *"]:
            return "String"
        else:
            # Includes emul_lv_obj_t *, emul_lv_style_t *, void *, other pointers
            return "Pointer" # Needs registration lookup

    # Check for known integer/float types
    if c_type_str in ["int", "short", "long", "long long",
                      "unsigned int", "unsigned short", "unsigned long", "unsigned long long",
                      "int8_t", "uint8_t", "int16_t", "uint16_t",
                      "int32_t", "uint32_t", "int64_t", "uint64_t",
                      "float", "double",
                      "lv_coord_t", # Often int16_t
                      "lv_opa_t", # Often uint8_t
                      # Add lvgl specific integer typedefs if identified as such
                      ] or c_type_str.startswith(f"{EMUL_PREFIX}lv") and c_type_str in enum_names: # Treat enums as numbers
        return "Number"

    if c_type_str == "bool" or c_type_str == "_Bool":
        return "Bool"

    # Assume simple structs passed by value need special object handling if needed
    if c_type_str in [f"{EMUL_PREFIX}lv_color_t", f"{EMUL_PREFIX}lv_point_t"]: # Add more simple structs if defined
        return "Struct"

    # Default or complex types
    # print(f"Warning: Cannot determine cJSON type for C type: {c_type_str}. Defaulting to Pointer/Unknown.")
    return "Unknown" # Needs specific handling or skipping

# --- C Code Generation Functions ---

def generate_header_top(api_data):
    """Generates the top part of the header file."""
    header = f"""\
#ifndef {EMUL_PREFIX.upper()}LVGL_H
#define {EMUL_PREFIX.upper()}LVGL_H

#ifdef __cplusplus
extern "C" {{
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h> // For size_t
#include {CJSON_INCLUDE}

// --- Basic Emulator Types ---

// Opaque structure for the emulated LVGL object
typedef struct {{
    cJSON *json_node;
    uintptr_t id; // Use pointer address as unique ID
}} {EMUL_PREFIX}lv_obj_t;

// Opaque structure for the emulated LVGL style
typedef struct {{
    cJSON *json_node;
    uintptr_t id; // Use pointer address as unique ID
}} {EMUL_PREFIX}lv_style_t;

// --- Basic LVGL Type Definitions (add more as needed) ---
// Define primitive types that LVGL often typedefs, if not directly using stdint.h types
typedef int16_t {EMUL_PREFIX}lv_coord_t;
typedef uint8_t {EMUL_PREFIX}lv_opa_t;
typedef uint32_t {EMUL_PREFIX}lv_color_t; // Simplification - LVGL color can be complex
// typedef struct {{ {EMUL_PREFIX}lv_coord_t x; {EMUL_PREFIX}lv_coord_t y; }} {EMUL_PREFIX}lv_point_t; // Example if needed by value
// typedef struct {{ uint8_t blue; uint8_t green; uint8_t red; uint8_t alpha; }} emul_lv_color32_t; // More complex color example

// Result type (often an enum)
typedef uint8_t {EMUL_PREFIX}lv_res_t; // Simplification, use actual enum below if present
#define {EMUL_PREFIX}LV_RES_OK 0
#define {EMUL_PREFIX}LV_RES_INV 1

// --- Forward Declarations for Structs/Unions (if needed explicitly) ---
"""
    # Add forward declarations from JSON if analysis shows they are necessary
    # for struct in api_data.get("structures", []):
    #     name = struct.get("name")
    #     if name: header += f"struct {EMUL_PREFIX}{name};\n"
    # for union in api_data.get("unions", []):
    #      name = union.get("name")
    #      if name: header += f"union {EMUL_PREFIX}{name};\n"

    header += "\n// --- Enums ---\n"
    return header

def generate_enums(api_data):
    """Generates C enum definitions."""
    code = ""
    global enum_names
    processed_enums = set() # Prevent duplicate typedefs if enum and typedef exist

    # Process typedefs first to identify potential enum typedef names
    for typedef in api_data.get("typedefs", []):
         t_name = typedef.get("name")
         t_type_info = typedef.get("type", {})
         base_type_name = get_base_type_name(t_type_info)
         if t_type_info.get("json_type") == "enum" or (t_type_info.get("json_type") == "lvgl_type" and base_type_name in enum_names):
             # This typedef IS an enum
             base_name = t_name.replace("_lv_", f"_{EMUL_PREFIX}lv_") if t_name.startswith("_lv_") else f"{EMUL_PREFIX}{t_name}"
             enum_names.add(t_name) # Add the original name for mapping lookup
             processed_enums.add(t_name) # Mark as processed
             # We generate the typedef later with the actual enum definition if available
             # code += f"typedef int {base_name}; // Placeholder for enum {t_name}\n"


    # Process enums
    for enum_info in api_data.get("enums", []):
        enum_name = enum_info.get("name") # This might be the internal _lv_..._t name
        typedef_name = enum_info.get("name") # Check if 'name' field implies a typedef name directly
        members = enum_info.get("members", [])

        if not members: continue

        # Determine the name to use for the C enum definition
        c_enum_name = None
        if typedef_name and typedef_name.endswith("_t"): # Good heuristic for typedef name
             c_enum_name = typedef_name.replace("_lv_", f"_{EMUL_PREFIX}lv_") if typedef_name.startswith("_lv_") else f"{EMUL_PREFIX}{typedef_name}"
             enum_names.add(typedef_name) # Register original name
        elif enum_name: # Use the internal name if no clear typedef name
             c_enum_name = enum_name.replace("_lv_", f"_{EMUL_PREFIX}lv_") if enum_name.startswith("_lv_") else f"{EMUL_PREFIX}{enum_name}"
             enum_names.add(enum_name) # Register original name (might be _lv_...)
        else:
             # Try to derive from first member if anonymous
             first_member_name = members[0].get("name", "UNKNOWN_ENUM")
             prefix = first_member_name.split('_')[0] if '_' in first_member_name else "anonymous"
             c_enum_name = f"{EMUL_PREFIX}{prefix}_enum" # Best guess for anonymous


        if not c_enum_name or c_enum_name in processed_enums: continue # Skip if already handled via a typedef or invalid

        processed_enums.add(c_enum_name) # Mark this name as processed

        # Add documentation if available
        doc = enum_info.get("docstring")
        if doc:
            code += f"/**\n * @brief {doc}\n */\n"

        code += f"typedef enum {{\n"
        for member in members:
            m_name = member.get("name")
            m_val = member.get("value")
            m_doc = member.get("docstring")
            if m_name and m_val is not None:
                 m_c_name = m_name.replace("LV_", f"{EMUL_PREFIX}LV_") # Prefix constants
                 code += f"    {m_c_name} = {m_val},"
                 if m_doc:
                      code += f" /**< {m_doc} */"
                 code += "\n"
        code += f"}} {c_enum_name};\n\n"

    # Ensure common LVGL enums are present if missed (example)
    if f"{EMUL_PREFIX}lv_res_t" not in processed_enums:
         code += f"typedef enum {{ {EMUL_PREFIX}LV_RES_OK = 0, {EMUL_PREFIX}LV_RES_INV = 1 }} {EMUL_PREFIX}lv_res_t;\n"
         processed_enums.add(f"{EMUL_PREFIX}lv_res_t")

    return code

def generate_structs_and_typedefs(api_data):
    """Generates necessary struct definitions (if simple) and typedefs."""
    code = "\n// --- Structs & Typedefs ---\n"
    global typedef_map, struct_names, func_ptr_names

    # Pre-scan structs/unions/func_ptrs to know their names
    for s in api_data.get("structures", []): struct_names.add(s.get("name"))
    for u in api_data.get("unions", []): struct_names.add(u.get("name")) # Treat unions like structs for naming
    for fp in api_data.get("function_pointers", []): func_ptr_names.add(fp.get("name"))

    # Generate simple struct definitions needed by value (e.g., lv_color_t)
    # Example: Define emul_lv_color_t based on common understanding or JSON fields if simple enough
    # This part is complex and depends heavily on how structs are used.
    # We defined emul_lv_color_t simply as uint32_t earlier for simplicity.
    # Let's keep it simple for now.
    # Example:
    # code += f"typedef struct {{\n    {EMUL_PREFIX}lv_coord_t x;\n    {EMUL_PREFIX}lv_coord_t y;\n}} {EMUL_PREFIX}lv_point_t;\n\n"

    # Generate typedefs
    for typedef in api_data.get("typedefs", []):
        name = typedef.get("name")
        type_info = typedef.get("type")
        doc = typedef.get("docstring")

        if not name or not type_info: continue

        # Store for later lookup during type mapping
        typedef_map[name] = typedef

        # Skip typedefs for the base emulated types we defined manually
        if name in ["lv_obj_t", "lv_style_t"]: continue
        # Skip typedefs already handled by enum generation
        if name in enum_names: continue

        c_name = name.replace("_lv_", f"_{EMUL_PREFIX}lv_") if name.startswith("_lv_") else f"{EMUL_PREFIX}{name}"
        c_type = map_type_to_emul(type_info)

        # Avoid redundant typedefs like 'typedef int int;'
        if c_name.lower() == c_type.lower().replace("const ", "").strip(): continue
        # Avoid typedefing already prefixed types to themselves
        if c_name == c_type: continue


        if doc: code += f"/** @brief {doc} */\n"

        # Special handling for function pointer typedefs
        if type_info.get("json_type") == "function_pointer" or name in func_ptr_names:
            # Need to reconstruct the full function pointer syntax
            fp_info = next((fp for fp in api_data.get("function_pointers", []) if fp.get("name") == name), None)
            if fp_info:
                 ret_type_info = fp_info.get("type") # This is ret_type object
                 ret_type = map_type_to_emul(ret_type_info)
                 args_code = []
                 args = fp_info.get("args", [])
                 if not args or (len(args) == 1 and get_base_type_name(args[0].get("type")) == "void"):
                      args_code.append("void")
                 else:
                      for arg in args:
                           arg_type = map_type_to_emul(arg.get("type"))
                           arg_name = sanitize_name(arg.get("name"))
                           args_code.append(f"{arg_type} {arg_name}")
                 code += f"typedef {ret_type} (*{c_name})({', '.join(args_code)});\n\n"
            else:
                 code += f"// Could not find function pointer details for {name}\n"
                 code += f"typedef void (*{c_name})(void); // Placeholder\n\n"
        else:
             # Regular typedef
             code += f"typedef {c_type} {c_name};\n\n"

    return code


def generate_function_prototypes(api_data):
    """Generates C function prototypes for the header."""
    code = "\n// --- Emulated LVGL Functions ---\n"
    code += "// --- Management Functions ---\n"
    code += "void emul_lv_init(void);\n"
    code += "void emul_lv_cleanup(void);\n"
    code += "void emul_lv_register_named_pointer(const void *ptr, const char *name);\n"
    code += "char* emul_lvgl_render_to_json(emul_lv_obj_t *root_obj);\n"
    code += "void emul_json_free(char *json_str);\n\n"
    code += "// --- Generated API Functions ---\n"


    for func_info in api_data.get("functions", []):
        func_name = func_info.get("name")
        if not func_name or func_name.startswith("_"): # Skip private functions
             continue

        # Skip memory functions, task/tick handlers, display/input drivers for emulator
        prefixes_to_skip = ["lv_mem_", "lv_ll_", "lv_timer_", "lv_tick_", "lv_disp_", "lv_indev_", "lv_anim_", "lv_group_"]
        if any(func_name.startswith(p) for p in prefixes_to_skip):
            continue

        emul_func_name = func_name.replace("lv_", f"{EMUL_PREFIX}lv_", 1)

        ret_type_info = func_info.get("type") # This is the 'ret_type' object
        ret_type = map_type_to_emul(ret_type_info)

        args = func_info.get("args", [])
        args_code = []

        if not args or (len(args) == 1 and get_base_type_name(args[0].get("type")) == "void"):
            args_code.append("void")
        else:
            for arg in args:
                arg_type_info = arg.get("type")
                arg_type = map_type_to_emul(arg_type_info)
                arg_name = sanitize_name(arg.get("name"))

                # Handle ellipsis (...)
                if arg_type == "...":
                     args_code.append("...")
                     break # Ellipsis must be the last argument

                # Handle unnamed arguments
                if not arg_name or arg_name == "_unnamed_":
                     # Find a unique placeholder if needed, or just use type
                     base_type_guess = get_base_type_name(arg_type_info).lower()
                     arg_name = f"p_{base_type_guess}" if "pointer" in arg_type_info.get("json_type","") else f"val_{base_type_guess}"
                     # Make arg_name somewhat unique if multiple unnamed
                     count = sum(1 for a in args_code if a.split()[-1].startswith(arg_name))
                     if count > 0: arg_name = f"{arg_name}{count}"


                args_code.append(f"{arg_type} {arg_name}")

        code += f"{ret_type} {emul_func_name}({', '.join(args_code)});\n"

    return code

def generate_header_bottom():
    """Generates the bottom part of the header file."""
    return """
#ifdef __cplusplus
}} /*extern "C"*/
#endif

#endif /* {EMUL_PREFIX.upper}LVGL_H */
""".format(EMUL_PREFIX=EMUL_PREFIX)

def generate_source_top():
    """Generates the top part of the source file."""
    return f"""\
#include "{HEADER_FILENAME}"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h> // For PRIxPTR

// --- Global State for Emulator ---

// Simple linked list for pointer name registration
typedef struct NamedPtr {{
    const void *ptr;
    const char *name;
    struct NamedPtr *next;
}} NamedPtr_t;

static NamedPtr_t *g_named_pointers = NULL;
static cJSON *g_virtual_dom_root = NULL; // Store all objects under a root for cleanup
static bool g_emul_initialized = false;

// Simple counter for unique style IDs if needed
static uintptr_t g_style_id_counter = 0;

// --- Helper Functions ---

// Get registered name or create a placeholder string (like "ptr_0x...")
static const char* get_pointer_name(const void *ptr) {{
    if (!ptr) return "null";

    NamedPtr_t *current = g_named_pointers;
    while (current) {{
        if (current->ptr == ptr) {{
            return current->name;
        }}
        current = current->next;
    }}

    // Not found, create a placeholder name string (caller must NOT free this)
    // WARNING: This is not thread-safe and uses a static buffer.
    // For simplicity in this example. A better approach would allocate memory.
    static char placeholder_name[32];
    snprintf(placeholder_name, sizeof(placeholder_name), "ptr_0x%" PRIxPTR, (uintptr_t)ptr);
    return placeholder_name;
}}

// Find cJSON node associated with an emulated object/style ID
static cJSON* find_json_node_by_id(uintptr_t id) {{
    if (!g_virtual_dom_root) return NULL;
    // Search in objects
    cJSON *objects = cJSON_GetObjectItemCaseSensitive(g_virtual_dom_root, "objects");
    if (objects) {{
        cJSON *obj_node = NULL;
        cJSON_ArrayForEach(obj_node, objects) {{
            cJSON *id_item = cJSON_GetObjectItemCaseSensitive(obj_node, "id");
            if (id_item && cJSON_IsNumber(id_item) && (uintptr_t)id_item->valuedouble == id) {{
                return obj_node;
            }}
        }}
    }}
    // Search in styles
    cJSON *styles = cJSON_GetObjectItemCaseSensitive(g_virtual_dom_root, "styles");
    if (styles) {{
        cJSON *style_node = NULL;
        cJSON_ArrayForEach(style_node, styles) {{
             cJSON *id_item = cJSON_GetObjectItemCaseSensitive(style_node, "id");
             if (id_item && cJSON_IsNumber(id_item) && (uintptr_t)id_item->valuedouble == id) {{
                 return style_node;
             }}
        }}
    }}
    return NULL;
}}

// Add or update a property on a cJSON node
static void set_json_property(cJSON *node, const char *key, cJSON *value_item) {{
    if (!node || !key || !value_item) return;
    if (cJSON_HasObjectItem(node, key)) {{
        cJSON_ReplaceItemInObjectCaseSensitive(node, key, value_item);
    }} else {{
        cJSON_AddItemToObject(node, key, value_item);
    }}
}}

// Serialize simple struct (e.g., color) to JSON - Add more as needed
/* Example:
static cJSON* serialize_color({EMUL_PREFIX}lv_color_t color) {{
    // Assuming color is uint32_t RGBA for simplicity
    cJSON *color_obj = cJSON_CreateObject();
    // This depends heavily on the actual format of lv_color_t
    // cJSON_AddNumberToObject(color_obj, "r", (color >> 24) & 0xFF);
    // cJSON_AddNumberToObject(color_obj, "g", (color >> 16) & 0xFF);
    // cJSON_AddNumberToObject(color_obj, "b", (color >> 8) & 0xFF);
    // cJSON_AddNumberToObject(color_obj, "a", color & 0xFF);
    // Simpler: store raw value
    cJSON_AddNumberToObject(color_obj, "raw", color);
    return color_obj;
}}
*/

// --- Management Function Implementations ---

void {EMUL_PREFIX}lv_init(void) {{
    if (g_emul_initialized) return;
    g_virtual_dom_root = cJSON_CreateObject();
    cJSON_AddItemToObject(g_virtual_dom_root, "objects", cJSON_CreateArray());
    cJSON_AddItemToObject(g_virtual_dom_root, "styles", cJSON_CreateArray());
    // Initialize other subsystems if needed
    g_emul_initialized = true;
    // printf("emul_lvgl initialized.\\n");
}}

void {EMUL_PREFIX}lv_cleanup(void) {{
    if (!g_emul_initialized) return;
    // Free named pointers list
    NamedPtr_t *current = g_named_pointers;
    while (current) {{
        NamedPtr_t *next = current->next;
        // Note: We assume the 'name' string is owned elsewhere (e.g., string literal)
        // If names were allocated, free them here: free((void*)current->name);
        free(current);
        current = next;
    }}
    g_named_pointers = NULL;

    // Free cJSON DOM
    if (g_virtual_dom_root) {{
        cJSON_Delete(g_virtual_dom_root);
        g_virtual_dom_root = NULL;
    }}
    g_style_id_counter = 0;
    g_emul_initialized = false;
    // printf("emul_lvgl cleaned up.\\n");
}}

void {EMUL_PREFIX}lv_register_named_pointer(const void *ptr, const char *name) {{
    if (!ptr || !name) return;

    // Check if pointer is already registered, update name if so
    NamedPtr_t *current = g_named_pointers;
    while(current) {{
        if (current->ptr == ptr) {{
            current->name = name; // Assume name is static or managed elsewhere
            return;
        }}
        current = current->next;
    }}

    // Add new registration
    NamedPtr_t *new_reg = (NamedPtr_t*)malloc(sizeof(NamedPtr_t));
    if (!new_reg) {{
        fprintf(stderr, "Error: Failed to allocate memory for pointer registration.\\n");
        return;
    }}
    new_reg->ptr = ptr;
    new_reg->name = name; // Store the pointer to the name string
    new_reg->next = g_named_pointers;
    g_named_pointers = new_reg;
}}

// Render the state of a specific object and its children (recursive)
// Helper for render_to_json
static cJSON* build_object_json_recursive(emul_lv_obj_t *obj) {{
    if (!obj || !obj->json_node) return NULL;

    // Create a deep copy to avoid modifying the internal state representation directly
    // (if render modifies structure, e.g. adding runtime info not in base node)
    // Alternatively, just return the node if rendering is read-only.
    // Let's assume read-only for now.
    cJSON *obj_json_copy = cJSON_Duplicate(obj->json_node, true); // Deep copy

    // Find children in the original structure and recursively build their JSON
    cJSON *children_array = cJSON_GetObjectItemCaseSensitive(obj->json_node, "children");
    cJSON *children_copy_array = cJSON_CreateArray(); // Create new children array for the copy

    if (children_array && cJSON_IsArray(children_array)) {{
        cJSON *child_ref;
        cJSON_ArrayForEach(child_ref, children_array) {{
             if (cJSON_IsNumber(child_ref)) {{ // Assuming children stores IDs
                 uintptr_t child_id = (uintptr_t)child_ref->valuedouble;
                 cJSON *child_node = find_json_node_by_id(child_id);
                 if (child_node) {{
                     // Fake an emul_lv_obj_t to pass to recursive call
                     emul_lv_obj_t fake_child_obj;
                     fake_child_obj.json_node = child_node;
                     fake_child_obj.id = child_id;
                     cJSON *child_json = build_object_json_recursive(&fake_child_obj);
                     if (child_json) {{
                         cJSON_AddItemToArray(children_copy_array, child_json);
                     }}
                 }}
             }}
        }}
    }}

    // Replace or add the children array in the copied JSON
    if (cJSON_HasObjectItem(obj_json_copy, "children")) {{
         cJSON_ReplaceItemInObjectCaseSensitive(obj_json_copy, "children", children_copy_array);
    }} else {{
         cJSON_AddItemToObject(obj_json_copy, "children", children_copy_array);
    }}


    return obj_json_copy;
}}


char* {EMUL_PREFIX}lvgl_render_to_json({EMUL_PREFIX}lv_obj_t *root_obj) {{
    if (!g_emul_initialized || !root_obj || !root_obj->json_node) {{
        return cJSON_Print(cJSON_CreateObject()); // Return empty JSON object"{{}}"
    }}

    // Build the JSON structure starting from the root_obj recursively
    cJSON *output_json = build_object_json_recursive(root_obj);

    if (!output_json) {{
         output_json = cJSON_CreateObject(); // Return empty if build fails
    }}

    // Add registered styles to the output for context? Optional.
    // cJSON *styles = cJSON_GetObjectItemCaseSensitive(g_virtual_dom_root, "styles");
    // if (styles) {{
    //    cJSON_AddItemToObject(output_json, "referenced_styles", cJSON_Duplicate(styles, true));
    // }}

    char *json_string = cJSON_PrintUnformatted(output_json); // Or cJSON_Print for formatted
    cJSON_Delete(output_json); // Free the temporary JSON structure

    return json_string; // Caller must free this string using emul_json_free
}}

void {EMUL_PREFIX}json_free(char *json_str) {{
    if (json_str) {{
        cJSON_free(json_str);
    }}
}}

// --- Generated Function Implementations ---
"""

def generate_function_implementation(func_info, all_enums):
    """Generates the C implementation for a single function."""
    func_name = func_info.get("name")
    if not func_name or func_name.startswith("_"): return "" # Skip private
    # Skip functions we don't want to emulate
    prefixes_to_skip = ["lv_mem_", "lv_ll_", "lv_timer_", "lv_tick_", "lv_disp_", "lv_indev_", "lv_anim_", "lv_group_"]
    if any(func_name.startswith(p) for p in prefixes_to_skip):
        return f"// Skipped function: {func_name}\n"

    emul_func_name = func_name.replace("lv_", f"{EMUL_PREFIX}lv_", 1)

    ret_type_info = func_info.get("type") # This is the 'ret_type' object
    ret_type = map_type_to_emul(ret_type_info)

    args = func_info.get("args", [])
    args_code = []
    arg_names = []
    arg_infos = []

    if not args or (len(args) == 1 and get_base_type_name(args[0].get("type")) == "void"):
        args_code.append("void")
    else:
        for i, arg in enumerate(args):
            arg_type_info = arg.get("type")
            arg_type = map_type_to_emul(arg_type_info)
            arg_name = sanitize_name(arg.get("name"))

            if arg_type == "...":
                 args_code.append("...")
                 arg_names.append("...")
                 arg_infos.append({"name": "...", "type": "...", "json_type": "special_type"})
                 break # Ellipsis must be last

            if not arg_name or arg_name == "_unnamed_":
                base_type_guess = get_base_type_name(arg_type_info).lower()
                arg_name = f"p_{base_type_guess}" if "pointer" in arg_type_info.get("json_type","") else f"val_{base_type_guess}"
                count = sum(1 for a in args_code if a.split()[-1].startswith(arg_name))
                if count > 0: arg_name = f"{arg_name}{count}"


            args_code.append(f"{arg_type} {arg_name}")
            arg_names.append(arg_name)
            arg_infos.append({"name": arg_name, "type_str": arg_type, "type_info": arg_type_info})

    impl = f"{ret_type} {emul_func_name}({', '.join(args_code)}) {{\n"
    impl += "    if (!g_emul_initialized) { printf(\"Warning: emul_lvgl not initialized!\\n\"); "
    # Add default return for uninitialized state
    default_ret = DEFAULT_RETURN_MAP.get(ret_type, "return; /* default void */")
    if ret_type.endswith("*"): default_ret = "return NULL;"
    if ret_type == 'void': default_ret = "return;"
    impl += f"{default_ret} }}\n\n"


    # --- Function Body Generation ---

    # Object/Style Creation (heuristic: function name contains "create" or "init")
    is_create_func = "create" in func_name
    is_style_init_func = func_name == "lv_style_init"
    target_obj_arg = None
    target_style_arg = None

    # Find the target object/style argument (usually the first argument)
    if len(arg_infos) > 0:
        first_arg_type = arg_infos[0]["type_str"]
        if first_arg_type == f"{EMUL_PREFIX}lv_obj_t *":
            target_obj_arg = arg_infos[0]["name"]
        elif first_arg_type == f"{EMUL_PREFIX}lv_style_t *":
             target_style_arg = arg_infos[0]["name"]


    if is_create_func and ret_type == f"{EMUL_PREFIX}lv_obj_t *":
        # --- Object Creation Logic ---
        impl += f"    // --- Object Creation: {func_name} ---\n"
        impl += f"    {EMUL_PREFIX}lv_obj_t *obj = ({EMUL_PREFIX}lv_obj_t *)malloc(sizeof({EMUL_PREFIX}lv_obj_t));\n"
        impl += f"    if (!obj) {{ fprintf(stderr, \"Error: Failed malloc for emul_lv_obj_t\\n\"); return NULL; }}\n"
        impl += f"    obj->id = (uintptr_t)obj;\n" # Use pointer as ID
        impl += f"    obj->json_node = cJSON_CreateObject();\n"
        impl += f"    if (!obj->json_node) {{ fprintf(stderr, \"Error: Failed cJSON_CreateObject\\n\"); free(obj); return NULL; }}\n\n"
        impl += f"    set_json_property(obj->json_node, \"id\", cJSON_CreateNumber((double)obj->id));\n"
        # Extract widget type from function name (e.g., lv_label_create -> label)
        widget_type = "obj"
        match = re.match(r"lv_(\w+)_create", func_name)
        if match: widget_type = match.group(1)
        impl += f"    set_json_property(obj->json_node, \"type\", cJSON_CreateString(\"{widget_type}\"));\n"
        impl += f"    set_json_property(obj->json_node, \"properties\", cJSON_CreateObject());\n"
        impl += f"    set_json_property(obj->json_node, \"styles\", cJSON_CreateArray());\n"
        impl += f"    set_json_property(obj->json_node, \"children\", cJSON_CreateArray());\n\n"

        # Add to global list and link to parent if applicable
        impl += f"    cJSON *objects = cJSON_GetObjectItemCaseSensitive(g_virtual_dom_root, \"objects\");\n"
        impl += f"    if (objects) cJSON_AddItemToArray(objects, cJSON_Duplicate(obj->json_node, false)); // Add shallow copy to root list\n\n" # Store basic ref in root

        parent_arg_name = None
        if len(arg_infos) > 0 and arg_infos[0]["type_str"] == f"{EMUL_PREFIX}lv_obj_t *":
            parent_arg_name = arg_infos[0]["name"]

        if parent_arg_name:
            impl += f"    if ({parent_arg_name} && {parent_arg_name}->json_node) {{\n"
            impl += f"        cJSON *parent_children = cJSON_GetObjectItemCaseSensitive({parent_arg_name}->json_node, \"children\");\n"
            impl += f"        if (!parent_children) {{\n"
            impl += f"            parent_children = cJSON_CreateArray();\n"
            impl += f"            set_json_property({parent_arg_name}->json_node, \"children\", parent_children);\n"
            impl += f"        }}\n"
            impl += f"        if (cJSON_IsArray(parent_children)) {{\n"
            impl += f"            cJSON_AddItemToArray(parent_children, cJSON_CreateNumber((double)obj->id)); // Add child ID to parent\n"
            impl += f"        }}\n"
            # Store parent ID in child object as well? Optional.
            impl += f"        set_json_property(obj->json_node, \"parent_id\", cJSON_CreateNumber((double){parent_arg_name}->id));\n"
            impl += f"    }}\n\n"

        impl += f"    // Add initial properties set during creation (if any arguments besides parent)\n"
        prop_obj_json = "cJSON_GetObjectItemCaseSensitive(obj->json_node, \"properties\")"
        start_index = 1 if parent_arg_name else 0
        for i in range(start_index, len(arg_infos)):
             arg = arg_infos[i]
             arg_name = arg["name"]
             arg_type_str = arg["type_str"]
             prop_name = arg_name # Use arg name as property name heuristic
             json_type = get_c_primitive_for_json(arg_type_str)

             if json_type == "Number":
                 impl += f"    set_json_property({prop_obj_json}, \"{prop_name}\", cJSON_CreateNumber((double){arg_name}));\n"
             elif json_type == "String":
                 impl += f"    set_json_property({prop_obj_json}, \"{prop_name}\", cJSON_CreateString({arg_name} ? {arg_name} : \"\"));\n"
             elif json_type == "Bool":
                 impl += f"    set_json_property({prop_obj_json}, \"{prop_name}\", cJSON_CreateBool({arg_name}));\n"
             elif json_type == "Pointer":
                 impl += f"    set_json_property({prop_obj_json}, \"{prop_name}\", cJSON_CreateString(get_pointer_name({arg_name})));\n"
             # Add Struct handling if needed
             # else: impl += f"    // Property {prop_name} type {arg_type_str} not handled for creation\n"


        impl += f"    return obj;\n"

    elif is_style_init_func:
         # --- Style Initialization Logic ---
         impl += f"    // --- Style Creation: {func_name} ---\n"
         impl += f"    {EMUL_PREFIX}lv_style_t *style = ({EMUL_PREFIX}lv_style_t *)malloc(sizeof({EMUL_PREFIX}lv_style_t));\n"
         impl += f"    if (!style) {{ fprintf(stderr, \"Error: Failed malloc for emul_lv_style_t\\n\"); return; }}\n"
         # Potentially use a counter for style IDs instead of address if styles are heavily reused/copied
         #impl += f"   style->id = ++g_style_id_counter;"
         impl += f"    style->id = (uintptr_t)style;" # Use pointer address as ID for simplicity
         impl += f"    style->id = (uintptr_t)style;\n"
         impl += f"    style->json_node = cJSON_CreateObject();\n"
         impl += f"    if (!style->json_node) {{ fprintf(stderr, \"Error: Failed cJSON_CreateObject\\n\"); free(style); return; }}\n\n"
         impl += f"    set_json_property(style->json_node, \"id\", cJSON_CreateNumber((double)style->id));\n"
         impl += f"    set_json_property(style->json_node, \"properties\", cJSON_CreateObject());\n\n"
         # Add to global list
         impl += f"    cJSON *styles = cJSON_GetObjectItemCaseSensitive(g_virtual_dom_root, \"styles\");\n"
         impl += f"    if (styles) cJSON_AddItemToArray(styles, cJSON_Duplicate(style->json_node, false)); // Add shallow copy to root list\n\n" # Store basic ref in root

         # Assign the created style to the input argument pointer
         impl += f"    if ({target_style_arg}) *{target_style_arg} = *style; // Copy struct content\n"
         impl += f"    free(style); // Free temporary allocation, user manages the one pointed to by arg\n"
         # OR: Requires style arg to be lv_style_t * style, not lv_style_t * style_p
         # *style_p = style; // caller owns pointer

         # Let's assume the API is lv_style_init(lv_style_t * style)
         # where the user provides the memory.
         # So we initialize the fields of the provided pointer.
         impl = f"{ret_type} {emul_func_name}({', '.join(args_code)}) {{\n" # Restart impl
         impl += "    if (!g_emul_initialized) { /* ... */ return; }\n"
         impl += f"    if (!{target_style_arg}) return;\n\n"
         impl += f"    // --- Style Initialization: {func_name} ---\n"
         impl += f"    {target_style_arg}->id = (uintptr_t){target_style_arg}; // Use pointer address given by user\n"
         impl += f"    {target_style_arg}->json_node = cJSON_CreateObject();\n"
         impl += f"    if (!{target_style_arg}->json_node) {{ fprintf(stderr, \"Error: Failed cJSON_CreateObject\\n\"); return; }}\n\n"
         impl += f"    set_json_property({target_style_arg}->json_node, \"id\", cJSON_CreateNumber((double){target_style_arg}->id));\n"
         impl += f"    set_json_property({target_style_arg}->json_node, \"properties\", cJSON_CreateObject());\n\n"
         # Add to global list
         impl += f"    cJSON *styles = cJSON_GetObjectItemCaseSensitive(g_virtual_dom_root, \"styles\");\n"
         impl += f"    if (styles) {{\n"
         impl += f"        // Avoid adding duplicates if init is called multiple times on same style ptr\n"
         impl += f"        cJSON *existing = find_json_node_by_id({target_style_arg}->id);\n"
         impl += f"        if (existing) cJSON_Delete(existing); // Remove old one if re-initializing\n"
         impl += f"        cJSON_AddItemToArray(styles, {target_style_arg}->json_node);\n"
         impl += f"    }}\n"
         # No return for void function


    elif target_obj_arg and func_name.startswith("lv_obj_set_"):
        # --- Object Property Setting ---
        impl += f"    // --- Object Property Set: {func_name} ---\n"
        impl += f"    if (!{target_obj_arg} || !{target_obj_arg}->json_node) {{ {default_ret} }}\n"
        impl += f"    cJSON *props = cJSON_GetObjectItemCaseSensitive({target_obj_arg}->json_node, \"properties\");\n"
        impl += f"    if (!props) {{ props = cJSON_CreateObject(); set_json_property({target_obj_arg}->json_node, \"properties\", props); }}\n"

        # Heuristic: property name is based on function name suffix
        prop_name_snake = func_name.replace(f"lv_obj_set_", "", 1)

        if len(arg_infos) > 1: # First arg is obj, second is usually the value
             val_arg = arg_infos[1]
             val_arg_name = val_arg["name"]
             val_arg_type_str = val_arg["type_str"]
             json_type = get_c_primitive_for_json(val_arg_type_str)

             if json_type == "Number":
                  # Special case for flags/state? lv_obj_add_flag, lv_obj_clear_flag
                 if func_name.startswith("lv_obj_add_flag") or func_name.startswith("lv_obj_add_state"):
                       impl += f"    // TODO: Handle state/flag addition (bitwise OR)\n"
                       impl += f"    set_json_property(props, \"{prop_name_snake}\", cJSON_CreateNumber((double){val_arg_name})); // Overwrite for now\n"
                 elif func_name.startswith("lv_obj_clear_flag") or func_name.startswith("lv_obj_clear_state"):
                       impl += f"    // TODO: Handle state/flag clearing (bitwise AND NOT)\n"
                       impl += f"    set_json_property(props, \"{prop_name_snake}\", cJSON_CreateNumber((double){val_arg_name})); // Placeholder to show arg\n"
                 else:
                      impl += f"    set_json_property(props, \"{prop_name_snake}\", cJSON_CreateNumber((double){val_arg_name}));\n"
             elif json_type == "String":
                 impl += f"    set_json_property(props, \"{prop_name_snake}\", cJSON_CreateString({val_arg_name} ? {val_arg_name} : \"\"));\n"
             elif json_type == "Bool":
                 impl += f"    set_json_property(props, \"{prop_name_snake}\", cJSON_CreateBool({val_arg_name}));\n"
             elif json_type == "Pointer":
                 # Could be font, image, user_data, another obj/style etc.
                 impl += f"    set_json_property(props, \"{prop_name_snake}\", cJSON_CreateString(get_pointer_name({val_arg_name})));\n"
             elif json_type == "Struct":
                 # Need specific handlers per struct type
                 if val_arg_type_str == f"{EMUL_PREFIX}lv_color_t":
                      # Simplification: Assume color is uint32_t, store number
                      impl += f"    set_json_property(props, \"{prop_name_snake}\", cJSON_CreateNumber((double){val_arg_name}));\n"
                      # Or use serialize_color helper if defined:
                      # impl += f" set_json_property(props, \"{prop_name_snake}\", serialize_color({val_arg_name}));\n"
                 else:
                      impl += f"    // Struct property {prop_name_snake} type {val_arg_type_str} not handled\n"
             else: # Unknown
                  impl += f"    // Property '{prop_name_snake}' type {val_arg_type_str} ({json_type}) not automatically handled.\n"
        else:
            impl += f"    // Could not determine value argument for {func_name}.\n"
        impl += f"    {default_ret}\n"

    elif target_style_arg and func_name.startswith("lv_style_set_"):
        # --- Style Property Setting ---
        impl += f"    // --- Style Property Set: {func_name} ---\n"
        impl += f"    if (!{target_style_arg} || !{target_style_arg}->json_node) {{ {default_ret} }}\n"
        impl += f"    cJSON *props = cJSON_GetObjectItemCaseSensitive({target_style_arg}->json_node, \"properties\");\n"
        impl += f"    if (!props) {{ props = cJSON_CreateObject(); set_json_property({target_style_arg}->json_node, \"properties\", props); }}\n"

        prop_name_snake = func_name.replace(f"lv_style_set_", "", 1)
        # State might be the last argument for styles, value is usually second
        val_arg_index = 1
        # state_arg_index = -1 # Potentially check last arg for lv_state_t

        if len(arg_infos) > val_arg_index:
             val_arg = arg_infos[val_arg_index]
             val_arg_name = val_arg["name"]
             val_arg_type_str = val_arg["type_str"]
             json_type = get_c_primitive_for_json(val_arg_type_str)

             # Note: Style properties often depend on state. We are simplifying here
             # by not handling state explicitly in the property name/storage.
             # A better model would nest properties under state keys.

             if json_type == "Number":
                  impl += f"    set_json_property(props, \"{prop_name_snake}\", cJSON_CreateNumber((double){val_arg_name}));\n"
             elif json_type == "String":
                 impl += f"    set_json_property(props, \"{prop_name_snake}\", cJSON_CreateString({val_arg_name} ? {val_arg_name} : \"\"));\n"
             elif json_type == "Bool":
                 impl += f"    set_json_property(props, \"{prop_name_snake}\", cJSON_CreateBool({val_arg_name}));\n"
             elif json_type == "Pointer":
                 impl += f"    set_json_property(props, \"{prop_name_snake}\", cJSON_CreateString(get_pointer_name({val_arg_name})));\n"
             elif json_type == "Struct":
                  if val_arg_type_str == f"{EMUL_PREFIX}lv_color_t":
                       impl += f"    set_json_property(props, \"{prop_name_snake}\", cJSON_CreateNumber((double){val_arg_name})); // Store raw color value\n"
                  else:
                       impl += f"    // Struct property {prop_name_snake} type {val_arg_type_str} not handled\n"
             else: # Unknown
                 impl += f"    // Property '{prop_name_snake}' type {val_arg_type_str} ({json_type}) not automatically handled.\n"

        else:
             impl += f"    // Could not determine value argument for {func_name}.\n"

        impl += f"    {default_ret}\n"

    elif target_obj_arg and ("add_style" in func_name or "remove_style" in func_name):
        # --- Style Application/Removal ---
        impl += f"    // --- Object Style Add/Remove: {func_name} ---\n"
        impl += f"    if (!{target_obj_arg} || !{target_obj_arg}->json_node) {{ {default_ret} }}\n"
        impl += f"    cJSON *obj_styles = cJSON_GetObjectItemCaseSensitive({target_obj_arg}->json_node, \"styles\");\n"
        impl += f"    if (!obj_styles) {{ obj_styles = cJSON_CreateArray(); set_json_property({target_obj_arg}->json_node, \"styles\", obj_styles); }}\n"

        style_arg = None
        selector_arg = None # Usually lv_part_t | lv_state_t
        if len(arg_infos) > 1 and arg_infos[1]["type_str"] == f"{EMUL_PREFIX}lv_style_t *":
             style_arg = arg_infos[1]
        if len(arg_infos) > 2 : # Heuristic: selector is often the 3rd arg
             selector_arg = arg_infos[2]

        if style_arg:
            style_ptr_name = style_arg["name"]
            impl += f"    if (!{style_ptr_name}) {{ {default_ret} }} // Null style ptr\n"
            style_id_num = f"(double){style_ptr_name}->id"

            if "add_style" in func_name:
                impl += f"    // Simplification: Add style ID to the object's list of styles.\n"
                impl += f"    // A real implementation needs selector (part|state).\n"
                # Create a simple representation: { "style_id": id, "selector": value }
                impl += f"    cJSON* style_ref = cJSON_CreateObject();\n"
                impl += f"    cJSON_AddNumberToObject(style_ref, \"style_id\", {style_id_num});\n"
                if selector_arg:
                     impl += f"    cJSON_AddNumberToObject(style_ref, \"selector\", (double){selector_arg['name']});\n"
                else:
                     impl += f"    cJSON_AddNumberToObject(style_ref, \"selector\", 0); // Default selector\n"

                impl += f"    // TODO: Avoid adding duplicate style refs?\n"
                impl += f"    if (cJSON_IsArray(obj_styles)) cJSON_AddItemToArray(obj_styles, style_ref);\n"

            elif "remove_style" in func_name:
                impl += f"    // Simplification: Remove style ID reference.\n"
                impl += f"    // A real implementation needs selector (part|state).\n"
                impl += f"    if (cJSON_IsArray(obj_styles)) {{\n"
                impl += f"        int i = 0;\n"
                impl += f"        cJSON *item = NULL;\n"
                impl += f"        cJSON_ArrayForEach(item, obj_styles) {{\n"
                impl += f"            cJSON* id_item = cJSON_GetObjectItemCaseSensitive(item, \"style_id\");\n"
                # Compare selector as well if available
                selector_match = "true";
                if selector_arg:
                    selector_match = f"(sel_item && cJSON_IsNumber(sel_item) && (uint32_t)sel_item->valuedouble == (uint32_t){selector_arg['name']})"
                    impl += f"            cJSON* sel_item = cJSON_GetObjectItemCaseSensitive(item, \"selector\");\n"

                impl += f"            if (id_item && cJSON_IsNumber(id_item) && (uintptr_t)id_item->valuedouble == (uintptr_t){style_ptr_name}->id && {selector_match}) {{\n"
                impl += f"                cJSON_DeleteItemFromArray(obj_styles, i);\n"
                impl += f"                break; // Assume only one instance per ID/selector combo\n"
                impl += f"            }}\n"
                impl += f"            i++;\n"
                impl += f"        }}\n"
                impl += f"    }}\n"
        else:
            impl += f"    // Could not determine style argument for {func_name}\n"

        impl += f"    {default_ret}\n"

    elif func_name == "lv_obj_del" and target_obj_arg:
        # --- Object Deletion ---
        impl += f"    // --- Object Deletion: {func_name} ---\n"
        impl += f"    if (!{target_obj_arg} || !{target_obj_arg}->json_node) {{ return; }}\n"
        impl += f"    // TODO: Implement proper deletion:\n"
        impl += f"    // 1. Recursively delete children.\n"
        impl += f"    // 2. Remove object's JSON node from parent's children array.\n"
        impl += f"    // 3. Remove object's JSON node from the global 'objects' list.\n"
        impl += f"    // 4. Free the emul_lv_obj_t struct itself.\n"
        impl += f"    // Simplification: Just mark as deleted or do nothing.\n"
        impl += f"    set_json_property({target_obj_arg}->json_node, \"deleted\", cJSON_CreateTrue());\n"
        impl += f"    // Maybe free the C struct? But leaves dangling pointers if referenced elsewhere."
        # impl += f"    // free({target_obj_arg}); // Risky if pointer is still used\n"
        impl += f"    return;\n"

    elif func_name == "lv_style_reset" and target_style_arg:
         # --- Style Reset ---
         impl += f"    // --- Style Reset: {func_name} ---\n"
         impl += f"    if (!{target_style_arg} || !{target_style_arg}->json_node) {{ return; }}\n"
         impl += f"    // Replace properties object with a new empty one\n"
         impl += f"    set_json_property({target_style_arg}->json_node, \"properties\", cJSON_CreateObject());\n"
         impl += f"    return;\n"


    # --- Default/Getter Handling ---
    else:
        # Assume it's a getter or unhandled function
        impl += f"    // --- Default/Getter/Unhandled: {func_name} ---\n"
        if ret_type != "void":
            # Try to find a sensible default
            ret_default = DEFAULT_RETURN_MAP.get(ret_type)
            if ret_default:
                impl += f"    {ret_default}\n"
            elif ret_type.endswith("*"): # Pointers default to NULL
                 impl += f"    return NULL;\n"
            else: # Other types default to 0/false (might need refinement)
                 impl += f"    return ({ret_type})0;\n"
        else: # Void function
             impl += f"    return;\n"


    impl += "}\n\n"
    return impl

def generate_source_bottom():
    """Generates the bottom part of the source file."""
    return "// --- End of Generated Source ---\n"

# --- Main Script Logic ---

def main():
    parser = argparse.ArgumentParser(description="Generate emul_lvgl C library from LVGL JSON API.")
    parser.add_argument("-j", "--json-path", required=True, help="Path to the input LVGL API JSON file.")
    parser.add_argument("-o", "--output-dir", required=True, help="Directory to save the generated emul_lvgl.h and emul_lvgl.c files.")
    args = parser.parse_args()

    # Create output directory if it doesn't exist
    os.makedirs(args.output_dir, exist_ok=True)

    # Load the JSON data
    try:
        with open(args.json_path, 'r') as f:
            api_data = json.load(f)
    except Exception as e:
        print(f"Error loading JSON file {args.json_path}: {e}")
        return

    print("Generating emul_lvgl library...")

    # --- Pre-process and Analyze Types ---
    # Populate typedef_map and identify enum/struct names first
    all_enums = set()
    for enum_info in api_data.get("enums", []):
        name = enum_info.get("name")
        if name: all_enums.add(name)
        for member in enum_info.get("members", []):
             m_type = member.get("type")
             if m_type and m_type.get("json_type") == "lvgl_type":
                 all_enums.add(m_type.get("name")) # Register enum type name from members

    for typedef in api_data.get("typedefs", []):
         name = typedef.get("name")
         if name: typedef_map[name] = typedef

    # --- Generate Header File ---
    header_path = os.path.join(args.output_dir, HEADER_FILENAME)
    print(f"Generating {header_path}...")
    try:
        with open(header_path, 'w') as f:
            f.write(generate_header_top(api_data))
            f.write(generate_enums(api_data)) # Generate enums first
            f.write(generate_structs_and_typedefs(api_data)) # Then structs/typedefs
            f.write(generate_function_prototypes(api_data))
            f.write(generate_header_bottom())
        print(f"Successfully generated {header_path}")
    except Exception as e:
        print(f"Error writing header file {header_path}: {e}")
        import traceback
        traceback.print_exc()
        return

    # --- Generate Source File ---
    source_path = os.path.join(args.output_dir, SOURCE_FILENAME)
    print(f"Generating {source_path}...")
    try:
        with open(source_path, 'w') as f:
            f.write(generate_source_top())
            # Generate implementations
            for func_info in api_data.get("functions", []):
                 f.write(generate_function_implementation(func_info, all_enums))
            f.write(generate_source_bottom())
        print(f"Successfully generated {source_path}")
    except Exception as e:
        print(f"Error writing source file {source_path}: {e}")
        import traceback
        traceback.print_exc()
        return

    print("emul_lvgl generation complete.")
    print(f"Remember to link against the cJSON library when compiling {SOURCE_FILENAME}.")

if __name__ == "__main__":
    main()
