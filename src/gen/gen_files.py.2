import json
import os
import re

# --- Configuration ---
INPUT_JSON = 'lv_def.json'
OUTPUT_DIR = 'emul_lvgl'
EMU_HEADER = os.path.join(OUTPUT_DIR, 'emul_lvgl.h')
EMU_SOURCE = os.path.join(OUTPUT_DIR, 'emul_lvgl.c')
BUILDER_HEADER = os.path.join(OUTPUT_DIR, 'ui_builder.h')
BUILDER_SOURCE = os.path.join(OUTPUT_DIR, 'ui_builder.c')

# --- Type Mappings ---
# Map JSON types to C types for the emulator header
TYPE_MAP_EMU_HEADER = {
    "int": "int32_t",
    "bool": "bool",
    "float": "float", # Assuming float is used, though often int in LVGL
    "char*": "const char*",
    "void*": "void*",
    "NoneType": "void",
    "lv_obj_t*": "lv_obj_t *",
    "lv_obj_t": "lv_obj_t *", # Treat lv_obj_t return as pointer too
    "color_t": "lv_color_t",
    "color32_t": "lv_color32_t",
    "font_t": "const lv_font_t *",
    "point_t": "lv_point_t",
    "area_t": "lv_area_t",
    "timer_t": "lv_timer_t *", # Emulator treats timer as opaque
    "group_t": "lv_group_t *", # Emulator treats group as opaque
    "display_t": "lv_display_t *", # Emulator treats display as opaque
    "style_t": "lv_style_t *", # Emulator treats style as opaque ptr
    "style_value_t": "lv_style_value_t", # Need definition
    "image_dsc_t": "const lv_image_dsc_t *", # Emulator treats image src as opaque
    "anim_t": "lv_anim_t *", # Emulator treats anim as opaque
    # Add other basic types as needed from the JSON 'structs' list
    "draw_buf_t": "lv_draw_buf_t *", # Treat as opaque
    "layer_t": "lv_layer_t *", # Treat as opaque
    # ... etc for other opaque types in the emulator
}

# Map C types to cJSON types/parsing for emulator implementation
TYPE_MAP_EMU_IMPL = {
    "int32_t": {"ctype": "int32_t", "json_add": "cJSON_AddNumberToObject", "json_type": "cJSON_Number"},
    "bool": {"ctype": "bool", "json_add": "cJSON_AddBoolToObject", "json_type": "cJSON_Bool"},
    "float": {"ctype": "float", "json_add": "cJSON_AddNumberToObject", "json_type": "cJSON_Number"},
    "const char*": {"ctype": "const char*", "json_add": "cJSON_AddStringToObject", "json_type": "cJSON_String"},
    "lv_obj_t *": {"ctype": "lv_obj_t *", "json_add": "lv_emu_add_obj_ref_to_json", "json_type": "cJSON_Number", "is_obj": True}, # Store ID
    "lv_color_t": {"ctype": "lv_color_t", "json_add": "lv_emu_add_color_to_json", "json_type": "cJSON_String"}, # Store hex
    "lv_color32_t": {"ctype": "lv_color32_t", "json_add": "lv_emu_add_color32_to_json", "json_type": "cJSON_String"}, # Store hex
    "const lv_font_t *": {"ctype": "const lv_font_t *", "json_add": "lv_emu_add_registry_ref_to_json", "json_type": "cJSON_String", "registry": "font"}, # Store name
    "lv_point_t": {"ctype": "lv_point_t", "json_add": "lv_emu_add_point_to_json", "json_type": "cJSON_Object"},
    "lv_area_t": {"ctype": "lv_area_t", "json_add": "lv_emu_add_area_to_json", "json_type": "cJSON_Object"},
    "void*": {"ctype": "void*", "json_add": "lv_emu_add_registry_ref_to_json", "json_type": "cJSON_String", "registry": "generic"}, # Store name for generic pointers
    "const lv_image_dsc_t *": {"ctype": "const lv_image_dsc_t *", "json_add": "lv_emu_add_registry_ref_to_json", "json_type": "cJSON_String", "registry": "image_src"}, # Store name
    # Add other basic struct mappings or registry mappings
}

# Map JSON types/names to actual LVGL functions/types for the builder
TYPE_MAP_BUILDER = {
    "int": {"ctype": "int32_t", "json_get": "cJSON_GetNumberValue", "is_num": True},
    "bool": {"ctype": "bool", "json_get": "cJSON_IsTrue", "is_bool": True},
    "float": {"ctype": "float", "json_get": "cJSON_GetNumberValue", "is_num": True},
    "char*": {"ctype": "const char*", "json_get": "cJSON_GetStringValue", "is_str": True},
    "void*": {"ctype": "void*", "is_registry": True, "registry": "generic"}, # Lookup name
    "lv_obj_t*": {"ctype": "lv_obj_t *", "is_obj_ref": True}, # Lookup ID
    "color_t": {"ctype": "lv_color_t", "parse_func": "ui_builder_parse_color"},
    "color32_t": {"ctype": "lv_color32_t", "parse_func": "ui_builder_parse_color32"},
    "font_t": {"ctype": "const lv_font_t *", "is_registry": True, "registry": "font"}, # Lookup name
    "point_t": {"ctype": "lv_point_t", "parse_func": "ui_builder_parse_point"},
    "area_t": {"ctype": "lv_area_t", "parse_func": "ui_builder_parse_area"},
    "image_dsc_t": {"ctype": "const lv_image_dsc_t *", "is_registry": True, "registry": "image_src"}, # Lookup name
    # ... other types
}

# --- Helper Functions ---

def sanitize_name(name):
    """Remove leading underscores and handle keywords if necessary."""
    name = name.lstrip('_')
    # Add checks for C keywords if they appear in json (e.g., 'default')
    if name in ['default', 'asm', 'auto', 'break', 'case', 'char', 'const', 'continue',
                'do', 'double', 'else', 'enum', 'extern', 'float', 'for', 'goto', 'if',
                'int', 'long', 'register', 'return', 'short', 'signed', 'sizeof', 'static',
                'struct', 'switch', 'typedef', 'union', 'unsigned', 'void', 'volatile', 'while']:
        return name + '_'
    return name

# Global variable to hold loaded JSON data for helper functions
lv_data = {}

def get_c_type_emu_header(type_str):
    """Maps JSON type string to C type string for emulator header."""
    global lv_data # Access global data
    type_str = type_str.replace(" ", "") # Normalize
    if type_str.endswith('*'):
      base_type = type_str[:-1]
      if base_type in TYPE_MAP_EMU_HEADER:
          # Use the mapped type and ensure it's a pointer
          mapped = TYPE_MAP_EMU_HEADER[base_type]
          return mapped if mapped.endswith('*') else mapped + " *"
      elif base_type in lv_data.get("structs", []):
           # Check for specific known structs that might not be mapped directly
           if base_type in ['point_t', 'area_t', 'color_t', 'color32_t', 'style_value_t']:
               return f"lv_{base_type}_t *" # Pointers to basic structs
           return f"lv_{base_type}_t *" # Assume struct pointer -> lv_structname_t *
      else:
           # Assume opaque pointer for unknown structs/types
           return "void *" # Fallback: unknown pointer type
    else:
       # Handle non-pointer types
       if type_str in TYPE_MAP_EMU_HEADER:
           return TYPE_MAP_EMU_HEADER[type_str]
       elif type_str in lv_data.get("structs", []):
           # Define basic structs, treat others as opaque pointers for simplicity in args/return
           if type_str in ['point_t', 'area_t', 'color_t', 'color32_t', 'style_value_t']:
               return f"lv_{type_str}_t"
           else:
               # Treat complex struct return/arg as opaque pointer in header
               return f"lv_{type_str}_t *"
       elif type_str in lv_data.get("enums", {}):
           # Handle enum types
           return f"lv_{type_str.lower()}_t" # e.g., lv_align_t
       else:
            # print(f"Warning: Emulator Header - Unhandled type: {type_str}")
            return "int" # Fallback

def get_c_type_info_emu_impl(type_str):
    """Maps JSON type string to C type info for emulator implementation."""
    type_str = type_str.replace(" ", "")
    # Prioritize exact pointer matches in the map first
    if type_str.endswith('*') and type_str in TYPE_MAP_EMU_IMPL:
         return TYPE_MAP_EMU_IMPL[type_str]

    # Check non-pointer type or base type of pointer
    base_type = type_str.replace('*','').strip()
    is_pointer = type_str.endswith('*')

    if base_type in TYPE_MAP_EMU_IMPL:
        info = TYPE_MAP_EMU_IMPL[base_type].copy()
        if is_pointer:
            info['ctype'] += " *"
            # Special handling for specific pointer types overrides base handling
            if base_type == "lv_obj_t":
                 info['is_obj'] = True; info['json_add'] = "lv_emu_add_obj_ref_to_json"
            elif base_type == "font_t":
                info['is_registry'] = True; info['registry'] = "font"; info['json_add'] = "lv_emu_add_registry_ref_to_json"
            elif base_type == "image_dsc_t":
                info['is_registry'] = True; info['registry'] = "image_src"; info['json_add'] = "lv_emu_add_registry_ref_to_json"
            elif base_type == "void":
                 info['is_registry'] = True; info['registry'] = "generic"; info['json_add'] = "lv_emu_add_registry_ref_to_json"
            # Add more pointer specific handlers based on base type if needed
        return info

    # Check if it's a known enum type - treat as int for storage, but need conversion logic
    if base_type in lv_data.get("enums", {}):
         c_type = f"lv_{base_type.lower()}_t" if not is_pointer else f"lv_{base_type.lower()}_t *"
         # Store enum as string representation using the enum_to_string helper
         return {"ctype": c_type, "json_add": "lv_emu_add_enum_to_json", "json_type": "cJSON_String", "enum_name": base_type.upper()}

    # Fallback for unknown types (likely struct pointers or complex structs)
    # Store as a generic registry pointer or an "unhandled" string
    if is_pointer:
         return {"ctype": "void *", "json_add": "lv_emu_add_registry_ref_to_json", "json_type": "cJSON_String", "registry": "generic"}
    else:
        # print(f"Warning: Emulator Impl - Unhandled non-pointer type: {type_str}")
        # Treat complex struct value as opaque pointer internally? Or unhandled?
        return {"ctype": "void *", "json_add": "lv_emu_add_unhandled_to_json", "json_type": "cJSON_String"}


def get_c_type_info_builder(type_str):
    """Maps JSON type string to C type info for builder implementation."""
    global lv_data
    type_str = type_str.replace(" ", "")
    # Check exact match first (e.g., lv_obj_t*)
    if type_str in TYPE_MAP_BUILDER:
        return TYPE_MAP_BUILDER[type_str]

    is_pointer = type_str.endswith('*')
    base_type = type_str[:-1] if is_pointer else type_str

    # Check base type if pointer
    if is_pointer:
        if base_type in TYPE_MAP_BUILDER:
            info = TYPE_MAP_BUILDER[base_type].copy()
            info['ctype'] += " *" # Add pointer back
            # Special handling for specific pointer types
            if base_type == "lv_obj_t": info = TYPE_MAP_BUILDER["lv_obj_t*"].copy()
            elif base_type == "font_t": info = TYPE_MAP_BUILDER["font_t"].copy()
            elif base_type == "image_dsc_t": info = TYPE_MAP_BUILDER["image_dsc_t"].copy()
            elif base_type == "void": info = TYPE_MAP_BUILDER["void*"].copy()
            # Add other specific pointer lookups...
            return info
        elif base_type in lv_data.get("structs", []):
            # Assume opaque registry lookup for unknown struct pointers
            # print(f"Warning: Builder - Assuming registry lookup for unknown struct ptr: {type_str}")
            return {"ctype": f"lv_{base_type}_t *", "is_registry": True, "registry": "generic"}

    # Check non-pointer type
    if base_type in lv_data.get("structs", []):
        # Handle known basic structs that have parsers
        if base_type in ['point_t', 'area_t', 'color_t', 'color32_t']:
             if base_type in TYPE_MAP_BUILDER:
                 return TYPE_MAP_BUILDER[base_type]
             else:
                 # print(f"Warning: Builder - Missing parse func for basic struct: {base_type}")
                 return {"ctype": f"lv_{base_type}_t", "is_unhandled": True}
        else:
             # print(f"Warning: Builder - Unhandled struct type: {base_type}")
             return {"ctype": f"lv_{base_type}_t", "is_unhandled": True} # Mark as unhandled

    # Check if it's an enum type
    if base_type in lv_data.get("enums", {}):
        c_type_name = f"lv_{base_type.lower()}_t"
        return {"ctype": c_type_name, "is_enum": True, "enum_name": base_type.upper()}


    # Final fallback
    # print(f"Warning: Builder - Unhandled type: {type_str}")
    return {"ctype": "int", "is_unhandled": True} # Default to int, mark as unhandled

# --- Enum Mapping Generation ---

def generate_emulator_enum_to_string_func(data):
    """Generates the C code for lv_emu_enum_to_string"""
    code = []
    code.append("static const char* lv_emu_enum_to_string(int value, const char* enum_name) {")
    code.append("    static char buffer[48]; // For unknown values")
    first_enum = True
    for enum_name, enum_data in sorted(data.get("enums", {}).items()):
        c_enum_name_upper = enum_name.upper()
        else_kw = "" if first_enum else "else "
        # Use the exact enum name from JSON for strcmp
        code.append(f"    {else_kw}if (strcmp(enum_name, \"{c_enum_name_upper}\") == 0) {{")
        code.append("        switch (value) {")
        # ASSUMPTION: We don't know the exact integer value from JSON, use index as placeholder
        i = 0
        for member_name in sorted(enum_data["members"].keys()):
            # We map the *assumed* integer value (index i) to the *original string name*
            code.append(f"            // Assuming LV_{c_enum_name_upper}_{sanitize_name(member_name).upper()} == {i}")
            code.append(f"            case {i}: return \"{member_name}\";") # Return original JSON key
            i += 1
        code.append(f"            default: snprintf(buffer, sizeof(buffer), \"UNKNOWN_{c_enum_name_upper}_%d\", value); return buffer;")
        code.append("        }")
        code.append("    }")
        first_enum = False

    code.append("    else {")
    code.append("        snprintf(buffer, sizeof(buffer), \"UNKNOWN_ENUM_TYPE_%s_%d\", enum_name, value); return buffer;")
    code.append("    }")
    code.append("}")
    return "\n".join(code)


def generate_builder_enum_from_string_func(data):
    """Generates the C code for ui_builder_enum_from_string"""
    code = []
    code.append("// Auto-generated enum string to value mapping")
    code.append("static int ui_builder_enum_from_string(const char* value_str, const char* enum_name) {")
    code.append("    if (!value_str || !enum_name) return 0;")
    first_enum = True
    for enum_name, enum_data in sorted(data.get("enums", {}).items()):
        c_enum_name_upper = enum_name.upper()
        else_kw = "" if first_enum else "else "
        # Use the exact enum name from JSON for strcmp
        code.append(f"    {else_kw}if (strcmp(enum_name, \"{c_enum_name_upper}\") == 0) {{")
        default_val_str = "0" # Default to 0 if no members or first member not found
        first_member_done = False

        for member_name in sorted(enum_data["members"].keys()):
            sanitized_member_upper = sanitize_name(member_name).upper()
            # Construct the C identifier based on LVGL convention
            c_member_name = f"LV_{c_enum_name_upper}_{sanitized_member_upper}"
            if not first_member_done:
                 # Assume the first member is a reasonable default
                 default_val_str = c_member_name
                 first_member_done = True
            # Compare against the original JSON key string
            code.append(f"        if (strcmp(value_str, \"{member_name}\") == 0) return {c_member_name};")

        code.append(f"        ui_builder_report_error(\"Unknown {c_enum_name_upper} enum value: '%s'\", value_str);")
        code.append(f"        return {default_val_str}; // Default value for {c_enum_name_upper}")
        code.append("    }")
        first_enum = False

    code.append("    else {")
    code.append("        ui_builder_report_error(\"Enum conversion not implemented for type: %s\", enum_name);")
    code.append("        return 0; // Default for unknown enum type")
    code.append("    }")
    code.append("}")
    return "\n".join(code)

# --- Header Generation Functions ---

def generate_emulator_header(data):
    """Generates lvgl_emulation.h"""
    code = []
    code.append("// Generated by generate_lvgl_emu.py - DO NOT EDIT")
    code.append("#ifndef LVGL_EMULATION_H")
    code.append("#define LVGL_EMULATION_H")
    code.append("\n#ifdef __cplusplus")
    code.append('extern "C" {')
    code.append("#endif")
    code.append("\n#include <stdint.h>")
    code.append("#include <stdbool.h>")
    code.append("#include <stddef.h>")
    code.append('#include "cJSON.h"') # Requires cJSON library
    code.append("\n// --- Basic Type Definitions (Emulated) ---")
    code.append("typedef void lv_font_t;")
    code.append("typedef void lv_image_dsc_t;")
    code.append("typedef int32_t lv_coord_t;")
    # code.append("typedef uint32_t lv_opa_t;")
    # Define colors based on common assumptions. Actual LVGL might use structs.
    code.append("typedef uint32_t lv_color_t; // Store as 0xAARRGGBB hex value for portability in JSON")
    code.append("typedef uint32_t lv_color32_t; // Store as 0xAARRGGBB hex value for portability in JSON")


    # --- Forward declare internal object struct ---
    code.append("struct lv_emu_obj_internal_t;")
    code.append("typedef struct lv_emu_obj_internal_t* lv_obj_t;")

    # --- Define minimal structs needed ---
    code.append("typedef struct { lv_coord_t x; lv_coord_t y; } lv_point_t;")
    code.append("typedef struct { lv_coord_t x1; lv_coord_t y1; lv_coord_t x2; lv_coord_t y2; } lv_area_t;")
    code.append("typedef union { lv_color_t color; const void * pointer; int32_t number; } lv_style_value_t;") # Simplified

    # --- Opaque types (represented as void* or specific pointers if needed) ---
    code.append("\n// --- Opaque Types (Pointers handled by registry) ---")
    opaque_types = set([
        "font_t", "timer_t", "group_t", "display_t", "style_t",
        "image_dsc_t", "anim_t", "draw_buf_t", "layer_t", "theme_t",
        # Add other known opaque types explicitly if needed
    ])
    # Add structs from json that aren't basic and aren't obj_t
    basic_structs = {"obj_t", "point_t", "area_t", "color_t", "color32_t", "style_value_t"}
    for s_name in data.get("structs", []):
        if s_name not in basic_structs:
            opaque_types.add(s_name)

    for type_name in sorted(list(opaque_types)):
        # Use a distinct name like lv_font_ptr to avoid conflict if lv_font_t is defined differently
        code.append(f"typedef void* lv_{type_name}_ptr; // Opaque pointer type")
        code.append(f"typedef lv_{type_name}_ptr lv_{type_name}_t; // Define lv_xxx_t as the opaque pointer")


    code.append("\n// --- Enums ---")
    for enum_name, enum_data in data.get("enums", {}).items():
        c_enum_name_lower = enum_name.lower()
        code.append(f"typedef enum {{")
        i = 0
        members = list(enum_data["members"].keys())
        for idx, member_name in enumerate(members):
             # Define enum members based on LVGL convention LV_ENUMNAME_MEMBERNAME
             c_member_name = f"LV_{enum_name.upper()}_{sanitize_name(member_name).upper()}"
             suffix = "," if idx < len(members) - 1 else ""
             # Assign value based on index - requires real header for actual values
             code.append(f"    {c_member_name} = {i}{suffix} /* Placeholder value */")
             i += 1
        code.append(f"}} lv_{c_enum_name_lower}_t;")


    code.append("\n// --- Constants ---")
    for const_name in data.get("int_constants", []):
        # We don't know the value, so define as 0 or a placeholder
        # Use LVGL naming convention
        c_const_name = f"LV_{sanitize_name(const_name).upper()}"
        code.append(f"#define {c_const_name} 0 // Placeholder value for {const_name}")
    # Add common constants manually if needed, ensure they match enum defs
    code.append("#ifndef LV_STATE_DEFAULT") # Prevent redefinition if included elsewhere
    code.append("#define LV_STATE_DEFAULT LV_STATE_DEFAULT")
    code.append("#endif")
    code.append("#ifndef LV_PART_MAIN")
    code.append("#define LV_PART_MAIN LV_PART_MAIN")
    code.append("#endif")

    code.append("\n// --- Emulator Control Functions ---")
    code.append("void lv_emu_init(void);")
    code.append("void lv_emu_deinit(void);")
    code.append("char* lv_emu_get_json(bool formatted); // Remember to free the returned string")
    code.append("void lv_emu_register_font(const char *name, const lv_font_t *font);")
    code.append("void lv_emu_register_image_src(const char *name, const lv_image_dsc_t *src);")
    code.append("void lv_emu_register_generic(const char *name, const void *ptr);")


    code.append("\n// --- Emulated LVGL Functions ---")
    processed_funcs = set()

    # Global functions
    for func_name, func_data in data.get("functions", {}).items():
        if func_data["type"] == "function":
            # Filter out functions not relevant to UI definition (e.g., getters, events, timers, fs, internal)
            if "event" in func_name or "timer" in func_name or "indev" in func_name or \
               "tick" in func_name or "anim" in func_name or "refr" in func_name or \
               "disp" in func_name or "group" in func_name or "theme" in func_name or \
               "font_get" in func_name or "style_get" in func_name or "obj_get" in func_name or \
               func_name.startswith("get_") or func_name.startswith("is_") or \
               "mem_" in func_name or "fs_" in func_name or \
               "log_" in func_name or "draw_" in func_name or "layout_" in func_name or \
               "deinit" in func_name or "_init" in func_name or \
               func_name in ["memcpy", "memset", "strlen", "strcpy", "strcmp", "malloc", "free", "realloc", "calloc", "zalloc"] or \
               "version_" in func_name or "debug_" in func_name or "assert_" in func_name or \
               "thread_" in func_name or "mutex_" in func_name or "lock" in func_name or "sync" in func_name or \
               "math_" in func_name or "trigo_" in func_name or "bezier" in func_name or \
               "snapshot_" in func_name or "handler" in func_name or "task" in func_name or \
               func_name.endswith("_cb") or "cache" in func_name: # More aggressive filtering
                continue # Skip non-UI definition functions for now

            processed_funcs.add(func_name)
            c_func_name = f"lv_{func_name}" # Use lv_ prefix

            ret_type = get_c_type_emu_header(func_data["return_type"])
            args = []
            for arg in func_data["args"]:
                 # Treat callbacks/func_ptrs as opaque void* in emulator
                 if arg["type"] == "callback" or arg["type"] == "function pointer":
                     args.append(f"void* {sanitize_name(arg['name'])}")
                 else:
                    args.append(f"{get_c_type_emu_header(arg['type'])} {sanitize_name(arg['name'])}")
            args_str = ", ".join(args) if args else "void"
            code.append(f"{ret_type} {c_func_name}({args_str});")

    # Object member functions
    for obj_name, obj_data in data.get("objects", {}).items():
         # Generate create function for specific widgets
         create_func_name = f"{obj_name}_create"
         if create_func_name in data.get("functions", {}):
              func_data = data["functions"][create_func_name]
              if create_func_name not in processed_funcs:
                   processed_funcs.add(create_func_name)
                   ret_type = get_c_type_emu_header(func_data["return_type"])
                   args = []
                   for arg in func_data["args"]:
                       if arg["type"] == "callback" or arg["type"] == "function pointer": args.append(f"void* {sanitize_name(arg['name'])}")
                       else: args.append(f"{get_c_type_emu_header(arg['type'])} {sanitize_name(arg['name'])}")
                   args_str = ", ".join(args) if args else "void"
                   code.append(f"{ret_type} lv_{create_func_name}({args_str});")

         # Process relevant member functions (mainly setters)
         for func_name, func_data in obj_data.get("members", {}).items():
             if func_data["type"] == "function":
                 # Filter out non-UI definition functions
                 if "event" in func_name or "timer" in func_name or "indev" in func_name or \
                    func_name.startswith("get_") or func_name.startswith("is_") or \
                    "style_get" in func_name or "hit_test" in func_name or \
                    "search" in func_name or "clean" in func_name or "del" in func_name or \
                    "refr" in func_name or "layout" in func_name or "state" in func_name or \
                    "class" in func_name or "event" in func_name or \
                    func_name.endswith("_cb"): # More filtering
                     continue

                 # Assume first arg is lv_obj_t* for members
                 if not func_data["args"] or not func_data["args"][0]["type"].startswith("lv_obj_t"):
                      continue

                 # Use lv_obj_ prefix for base object members
                 c_func_name = f"lv_{obj_name}_{func_name}" if obj_name != "obj" else f"lv_obj_{func_name}"

                 if c_func_name not in processed_funcs:
                     processed_funcs.add(c_func_name)
                     processed_funcs.add(func_name) # Add base name too to avoid global/member clash

                     ret_type = get_c_type_emu_header(func_data["return_type"])
                     args = []
                     for arg in func_data["args"]:
                          if arg["type"] == "callback" or arg["type"] == "function pointer": args.append(f"void* {sanitize_name(arg['name'])}")
                          else: args.append(f"{get_c_type_emu_header(arg['type'])} {sanitize_name(arg['name'])}")
                     args_str = ", ".join(args) if args else "void"
                     code.append(f"{ret_type} {c_func_name}({args_str});")


    code.append("\n#ifdef __cplusplus")
    code.append("}")
    code.append("#endif")
    code.append("\n#endif // LVGL_EMULATION_H")
    return "\n".join(code)

# --- Source Generation Functions ---

# Helper function to structure emulator source generation
def generate_emulator_source_impl(data, enum_to_string_impl_code):
    code = []
    code.append("// Generated by generate_lvgl_emu.py - DO NOT EDIT")
    code.append("#include \"lvgl_emulation.h\"")
    code.append("#include <stdio.h>")
    code.append("#include <stdlib.h>")
    code.append("#include <string.h>")
    code.append("\n// --- Hash Map Implementation (Simple example using uthash.h) ---")
    code.append("#include \"uthash.h\"") # Get uthash.h from https://troydhanson.github.io/uthash/
    code.append("\n// Registry Entry")
    code.append("typedef struct {")
    code.append("    const void *ptr; // Key: The actual pointer provided by the user")
    code.append("    const char *name; // Value: The registered name")
    code.append("    UT_hash_handle hh;")
    code.append("} lv_emu_registry_entry_t;")
    code.append("\n// Internal Object Representation")
    code.append("typedef struct lv_emu_obj_internal_t {")
    code.append("    uint32_t id;")
    code.append("    cJSON *json_node;")
    code.append("    // Add other internal state if needed (e.g., pointer back to this struct)")
    code.append("    UT_hash_handle hh; // Make ID searchable if needed")
    code.append("} lv_emu_obj_internal_t;")
    code.append("\n// Emulator Global State")
    code.append("typedef struct {")
    code.append("    cJSON *root_json; // Root of the UI definition")
    code.append("    cJSON *objects_json; // Array of objects under root_json")
    code.append("    uint32_t next_obj_id;")
    code.append("    lv_emu_registry_entry_t *font_registry;")
    code.append("    lv_emu_registry_entry_t *image_src_registry;")
    code.append("    lv_emu_registry_entry_t *generic_registry;")
    code.append("    lv_emu_obj_internal_t *object_map; // Map ID -> internal object struct ptr")
    code.append("} lv_emu_state_t;")
    code.append("\nstatic lv_emu_state_t g_emu_state = {0};")

    code.append("\n// --- Forward Declarations for Helpers ---")
    code.append("static lv_obj_t lv_emu_create_obj_internal(const char* type, lv_obj_t parent);")
    code.append("static cJSON* lv_emu_get_or_create_json_object(cJSON *parent, const char *key);")
    code.append("static cJSON* lv_emu_get_or_create_json_array(cJSON *parent, const char *key);")
    code.append("static void lv_emu_add_registry_ref_to_json(cJSON *json_obj, const char *key, const void *ptr, lv_emu_registry_entry_t *registry);")
    code.append("static void lv_emu_add_obj_ref_to_json(cJSON *json_obj, const char *key, lv_obj_t obj);")
    code.append("static void lv_emu_add_color_to_json(cJSON *json_obj, const char *key, lv_color_t color);")
    code.append("static void lv_emu_add_color32_to_json(cJSON *json_obj, const char *key, lv_color32_t color);")
    code.append("static void lv_emu_add_point_to_json(cJSON *json_obj, const char *key, lv_point_t point);")
    code.append("static void lv_emu_add_area_to_json(cJSON *json_obj, const char *key, lv_area_t area);")
    code.append("static void lv_emu_add_unhandled_to_json(cJSON *json_obj, const char *key, const void *ptr);")
    code.append("static void lv_emu_add_enum_to_json(cJSON *json_obj, const char *key, int value, const char* enum_name);") # Added helper
    code.append("static const char* lv_emu_find_registry_name(const void *ptr, lv_emu_registry_entry_t *registry);")
    code.append("static void lv_emu_register_internal(const char *name, const void *ptr, lv_emu_registry_entry_t **registry);")

    code.append("\n// --- Generated Enum Mapping Function ---")
    code.append(enum_to_string_impl_code) # Inject generated enum function
    code.append("// --- End Enum Mapping Function ---\n")

    code.append("static void lv_emu_set_obj_property(lv_obj_t obj, const char* prop_name, cJSON* value_json);")
    code.append("static void lv_emu_set_obj_style_property(lv_obj_t obj, int32_t part, int32_t state, const char* prop_name, cJSON* value_json);")


    code.append("\n// --- Emulator Control Function Implementations ---")
    code.append("""
void lv_emu_init(void) {
    if (g_emu_state.root_json) {
        cJSON_Delete(g_emu_state.root_json); // Clear previous state
    }
    // Clear object map
    lv_emu_obj_internal_t *obj_current, *obj_tmp;
    HASH_ITER(hh, g_emu_state.object_map, obj_current, obj_tmp) {
        HASH_DEL(g_emu_state.object_map, obj_current);
        // Don't delete obj_current->json_node here, it's part of root_json
        free(obj_current);
    }
    // Clear registries
    lv_emu_registry_entry_t *reg_current, *reg_tmp;
    HASH_ITER(hh, g_emu_state.font_registry, reg_current, reg_tmp) { HASH_DEL(g_emu_state.font_registry, reg_current); free(reg_current); }
    HASH_ITER(hh, g_emu_state.image_src_registry, reg_current, reg_tmp) { HASH_DEL(g_emu_state.image_src_registry, reg_current); free(reg_current); }
    HASH_ITER(hh, g_emu_state.generic_registry, reg_current, reg_tmp) { HASH_DEL(g_emu_state.generic_registry, reg_current); free(reg_current); }

    memset(&g_emu_state, 0, sizeof(g_emu_state));
    g_emu_state.root_json = cJSON_CreateObject();
    if (!g_emu_state.root_json) { /* Handle error */ return; }
    g_emu_state.objects_json = cJSON_AddArrayToObject(g_emu_state.root_json, "objects");
    if (!g_emu_state.objects_json) { /* Handle error */ cJSON_Delete(g_emu_state.root_json); g_emu_state.root_json = NULL; return; }
    g_emu_state.next_obj_id = 1; // Start IDs from 1
    g_emu_state.font_registry = NULL;
    g_emu_state.image_src_registry = NULL;
    g_emu_state.generic_registry = NULL;
    g_emu_state.object_map = NULL; // Initialize object map
}

void lv_emu_deinit(void) {
    if (g_emu_state.root_json) {
        cJSON_Delete(g_emu_state.root_json);
    }
    // Clear object map
    lv_emu_obj_internal_t *obj_current, *obj_tmp;
    HASH_ITER(hh, g_emu_state.object_map, obj_current, obj_tmp) {
        HASH_DEL(g_emu_state.object_map, obj_current);
        free(obj_current);
    }
     // Clear registries
    lv_emu_registry_entry_t *reg_current, *reg_tmp;
    HASH_ITER(hh, g_emu_state.font_registry, reg_current, reg_tmp) { HASH_DEL(g_emu_state.font_registry, reg_current); free(reg_current); }
    HASH_ITER(hh, g_emu_state.image_src_registry, reg_current, reg_tmp) { HASH_DEL(g_emu_state.image_src_registry, reg_current); free(reg_current); }
    HASH_ITER(hh, g_emu_state.generic_registry, reg_current, reg_tmp) { HASH_DEL(g_emu_state.generic_registry, reg_current); free(reg_current); }

    memset(&g_emu_state, 0, sizeof(g_emu_state));
}

char* lv_emu_get_json(bool formatted) {
    if (!g_emu_state.root_json) return NULL;
    return formatted ? cJSON_Print(g_emu_state.root_json) : cJSON_PrintUnformatted(g_emu_state.root_json);
}

static void lv_emu_register_internal(const char *name, const void *ptr, lv_emu_registry_entry_t **registry) {
    if (!ptr || !name) return;
    lv_emu_registry_entry_t *entry;
    HASH_FIND_PTR(*registry, &ptr, entry);
    if (entry == NULL) {
        entry = (lv_emu_registry_entry_t*)malloc(sizeof(lv_emu_registry_entry_t));
        if(!entry) return; // Malloc failed
        entry->ptr = ptr;
        entry->name = name; // Store pointer to name provided by user
        HASH_ADD_PTR(*registry, ptr, entry);
    } else {
        entry->name = name; // Update name if pointer already exists
    }
}

void lv_emu_register_font(const char *name, const lv_font_t *font) { lv_emu_register_internal(name, font, &g_emu_state.font_registry); }
void lv_emu_register_image_src(const char *name, const lv_image_dsc_t *src) { lv_emu_register_internal(name, src, &g_emu_state.image_src_registry); }
void lv_emu_register_generic(const char *name, const void *ptr) { lv_emu_register_internal(name, ptr, &g_emu_state.generic_registry); }

// --- Helper Function Implementations ---

static const char* lv_emu_find_registry_name(const void *ptr, lv_emu_registry_entry_t *registry) {
    if (!ptr || !registry) return "NULL"; // Return "NULL" for null pointers
    lv_emu_registry_entry_t *entry;
    HASH_FIND_PTR(registry, &ptr, entry);
    return entry ? entry->name : "unknown_ptr";
}

static cJSON* lv_emu_get_or_create_json_object(cJSON *parent, const char *key) {
    if (!parent || !key) return NULL;
    cJSON *obj = cJSON_GetObjectItemCaseSensitive(parent, key);
    return obj ? obj : cJSON_AddObjectToObject(parent, key);
}
static cJSON* lv_emu_get_or_create_json_array(cJSON *parent, const char *key) {
     if (!parent || !key) return NULL;
    cJSON *arr = cJSON_GetObjectItemCaseSensitive(parent, key);
    return arr ? arr : cJSON_AddArrayToObject(parent, key);
}

static void lv_emu_add_registry_ref_to_json(cJSON *json_obj, const char *key, const void *ptr, lv_emu_registry_entry_t *registry) {
     if (!json_obj || !key) return;
     const char * name = lv_emu_find_registry_name(ptr, registry);
     cJSON_AddStringToObject(json_obj, key, name ? name : "unregistered_ptr");
}

static void lv_emu_add_obj_ref_to_json(cJSON *json_obj, const char *key, lv_obj_t obj) {
     if (!json_obj || !key) return;
    cJSON_AddNumberToObject(json_obj, key, (obj && obj->json_node) ? obj->id : 0);
}

static void lv_emu_add_color_to_json(cJSON *json_obj, const char *key, lv_color_t color) {
     if (!json_obj || !key) return;
    // Format as #AARRGGBB, assuming lv_color_t holds this (might need platform specifics)
    char hex_str[10]; snprintf(hex_str, sizeof(hex_str), "#%08X", (uint32_t)color);
    cJSON_AddStringToObject(json_obj, key, hex_str);
}
static void lv_emu_add_color32_to_json(cJSON *json_obj, const char *key, lv_color32_t color32) {
      if (!json_obj || !key) return;
    // Format as #AARRGGBB, assuming lv_color32_t holds this
    char hex_str[10]; snprintf(hex_str, sizeof(hex_str), "#%08X", (uint32_t)color32);
    cJSON_AddStringToObject(json_obj, key, hex_str);
}

static void lv_emu_add_point_to_json(cJSON *json_obj, const char *key, lv_point_t point) {
     if (!json_obj || !key) return;
    cJSON *p_json = cJSON_CreateObject();
    if (!p_json) return;
    cJSON_AddNumberToObject(p_json, "x", point.x);
    cJSON_AddNumberToObject(p_json, "y", point.y);
    cJSON_AddItemToObject(json_obj, key, p_json);
}

static void lv_emu_add_area_to_json(cJSON *json_obj, const char *key, lv_area_t area) {
     if (!json_obj || !key) return;
    cJSON *a_json = cJSON_CreateObject();
    if (!a_json) return;
    cJSON_AddNumberToObject(a_json, "x1", area.x1);
    cJSON_AddNumberToObject(a_json, "y1", area.y1);
    cJSON_AddNumberToObject(a_json, "x2", area.x2);
    cJSON_AddNumberToObject(a_json, "y2", area.y2);
    cJSON_AddItemToObject(json_obj, key, a_json);
}

static void lv_emu_add_unhandled_to_json(cJSON *json_obj, const char *key, const void *ptr) {
     if (!json_obj || !key) return;
    char buffer[50]; snprintf(buffer, sizeof(buffer), "unhandled_ptr:%p", ptr);
    cJSON_AddStringToObject(json_obj, key, buffer);
}

// Helper to add enum as string
static void lv_emu_add_enum_to_json(cJSON *json_obj, const char *key, int value, const char* enum_name) {
    if (!json_obj || !key || !enum_name) return;
    const char* enum_str = lv_emu_enum_to_string(value, enum_name);
    cJSON_AddStringToObject(json_obj, key, enum_str);
}


// Basic internal object creation
static lv_obj_t lv_emu_create_obj_internal(const char* type, lv_obj_t parent) {
    if (!g_emu_state.root_json) lv_emu_init();
    if (!g_emu_state.root_json || !g_emu_state.objects_json) return NULL; // Init failed or objects array missing

    lv_emu_obj_internal_t* emu_obj = (lv_emu_obj_internal_t*)calloc(1, sizeof(lv_emu_obj_internal_t)); // Use calloc
    if (!emu_obj) return NULL;

    emu_obj->id = g_emu_state.next_obj_id++;
    emu_obj->json_node = cJSON_CreateObject();
    if (!emu_obj->json_node) { free(emu_obj); return NULL; }

    // Add basic info to JSON
    cJSON_AddNumberToObject(emu_obj->json_node, "id", emu_obj->id);
    cJSON_AddStringToObject(emu_obj->json_node, "type", type ? type : "obj");
    cJSON_AddNumberToObject(emu_obj->json_node, "parent_id", parent ? parent->id : 0); // 0 = root/screen
    cJSON_AddObjectToObject(emu_obj->json_node, "properties"); // Placeholder for properties
    cJSON_AddArrayToObject(emu_obj->json_node, "styles");     // Placeholder for styles
    cJSON_AddArrayToObject(emu_obj->json_node, "flags");      // Initialize flags array
    cJSON_AddArrayToObject(emu_obj->json_node, "states");     // Initialize states array

    // Add this object's JSON representation to the global list
    cJSON_AddItemToArray(g_emu_state.objects_json, emu_obj->json_node);

    // Add internal object struct to ID map
    HASH_ADD_INT(g_emu_state.object_map, id, emu_obj);

    return emu_obj; // Return pointer to the internal struct
}

// Helper to find internal object struct by ID
static lv_emu_obj_internal_t* lv_emu_find_internal_obj_by_id(uint32_t id) {
    if (id == 0) return NULL;
    lv_emu_obj_internal_t *entry;
    HASH_FIND_INT(g_emu_state.object_map, &id, entry);
    return entry;
}


// --- Functions to Set Properties/Styles in JSON ---
// Helper to set a direct property on the object's JSON
static void lv_emu_set_obj_property(lv_obj_t obj, const char* prop_name, cJSON* value_json) {
    if (!obj || !obj->json_node || !prop_name || !value_json) { cJSON_Delete(value_json); return; }; // Clean up value if error
    cJSON *properties = lv_emu_get_or_create_json_object(obj->json_node, "properties");
    if (!properties) { cJSON_Delete(value_json); return; }; // Failed to create properties object
    // Replace existing property if it exists, otherwise add
    if (cJSON_HasObjectItem(properties, prop_name)) {
        cJSON_ReplaceItemInObjectCaseSensitive(properties, prop_name, value_json);
    } else {
        cJSON_AddItemToObject(properties, prop_name, value_json);
    }
}

// Helper to set a style property, creating/updating style entries as needed
static void lv_emu_set_obj_style_property(lv_obj_t obj, int32_t part, int32_t state, const char* prop_name, cJSON* value_json) {
    if (!obj || !obj->json_node || !prop_name || !value_json) { cJSON_Delete(value_json); return; }

    cJSON *styles_array = lv_emu_get_or_create_json_array(obj->json_node, "styles");
     if (!styles_array) { cJSON_Delete(value_json); return; }; // Failed to create styles array

    // Use enum mapping to get string representation
    const char* part_str = lv_emu_enum_to_string(part, "PART");
    const char* state_str = lv_emu_enum_to_string(state, "STATE");

    cJSON *style_entry = NULL;
    cJSON *current_entry = NULL;
    // Find if a style entry for this part/state already exists
    cJSON_ArrayForEach(current_entry, styles_array) {
        cJSON *p = cJSON_GetObjectItemCaseSensitive(current_entry, "part");
        cJSON *s = cJSON_GetObjectItemCaseSensitive(current_entry, "selector"); // Use "selector" for state
        if (p && s && cJSON_IsString(p) && cJSON_IsString(s) &&
            strcmp(p->valuestring, part_str) == 0 &&
            strcmp(s->valuestring, state_str) == 0)
        {
            style_entry = current_entry;
            break;
        }
    }

    // If not found, create a new style entry
    if (!style_entry) {
        style_entry = cJSON_CreateObject();
        if (!style_entry) { cJSON_Delete(value_json); return; };
        cJSON_AddStringToObject(style_entry, "part", part_str);
        cJSON_AddStringToObject(style_entry, "selector", state_str);
        cJSON_AddObjectToObject(style_entry, "props"); // Create props obj immediately
        cJSON_AddItemToArray(styles_array, style_entry);
    }

    // Get the properties object within the style entry
    cJSON *style_props = lv_emu_get_or_create_json_object(style_entry, "props");
     if (!style_props) { cJSON_Delete(value_json); return; }; // Failed to get/create style props object

    // Add or replace the specific style property
    if (cJSON_HasObjectItem(style_props, prop_name)) {
        cJSON_ReplaceItemInObjectCaseSensitive(style_props, prop_name, value_json);
    } else {
        cJSON_AddItemToObject(style_props, prop_name, value_json);
    }
}

""") # End multi-line string


    # --- Generate LVGL Function Implementations ---
    processed_funcs = set() # Track generated functions to avoid duplicates

    # Generate object creation functions first
    create_funcs = []
    for obj_name, obj_data in data.get("objects", {}).items():
         func_name = f"{obj_name}_create"
         if func_name in data.get("functions", {}): create_funcs.append((func_name, data["functions"][func_name]))
         elif obj_name == "obj": # Base object create
              func_name = "obj_create"
              if func_name in data.get("functions", {}): create_funcs.append((func_name, data["functions"][func_name]))

    for func_name, func_data in create_funcs:
        if func_name in processed_funcs: continue
        processed_funcs.add(func_name)

        widget_type = func_name.replace("_create", "")
        c_func_name = f"lv_{func_name}"
        ret_type = get_c_type_emu_header(func_data["return_type"])
        args_list = []; arg_names = []
        for arg in func_data["args"]:
            args_list.append(f"{get_c_type_emu_header(arg['type'])} {sanitize_name(arg['name'])}")
            arg_names.append(sanitize_name(arg['name']))
        args_str = ", ".join(args_list) if args_list else "void"

        code.append(f"// --- {c_func_name} ---")
        code.append(f"{ret_type} {c_func_name}({args_str}) {{")
        parent_arg = arg_names[0] if arg_names else "NULL" # Assume first arg is parent
        code.append(f"    // Create internal representation")
        code.append(f"    lv_obj_t new_obj = lv_emu_create_obj_internal(\"{widget_type}\", {parent_arg});")
        # Handle other create arguments if they set initial properties? (More complex)
        code.append(f"    return new_obj;")
        code.append(f"}}\n")


    # Global functions (Setters, etc.) - Apply filtering
    for func_name, func_data in data.get("functions", {}).items():
         if func_name in processed_funcs: continue # Skip creates handled above
         if func_data["type"] != "function": continue

         # Apply filtering (copied and adjusted from header generation)
         if "event" in func_name or "timer" in func_name or "indev" in func_name or \
               "tick" in func_name or "anim" in func_name or "refr" in func_name or \
               "disp" in func_name or "group" in func_name or "theme" in func_name or \
               "font_get" in func_name or "style_get" in func_name or "obj_get" in func_name or \
               func_name.startswith("get_") or func_name.startswith("is_") or \
               "mem_" in func_name or "fs_" in func_name or \
               "log_" in func_name or "draw_" in func_name or "layout_" in func_name or \
               "deinit" in func_name or "_init" in func_name or \
               func_name in ["memcpy", "memset", "strlen", "strcpy", "strcmp", "malloc", "free", "realloc", "calloc", "zalloc"] or \
               "version_" in func_name or "debug_" in func_name or "assert_" in func_name or \
               "thread_" in func_name or "mutex_" in func_name or "lock" in func_name or "sync" in func_name or \
               "math_" in func_name or "trigo_" in func_name or "bezier" in func_name or \
               "snapshot_" in func_name or "handler" in func_name or "task" in func_name or \
               func_name.endswith("_cb") or "cache" in func_name:
                continue
         processed_funcs.add(func_name)

         c_func_name = f"lv_{func_name}"
         ret_type_str = func_data["return_type"]; ret_type = get_c_type_emu_header(ret_type_str)
         args_list = []; arg_names = []; arg_types = []
         for arg in func_data["args"]:
              arg_type_str = arg["type"]
              arg_type = get_c_type_emu_header(arg_type_str)
              arg_name = sanitize_name(arg['name'])
              args_list.append(f"{arg_type} {arg_name}")
              arg_names.append(arg_name)
              arg_types.append(arg_type_str) # Keep original JSON type string
         args_str = ", ".join(args_list) if args_list else "void"

         code.append(f"// --- {c_func_name} ---")
         code.append(f"{c_func_name}({args_str}) {{")
         # Handle specific known global functions
         if func_name == "screen_active" or func_name == "scr_act":
              # Find first object with type "screen" in the JSON array
              code.append(f"    if(g_emu_state.objects_json) {{")
              code.append(f"        cJSON *obj_item = NULL;")
              code.append(f"        cJSON_ArrayForEach(obj_item, g_emu_state.objects_json) {{")
              code.append(f"            cJSON* type_json = cJSON_GetObjectItemCaseSensitive(obj_item, \"type\");")
              code.append(f"            cJSON* id_json = cJSON_GetObjectItemCaseSensitive(obj_item, \"id\");")
              code.append(f"            if(type_json && cJSON_IsString(type_json) && strcmp(type_json->valuestring, \"screen\") == 0 && id_json && cJSON_IsNumber(id_json)) {{")
              code.append(f"                 // Find the internal object struct pointer using the ID")
              code.append(f"                 lv_emu_obj_internal_t* screen_obj = lv_emu_find_internal_obj_by_id((uint32_t)id_json->valuedouble);")
              code.append(f"                 if(screen_obj) return screen_obj; // Return pointer to internal struct")
              code.append(f"            }}")
              code.append(f"        }}")
              code.append(f"    }}")
              code.append(f"     // Fallback: create screen if none exists? This might be unexpected.")
              code.append(f"     // return lv_emu_create_obj_internal(\"screen\", NULL); ")
              code.append(f"     return NULL; // Or return NULL if no screen found")

         elif func_name == "screen_load" or func_name == "scr_load":
              code.append(f"    if (!{arg_names[0]} || !{arg_names[0]}->json_node) return;")
              # Add active screen ID to the root JSON object for the builder's info
              code.append(f"    cJSON_AddNumberToObject(g_emu_state.root_json, \"active_screen_id\", {arg_names[0]}->id);")
         elif func_name == "color_hex": # Example utility function
             code.append(f"    // Assuming input c is 0xRRGGBB")
             code.append(f"    uint32_t color_val = (uint32_t){arg_names[0]};")
             code.append(f"    // Convert to internal format (#AARRGGBB) - assuming 0xFF alpha")
             code.append(f"    return (0xFF000000 | color_val); // Return as lv_color_t (uint32_t)")
         elif func_name == "palette_main": # Example palette
              code.append(f"    // Map palette enum to a hex color (placeholder)")
              code.append(f"    // Requires LV_PALETTE_... enum definitions to be correct")
              code.append(f"    int p_idx = {arg_names[0]}; // Placeholder value")
              code.append(f"    uint32_t colors[] = {{0xFFF44336, 0xFFE91E63, 0xFF9C27B0 /* ... more ... */, 0xFF795548, 0xFF9E9E9E, 0xFF607D8B}};")
              code.append(f"    uint32_t color = (p_idx >= 0 && p_idx < sizeof(colors)/sizeof(colors[0])) ? colors[p_idx] : 0xFF000000;")
              code.append(f"    return (0xFF000000 | color); // Add alpha, return lv_color_t")

         # Add stubs or simple implementations for other relevant globals
         else:
             code.append(f"    // Functionality for '{c_func_name}' not fully implemented in emulator.")

         # Default return for non-void functions
         if ret_type != "void":
            if ret_type.endswith("*"): code.append(f"    return NULL;")
            elif ret_type == "bool": code.append(f"    return false;")
            elif "color" in ret_type.lower(): code.append(f"    return 0;") # Default black/transparent
            else: code.append(f"    return 0;") # Default int/float

         code.append(f"}}\n")


    # Object member functions (Setters, etc.)
    for obj_name, obj_data in data.get("objects", {}).items():
         # Focus on base 'obj' for now, expand later if needed for widget specifics
         # if obj_name != "obj": continue

         for func_name, func_data in obj_data.get("members", {}).items():
             # Use lv_obj_ prefix for base object members, lv_<widget>_ for others
             c_func_name = f"lv_{obj_name}_{func_name}" if obj_name != "obj" else f"lv_obj_{func_name}"

             if c_func_name in processed_funcs: continue # Skip already processed global/create/member
             if func_data["type"] != "function": continue

             # Apply filtering (copied and adjusted from header generation)
             if "event" in func_name or "timer" in func_name or "indev" in func_name or \
                    func_name.startswith("get_") or func_name.startswith("is_") or \
                    "style_get" in func_name or "hit_test" in func_name or \
                    "search" in func_name or "clean" in func_name or "del" in func_name or \
                    "refr" in func_name or "layout" in func_name or "state" in func_name or \
                    "class" in func_name or "event" in func_name or \
                    func_name.endswith("_cb"):
                 continue

             # Ensure first arg is lv_obj_t* (or appropriate widget type ptr)
             if not func_data["args"] or len(func_data["args"]) == 0 or not func_data["args"][0]["type"].startswith(f"lv_{obj_name}_t"):
                  if  len(func_data["args"]) == 0 or not (obj_name == "obj" and func_data["args"][0]["type"].startswith("lv_obj_t")):
                      continue # Skip if first arg doesn't match object type

             processed_funcs.add(c_func_name)
             processed_funcs.add(func_name) # Add base name too

             ret_type_str = func_data["return_type"]; ret_type = get_c_type_emu_header(ret_type_str)
             args_list = []; arg_names = []; arg_types = []
             for arg in func_data["args"]:
                  arg_type_str = arg["type"]
                  arg_type = get_c_type_emu_header(arg_type_str)
                  arg_name = sanitize_name(arg['name'])
                  args_list.append(f"{arg_type} {arg_name}")
                  arg_names.append(arg_name)
                  arg_types.append(arg_type_str) # Keep original JSON type string
             args_str = ", ".join(args_list) if args_list else "void"

             code.append(f"// --- {c_func_name} ---")
             code.append(f"{ret_type} {c_func_name}({args_str}) {{")
             obj_arg_name = arg_names[0]

             # Object validity check
             code.append(f"    if (!{obj_arg_name} || !{obj_arg_name}->json_node) {{")
             if ret_type != "void":
                if ret_type.endswith("*"): code.append(f"        return NULL;")
                elif ret_type == "bool": code.append(f"        return false;")
                elif "color" in ret_type.lower(): code.append(f"        return 0;")
                else: code.append(f"        return 0;")
             else: code.append(f"        return;")
             code.append(f"    }}")


             # --- Logic based on function name conventions ---
             is_style_func = func_name.startswith("set_style_")
             is_prop_func = func_name.startswith("set_") and not is_style_func
             # Flags/States are handled specifically for lv_obj_... funcs
             is_add_flag_func = (obj_name == "obj" and func_name == "add_flag")
             is_clear_flag_func = (obj_name == "obj" and func_name == "clear_flag")
             is_add_state_func = (obj_name == "obj" and func_name == "add_state")
             is_clear_state_func = (obj_name == "obj" and func_name == "clear_state")
             is_set_parent_func = (obj_name == "obj" and func_name == "set_parent")
             is_align_func = (obj_name == "obj" and func_name == "align")
             is_align_to_func = (obj_name == "obj" and func_name == "align_to")
             # Add other specific base obj functions like scroll_to, etc.

             value_arg_index = -1; part_arg_index = -1; state_arg_index = -1; prop_name = ""

             if is_prop_func:
                 # Assumes setter format: lv_obj_set_PROP(obj, value, ...)
                 # Or lv_widget_set_PROP(widget, value, ...)
                 if len(arg_names) > 1:
                     value_arg_index = 1
                     prop_name = func_name[len("set_"):] # e.g., "width", "height", "text", "value"
                 else: prop_name = func_name[len("set_"):] # Handle setters with no value arg? (e.g., set_click?)

             elif is_style_func:
                 # Assumes format: lv_obj_set_style_PROP(obj, value, selector)
                 # Or lv_obj_set_style_PROP(obj, value, part, state) - Need more robust detection
                 style_prop_name_parts = func_name.split('_')[2:] # Skip set_style
                 prop_name = "_".join(style_prop_name_parts)

                 # Determine part/state indices based on number and types of args
                 if len(arg_names) >= 3: # Must have obj, value, selector/state
                     value_arg_index = 1
                     # Check last arg: if it's int-like, assume it's selector/state
                     if arg_types[-1] == 'int':
                         state_arg_index = len(arg_names) - 1
                     else: # Maybe selector omitted, defaults to 0? Risky assumption.
                         state_arg_index = -1 # Indicate default state needed

                     # Check for part arg (usually before state if 4+ args and int)
                     if len(arg_names) >= 4 and arg_types[-2] == 'int' and state_arg_index == len(arg_names) -1:
                         part_arg_index = len(arg_names) - 2
                     else:
                         part_arg_index = -1 # Indicate default part needed

                 else: # Invalid style function signature?
                      value_arg_index = -1 # Mark as unhandled

             elif is_set_parent_func and len(arg_names) == 2:
                 parent_arg_name = arg_names[1]
                 code.append(f"    uint32_t parent_id = {parent_arg_name} ? {parent_arg_name}->id : 0;")
                 code.append(f"    // Update parent_id in JSON (don't delete/re-add, just replace)")
                 code.append(f"    cJSON_ReplaceItemInObjectCaseSensitive({obj_arg_name}->json_node, \"parent_id\", cJSON_CreateNumber(parent_id));")

             elif is_align_func and len(arg_names) == 2: # lv_obj_align(obj, align_enum)
                 prop_name = "align"; value_arg_index = 1; is_prop_func = True # Treat as simple property

             elif is_align_to_func and len(arg_names) >= 4: # lv_obj_align_to(obj, base, align, x, y)
                 # Store as complex property "align_to"
                 code.append(f"    cJSON* align_info = cJSON_CreateObject();")
                 code.append("    if (align_info) {")#: # Check creation
                 code.append(f"        lv_emu_add_obj_ref_to_json(align_info, \"base_obj\", {arg_names[1]});")
                 code.append(f"        lv_emu_add_enum_to_json(align_info, \"align_type\", {arg_names[2]}, \"ALIGN\");")
                 code.append(f"        cJSON* offset = cJSON_CreateObject();")
                 code.append("        if (offset) {")
                 # if offset:
                 code.append(f"            cJSON_AddNumberToObject(offset, \"x\", {arg_names[3]});")
                 code.append(f"            cJSON_AddNumberToObject(offset, \"y\", {arg_names[4]});")
                 code.append(f"            cJSON_AddItemToObject(align_info, \"offset\", offset);")
                 code.append("        }")
                 code.append(f"        lv_emu_set_obj_property({obj_arg_name}, \"align_to\", align_info);")
                 code.append("   }")
                 # else { handle align_info creation error }

             elif is_add_flag_func or is_clear_flag_func:
                  if len(arg_names) == 2:
                       flag_arg_name = arg_names[1]
                       flag_enum_name = "OBJ_FLAG" # Assume this is the enum name for flags
                       code.append(f"    const char* flag_name_str = lv_emu_enum_to_string({flag_arg_name}, \"{flag_enum_name}\");")
                       code.append(f"    cJSON* flags_array = lv_emu_get_or_create_json_array({obj_arg_name}->json_node, \"flags\");")
                       code.append(f"    if (flags_array && flag_name_str) {{")
                       code.append(f"        int i; cJSON *item;")
                       code.append(f"        bool found = false;")
                       code.append(f"        int current_size = cJSON_GetArraySize(flags_array);")
                       code.append(f"        for (i = current_size - 1; i >= 0; i--) {{ // Iterate backwards for safe deletion")
                       code.append(f"            item = cJSON_GetArrayItem(flags_array, i);")
                       code.append(f"            if (cJSON_IsString(item) && strcmp(item->valuestring, flag_name_str) == 0) {{")
                       code.append(f"                found = true;")
                       if is_clear_flag_func:
                           code.append(f"                cJSON_DeleteItemFromArray(flags_array, i);")
                       code.append(f"                break;") # Assume only one instance of flag
                       code.append(f"            }}")
                       code.append(f"        }}")
                       if is_add_flag_func:
                           code.append("    if (!found) {");
                       code.append(f"        cJSON_AddItemToArray(flags_array, cJSON_CreateString(flag_name_str));")
                       code.append(f"    }}")

             elif is_add_state_func or is_clear_state_func:
                  if len(arg_names) == 2:
                       state_arg_name = arg_names[1]
                       state_enum_name = "STATE" # Assume this is the enum name
                       code.append(f"    const char* state_name_str = lv_emu_enum_to_string({state_arg_name}, \"{state_enum_name}\");")
                       code.append(f"    cJSON* states_array = lv_emu_get_or_create_json_array({obj_arg_name}->json_node, \"states\");")
                       code.append(f"    if (states_array && state_name_str) {{")
                       code.append(f"        int i; cJSON *item;")
                       code.append(f"        bool found = false;")
                       code.append(f"        int current_size = cJSON_GetArraySize(states_array);")
                       code.append(f"        for (i = current_size - 1; i >= 0; i--) {{ // Iterate backwards")
                       code.append(f"            item = cJSON_GetArrayItem(states_array, i);")
                       code.append(f"            if (cJSON_IsString(item) && strcmp(item->valuestring, state_name_str) == 0) {{")
                       code.append(f"                found = true;")
                       if is_clear_state_func:
                           code.append(f"                cJSON_DeleteItemFromArray(states_array, i);")
                       code.append(f"                break;")
                       code.append(f"            }}")
                       code.append(f"        }}")
                       if is_add_state_func and not found:
                           code.append(f"        cJSON_AddItemToArray(states_array, cJSON_CreateString(state_name_str));")
                       code.append(f"    }}")

             # --- Generate JSON update code for properties/styles ---
             elif value_arg_index >= 0 and prop_name: # Ensure value index is valid
                 value_arg_name = arg_names[value_arg_index]
                 value_arg_type = arg_types[value_arg_index] # Original JSON type string

                 # Get type info for implementation (handles registries, basic types, enums)
                 type_info = get_c_type_info_emu_impl(value_arg_type)
                 json_add_func = type_info['json_add']
                 registry_type = type_info.get('registry')
                 enum_name_for_arg = type_info.get('enum_name') # Get enum name if type is enum


                 code.append(f"    // --- Property/Style: {prop_name} ---")
                 code.append(f"    cJSON* value_json = NULL;")
                 value_json_creation_str = "" # Store the C code to create the JSON value

                 if json_add_func == "cJSON_AddNumberToObject": value_json_creation_str = f"cJSON_CreateNumber((double){value_arg_name})"
                 elif json_add_func == "cJSON_AddBoolToObject": value_json_creation_str = f"cJSON_CreateBool({value_arg_name})"
                 elif json_add_func == "cJSON_AddStringToObject": value_json_creation_str = f"cJSON_CreateString({value_arg_name} ? {value_arg_name} : \"\")"
                 elif json_add_func == "lv_emu_add_obj_ref_to_json": value_json_creation_str = f"cJSON_CreateNumber({value_arg_name} ? {value_arg_name}->id : 0)"
                 elif json_add_func == "lv_emu_add_color_to_json":
                      code.append(f"    char hex_color[10]; snprintf(hex_color, sizeof(hex_color), \"#%08X\", (uint32_t){value_arg_name});")
                      value_json_creation_str = "cJSON_CreateString(hex_color)"
                 elif json_add_func == "lv_emu_add_color32_to_json":
                      code.append(f"    char hex_color32[10]; snprintf(hex_color32, sizeof(hex_color32), \"#%08X\", (uint32_t){value_arg_name});")
                      value_json_creation_str = "cJSON_CreateString(hex_color32)"
                 elif json_add_func == "lv_emu_add_point_to_json":
                      # Create JSON object directly in C code block
                      code.append(f"    value_json = cJSON_CreateObject(); if(value_json){{ cJSON_AddNumberToObject(value_json, \"x\", {value_arg_name}.x); cJSON_AddNumberToObject(value_json, \"y\", {value_arg_name}.y); }}")
                      value_json_creation_str = "value_json" # Indicate variable holds the value
                 elif json_add_func == "lv_emu_add_area_to_json":
                      # Create JSON object directly in C code block
                      code.append(f"    value_json = cJSON_CreateObject(); if(value_json){{ cJSON_AddNumberToObject(value_json, \"x1\", {value_arg_name}.x1); cJSON_AddNumberToObject(value_json, \"y1\", {value_arg_name}.y1); cJSON_AddNumberToObject(value_json, \"x2\", {value_arg_name}.x2); cJSON_AddNumberToObject(value_json, \"y2\", {value_arg_name}.y2); }}")
                      value_json_creation_str = "value_json" # Indicate variable holds the value
                 elif json_add_func == "lv_emu_add_registry_ref_to_json":
                     registry_ptr_str = f"g_emu_state.{registry_type}_registry" if registry_type else "NULL"
                     code.append(f"    const char *reg_name = lv_emu_find_registry_name({value_arg_name}, {registry_ptr_str});")
                     value_json_creation_str = f"cJSON_CreateString(reg_name ? reg_name : \"unregistered\")"
                 elif json_add_func == "lv_emu_add_enum_to_json": # Handle enum types specifically
                      if enum_name_for_arg:
                           code.append(f"    const char* enum_str = lv_emu_enum_to_string({value_arg_name}, \"{enum_name_for_arg}\");")
                           value_json_creation_str = "cJSON_CreateString(enum_str)"
                      else: # Fallback if enum name detection failed
                           value_json_creation_str = f"cJSON_CreateNumber((double){value_arg_name})" # Store as number
                 elif json_add_func == "lv_emu_add_unhandled_to_json":
                      code.append(f"    char unhandled_buf[64]; snprintf(unhandled_buf, sizeof(unhandled_buf), \"unhandled_ptr:%p\", (void*){value_arg_name});")
                      value_json_creation_str = "cJSON_CreateString(unhandled_buf)"
                 else: # Default fallback if no specific handler matched
                     # Should ideally not happen if get_c_type_info_emu_impl is robust
                     code.append(f"    // Defaulting to number for unhandled type {value_arg_type}")
                     value_json_creation_str = f"cJSON_CreateNumber((double){value_arg_name})"

                 # Add the created JSON value to the correct place
                 if value_json_creation_str:
                     if value_json_creation_str != "value_json": # If creation string generates the value
                         code.append(f"    value_json = {value_json_creation_str};")

                     if is_prop_func:
                         code.append(f"    lv_emu_set_obj_property({obj_arg_name}, \"{prop_name}\", value_json);")
                     elif is_style_func:
                         # Use determined or default part/state values
                         part_arg_val = f"{arg_names[part_arg_index]}" if part_arg_index >= 0 else "LV_PART_MAIN"
                         state_arg_val = f"{arg_names[state_arg_index]}" if state_arg_index >= 0 else "LV_STATE_DEFAULT"
                         code.append(f"    // Applying style '{prop_name}' to part={part_arg_val}, state={state_arg_val}")
                         code.append(f"    lv_emu_set_obj_style_property({obj_arg_name}, {part_arg_val}, {state_arg_val}, \"{prop_name}\", value_json);")
                     else:
                          code.append(f"    // Value created but no handler to apply it?")
                          code.append(f"    cJSON_Delete(value_json); // Clean up unused value")

                 else:
                      code.append(f"    // Failed to determine JSON creation for {prop_name}")


             else: # Function doesn't match known patterns (setters, align, flags, etc.)
                  code.append(f"    // Logic for {c_func_name} not implemented.")


             # Default return for non-void functions
             if ret_type != "void":
                if ret_type.endswith("*"): code.append(f"    return NULL;")
                elif ret_type == "bool": code.append(f"    return false;")
                elif "color" in ret_type.lower(): code.append(f"    return 0;")
                else: code.append(f"    return 0;")
             code.append(f"}}\n") # End function implementation

    return "\n".join(code)


def generate_emulator_source(data):
    """Generates the full lvgl_emulation.c source file"""
    enum_to_string_code = generate_emulator_enum_to_string_func(data)
    # Pass data and the generated enum function code to the main implementation generator
    full_source_code = generate_emulator_source_impl(data, enum_to_string_code)
    return full_source_code


# Helper function to structure builder source generation
def generate_builder_source_impl(data, string_to_enum_impl_code):
    code = []
    code.append("// Generated by generate_lvgl_emu.py - DO NOT EDIT")
    code.append("#include \"ui_builder.h\"")
    code.append("#include <stdio.h>")
    code.append("#include <stdlib.h>")
    code.append("#include <string.h>")
    code.append("#include <stdarg.h>")
    code.append("\n// Simple String->Pointer Hash Map (uthash.h)")
    code.append("#include \"uthash.h\"") # Get uthash.h from https://troydhanson.github.io/uthash/
    code.append("\ntypedef struct {")
    code.append("    const char *name; // Key: Name from JSON (needs to be stable)")
    code.append("    const void *ptr;  // Value: Actual LVGL pointer")
    code.append("    UT_hash_handle hh;")
    code.append("} ui_builder_registry_entry_t;")
    code.append("\n// Simple ID->lv_obj_t* Hash Map (uthash.h)")
    code.append("typedef struct {")
    code.append("    uint32_t id;      // Key: ID from JSON")
    code.append("    lv_obj_t *obj;    // Value: Created LVGL object pointer")
    code.append("    UT_hash_handle hh;")
    code.append("} ui_builder_id_map_entry_t;")
    code.append("\n// Builder Global State")
    code.append("typedef struct {")
    code.append("    ui_builder_registry_entry_t *font_registry;")
    code.append("    ui_builder_registry_entry_t *image_src_registry;")
    code.append("    ui_builder_registry_entry_t *generic_registry;")
    code.append("    ui_builder_id_map_entry_t *id_map;")
    code.append("    ui_builder_error_cb_t error_cb;")
    code.append("} ui_builder_state_t;")
    code.append("\nstatic ui_builder_state_t g_builder_state = {0};")

    code.append("\n// --- Forward Declarations ---")
    code.append("static lv_obj_t* build_object_recursive(cJSON *obj_json, lv_obj_t* parent_obj);")
    code.append("static void apply_properties(lv_obj_t *obj, uint32_t obj_id, cJSON *props_json);")
    code.append("static void apply_styles(lv_obj_t *obj, cJSON *styles_json);")
    code.append("static void apply_flags_and_states(lv_obj_t *obj, cJSON *obj_json);")
    code.append("static const void* ui_builder_find_registry_ptr(const char *name, ui_builder_registry_entry_t *registry);")
    code.append("static void ui_builder_register_internal(const char *name, const void *ptr, ui_builder_registry_entry_t **registry);")

    code.append("\n// --- Generated Enum Mapping Function ---")
    code.append(string_to_enum_impl_code) # Inject generated enum function
    code.append("// --- End Enum Mapping Function ---\n")

    code.append("static lv_color_t ui_builder_parse_color(cJSON *color_json);")
    code.append("static lv_color32_t ui_builder_parse_color32(cJSON *color_json);")
    code.append("static lv_point_t ui_builder_parse_point(cJSON *point_json);")
    code.append("static lv_area_t ui_builder_parse_area(cJSON *area_json);")
    code.append("static void ui_builder_report_error(const char *fmt, ...);")
    code.append("static void ui_builder_add_obj_to_map(uint32_t id, lv_obj_t *obj);")
    code.append("static lv_obj_t* ui_builder_find_obj_by_id(uint32_t id);")

    code.append("\n// --- Error Reporting ---")
    code.append("""
static void ui_builder_report_error(const char *fmt, ...) {
    char buffer[256]; // Static buffer for simplicity
    va_list args;
    va_start(args, fmt);
    vsnprintf(buffer, sizeof(buffer), fmt, args);
    va_end(args);
    buffer[sizeof(buffer) - 1] = '\\0'; // Ensure null termination

    if (g_builder_state.error_cb) {
        g_builder_state.error_cb(buffer);
    } else {
        // Default: print to stderr if no callback is set
        fprintf(stderr, "UI Builder Error: %s\\n", buffer);
    }
}

void ui_builder_set_error_cb(ui_builder_error_cb_t cb) { g_builder_state.error_cb = cb; }
""")


    code.append("\n// --- Builder Control Implementations ---")
    code.append("""
void ui_builder_init(void) { ui_builder_deinit(); } // Simple init clears state

void ui_builder_deinit(void) {
    ui_builder_registry_entry_t *reg_current, *reg_tmp;
    ui_builder_id_map_entry_t *id_current, *id_tmp;
    // Free registry entries (including duplicated names)
    HASH_ITER(hh, g_builder_state.font_registry, reg_current, reg_tmp) { HASH_DEL(g_builder_state.font_registry, reg_current); free((void*)reg_current->name); free(reg_current); }
    HASH_ITER(hh, g_builder_state.image_src_registry, reg_current, reg_tmp) { HASH_DEL(g_builder_state.image_src_registry, reg_current); free((void*)reg_current->name); free(reg_current); }
    HASH_ITER(hh, g_builder_state.generic_registry, reg_current, reg_tmp) { HASH_DEL(g_builder_state.generic_registry, reg_current); free((void*)reg_current->name); free(reg_current); }
    // Clear ID map (objects are managed by LVGL)
    HASH_ITER(hh, g_builder_state.id_map, id_current, id_tmp) { HASH_DEL(g_builder_state.id_map, id_current); free(id_current); }
    memset(&g_builder_state, 0, sizeof(g_builder_state)); // Clear state struct
}

static void ui_builder_register_internal(const char *name, const void *ptr, ui_builder_registry_entry_t **registry) {
    if (!ptr || !name) return;
    ui_builder_registry_entry_t *entry;
    HASH_FIND_STR(*registry, name, entry);
    if (entry == NULL) {
        entry = (ui_builder_registry_entry_t*)malloc(sizeof(ui_builder_registry_entry_t));
        if(!entry) { ui_builder_report_error("Malloc failed for registry entry '%s'", name); return; }
        entry->name = strdup(name); // Duplicate name string for hash table key
        if (!entry->name) { free(entry); ui_builder_report_error("strdup failed for registry name '%s'", name); return; }
        entry->ptr = ptr;
        HASH_ADD_KEYPTR(hh, *registry, entry->name, strlen(entry->name), entry);
    } else {
        // Name exists, update pointer? Could be an error depending on use case.
        // ui_builder_report_error("Warning: Registry name '%s' already exists, updating pointer.", name);
        entry->ptr = ptr;
    }
}

void ui_builder_register_font(const char *name, const lv_font_t *font) { ui_builder_register_internal(name, font, &g_builder_state.font_registry); }
void ui_builder_register_image_src(const char *name, const void *src) { ui_builder_register_internal(name, src, &g_builder_state.image_src_registry); }
void ui_builder_register_generic(const char *name, const void *ptr) { ui_builder_register_internal(name, ptr, &g_builder_state.generic_registry); }

static const void* ui_builder_find_registry_ptr(const char *name, ui_builder_registry_entry_t *registry) {
    if (!name || !registry) return NULL;
    ui_builder_registry_entry_t *entry;
    HASH_FIND_STR(registry, name, entry);
    if (!entry) {
        // Report error only once? Or let caller handle NULL? Reporting here is useful for debug.
        ui_builder_report_error("Registry entry '%s' not found.", name);
    }
    return entry ? entry->ptr : NULL;
}

static lv_obj_t* ui_builder_find_obj_by_id(uint32_t id) {
    if (id == 0) return NULL; // 0 represents NULL parent (e.g., screen)
    ui_builder_id_map_entry_t *entry;
    HASH_FIND_INT(g_builder_state.id_map, &id, entry);
    // Don't report error here, parent might not be created yet in single pass
    return entry ? entry->obj : NULL;
}

static void ui_builder_add_obj_to_map(uint32_t id, lv_obj_t *obj) {
    if (id == 0 || !obj) return;
    ui_builder_id_map_entry_t *entry;
    HASH_FIND_INT(g_builder_state.id_map, &id, entry);
    if (entry == NULL) {
        entry = (ui_builder_id_map_entry_t*)malloc(sizeof(ui_builder_id_map_entry_t));
        if(!entry) { ui_builder_report_error("Malloc failed for id map entry %u", id); return; }
        entry->id = id;
        entry->obj = obj;
        HASH_ADD_INT(g_builder_state.id_map, id, entry);
    } else {
        // ID collision? Should not happen if emulator generates unique IDs.
        ui_builder_report_error("Warning: Object ID %u already exists in map, overwriting.", id);
        entry->obj = obj;
    }
}
""")

    code.append("\n// --- JSON Parsing Helper Implementations ---")
    # (Copy implementations of parse_color, parse_color32, parse_point, parse_area from previous script)
    code.append("""
static lv_color_t ui_builder_parse_color(cJSON *color_json) {
    if (!cJSON_IsString(color_json)) return lv_color_black(); // Default
    const char* hex_str = color_json->valuestring;
    if (hex_str[0] != '#') return lv_color_black();
    uint32_t hex_val = (uint32_t)strtoul(hex_str + 1, NULL, 16);
    // Assuming #AARRGGBB or #RRGGBB format from emulator
    uint8_t r = (hex_val >> 16) & 0xFF;
    uint8_t g = (hex_val >> 8) & 0xFF;
    uint8_t b = hex_val & 0xFF;
    // Let lv_color_make handle conversion based on LV_COLOR_DEPTH
    return lv_color_make(r, g, b);
}

static lv_color32_t ui_builder_parse_color32(cJSON *color_json) {
     lv_color32_t c32 = {.full = 0}; // Initialize to black, full transparent
     if (!cJSON_IsString(color_json)) return c32;
     const char* hex_str = color_json->valuestring;
     if (hex_str[0] != '#') return c32;
     uint32_t hex_val = (uint32_t)strtoul(hex_str + 1, NULL, 16);
     // If #RRGGBB format, add full alpha
     if (strlen(hex_str + 1) == 6) hex_val |= 0xFF000000;
     c32.full = hex_val; // Assuming lv_color32_t has .full or similar union/struct access
     return c32;
}

static lv_point_t ui_builder_parse_point(cJSON *point_json) {
    lv_point_t p = {0, 0};
    if (!cJSON_IsObject(point_json)) return p;
    cJSON *x = cJSON_GetObjectItemCaseSensitive(point_json, "x");
    cJSON *y = cJSON_GetObjectItemCaseSensitive(point_json, "y");
    if (cJSON_IsNumber(x)) p.x = (lv_coord_t)x->valuedouble;
    if (cJSON_IsNumber(y)) p.y = (lv_coord_t)y->valuedouble;
    return p;
}

static lv_area_t ui_builder_parse_area(cJSON *area_json) {
    lv_area_t a = {0, 0, 0, 0};
    if (!cJSON_IsObject(area_json)) return a;
    cJSON *x1 = cJSON_GetObjectItemCaseSensitive(area_json, "x1");
    cJSON *y1 = cJSON_GetObjectItemCaseSensitive(area_json, "y1");
    cJSON *x2 = cJSON_GetObjectItemCaseSensitive(area_json, "x2");
    cJSON *y2 = cJSON_GetObjectItemCaseSensitive(area_json, "y2");
    if (cJSON_IsNumber(x1)) a.x1 = (lv_coord_t)x1->valuedouble;
    if (cJSON_IsNumber(y1)) a.y1 = (lv_coord_t)y1->valuedouble;
    if (cJSON_IsNumber(x2)) a.x2 = (lv_coord_t)x2->valuedouble;
    if (cJSON_IsNumber(y2)) a.y2 = (lv_coord_t)y2->valuedouble;
    return a;
}
""")


    code.append("\n// --- Builder Core Logic ---")
    # (Copy implementations of build_object_recursive, apply_flags_and_states, apply_properties, apply_styles, load_json from previous script)
    # Ensure these functions use the generated ui_builder_enum_from_string where needed.
    code.append("""
static void apply_flags_and_states(lv_obj_t *obj, cJSON *obj_json) {
     if(!obj || !obj_json) return;
     cJSON *flags_array = cJSON_GetObjectItemCaseSensitive(obj_json, "flags");
     if (cJSON_IsArray(flags_array)) {
         cJSON *flag_item;
         cJSON_ArrayForEach(flag_item, flags_array) {
             if (cJSON_IsString(flag_item) && flag_item->valuestring) {
                 // Use generated enum mapping (assuming "OBJ_FLAG" is correct name)
                 lv_obj_flag_t flag = (lv_obj_flag_t)ui_builder_enum_from_string(flag_item->valuestring, "OBJ_FLAG");
                 // Avoid adding flag 0 if that's the default/error return
                 // Check specific flags like HIDDEN etc. if needed.
                 // For now, add whatever the function returns. Check LVGL if 0 is a valid flag.
                 lv_obj_add_flag(obj, flag);
             }
         }
     }
     // Note: Flags cleared by default on creation. This only adds flags.

     cJSON *states_array = cJSON_GetObjectItemCaseSensitive(obj_json, "states");
     if (cJSON_IsArray(states_array)) {
         cJSON *state_item;
         cJSON_ArrayForEach(state_item, states_array) {
             if (cJSON_IsString(state_item) && state_item->valuestring) {
                 // Use generated enum mapping
                 lv_state_t state = (lv_state_t)ui_builder_enum_from_string(state_item->valuestring, "STATE");
                 // Add the state (LVGL handles duplicates)
                 lv_obj_add_state(obj, state);
             }
         }
     }
     // Note: States cleared by default. This only adds states.
}

static void apply_properties(lv_obj_t *obj, uint32_t obj_id, cJSON *props_json) {
    if (!obj || !props_json) return;
    cJSON *prop = NULL;
    cJSON_ArrayForEach(prop, props_json) { // Iterate properties object
        const char* prop_name = prop->key;
        if (!prop_name) continue;

        // Map prop_name to lv_obj_set_... or lv_widget_set_... function
        // --- Size and Position ---
        if (strcmp(prop_name, "width") == 0 && cJSON_IsNumber(prop)) {
            lv_obj_set_width(obj, (lv_coord_t)prop->valuedouble);
        } else if (strcmp(prop_name, "height") == 0 && cJSON_IsNumber(prop)) {
            lv_obj_set_height(obj, (lv_coord_t)prop->valuedouble);
        } else if (strcmp(prop_name, "x") == 0 && cJSON_IsNumber(prop)) {
             lv_obj_set_x(obj, (lv_coord_t)prop->valuedouble);
        } else if (strcmp(prop_name, "y") == 0 && cJSON_IsNumber(prop)) {
             lv_obj_set_y(obj, (lv_coord_t)prop->valuedouble);
        } else if (strcmp(prop_name, "align") == 0 && cJSON_IsString(prop) && prop->valuestring) {
             lv_align_t align_val = (lv_align_t)ui_builder_enum_from_string(prop->valuestring, "ALIGN");
             lv_obj_set_align(obj, align_val);
        } else if (strcmp(prop_name, "align_to") == 0 && cJSON_IsObject(prop)) {
             cJSON *base_obj_json = cJSON_GetObjectItemCaseSensitive(prop, "base_obj");
             cJSON *align_type_json = cJSON_GetObjectItemCaseSensitive(prop, "align_type");
             cJSON *offset_json = cJSON_GetObjectItemCaseSensitive(prop, "offset");
             if(cJSON_IsNumber(base_obj_json) && cJSON_IsString(align_type_json) && align_type_json->valuestring) {
                 lv_obj_t* base_obj = ui_builder_find_obj_by_id((uint32_t)base_obj_json->valuedouble);
                 if(base_obj) {
                     lv_align_t align_val = (lv_align_t)ui_builder_enum_from_string(align_type_json->valuestring, "ALIGN");
                     lv_coord_t x_ofs = 0, y_ofs = 0;
                     if(cJSON_IsObject(offset_json)) {
                         lv_point_t offset_pt = ui_builder_parse_point(offset_json);
                         x_ofs = offset_pt.x; y_ofs = offset_pt.y;
                     }
                     lv_obj_align_to(obj, base_obj, align_val, x_ofs, y_ofs);
                 } else { ui_builder_report_error("Align_to: Base object ID %u not found for object %u", (unsigned int)base_obj_json->valuedouble, obj_id); }
             } else { ui_builder_report_error("Invalid align_to property format for object %u", obj_id); }
        }
        // --- Widget Specific Properties ---
        else if (strcmp(prop_name, "text") == 0 && cJSON_IsString(prop) && prop->valuestring) {
             // Check obj type? Assume label or button for now
             if (lv_obj_check_type(obj, &lv_label_class)) {
                 lv_label_set_text(obj, prop->valuestring);
             } else if (lv_obj_check_type(obj, &lv_button_class)) {
                 // Buttons often have a label child. Find or create it.
                 lv_obj_t* label = lv_obj_get_child(obj, 0); // Simple assumption: first child is label
                 if (!label || !lv_obj_check_type(label, &lv_label_class)) {
                     label = lv_label_create(obj); // Create if not found or wrong type
                     if(label) lv_obj_center(label);
                 }
                 if(label) lv_label_set_text(label, prop->valuestring);
                 else { ui_builder_report_error("Could not find/create label for button %u", obj_id); }
             } else if (lv_obj_check_type(obj, &lv_textarea_class)) {
                 lv_textarea_set_text(obj, prop->valuestring);
             } // Add other text-based widgets...
             else { ui_builder_report_error("Setting 'text' property on unsupported object type for obj %u", obj_id); }
        } else if (strcmp(prop_name, "value") == 0 && cJSON_IsNumber(prop)) {
             // Assume Slider or Bar or Arc...
             if (lv_obj_check_type(obj, &lv_slider_class)) { lv_slider_set_value(obj, (int32_t)prop->valuedouble, LV_ANIM_OFF); }
             else if (lv_obj_check_type(obj, &lv_bar_class)) { lv_bar_set_value(obj, (int32_t)prop->valuedouble, LV_ANIM_OFF); }
             else if (lv_obj_check_type(obj, &lv_arc_class)) { lv_arc_set_value(obj, (int16_t)prop->valuedouble); }
             // Add spinner etc.
             else { ui_builder_report_error("Setting 'value' property on unsupported object type for obj %u", obj_id); }
        } else if (strcmp(prop_name, "src") == 0) { // For images
            if (lv_obj_check_type(obj, &lv_image_class)) {
                if (cJSON_IsString(prop) && prop->valuestring) { // Assume name in registry
                     const void* img_src = ui_builder_find_registry_ptr(prop->valuestring, g_builder_state.image_src_registry);
                     if (img_src) { lv_image_set_src(obj, img_src); }
                     // Error reported by find_registry_ptr if not found
                } // Could potentially handle embedded base64 data here too
            } else { ui_builder_report_error("Setting 'src' property on non-image object %u", obj_id); }
        }
        // Add MANY more property mappings based on lv_def.json and LVGL API...
        // e.g., range for slider/bar, options for dropdown, checked for checkbox/switch...

        else {
            ui_builder_report_error("Unsupported property '%s' for object %u", prop_name, obj_id);
        }
    }
}


static void apply_styles(lv_obj_t *obj, cJSON *styles_array) {
    if(!obj || !styles_array) return;
    cJSON *style_entry = NULL;
    cJSON_ArrayForEach(style_entry, styles_array) {
        if (!cJSON_IsObject(style_entry)) continue;

        cJSON *part_json = cJSON_GetObjectItemCaseSensitive(style_entry, "part");
        cJSON *selector_json = cJSON_GetObjectItemCaseSensitive(style_entry, "selector"); // State
        cJSON *props_json = cJSON_GetObjectItemCaseSensitive(style_entry, "props");

        if (!cJSON_IsString(part_json) || !cJSON_IsString(selector_json) || !cJSON_IsObject(props_json) ||
            !part_json->valuestring || !selector_json->valuestring) {
            ui_builder_report_error("Invalid style entry format");
            continue;
        }

        // Use generated enum mapping
        lv_part_t part = (lv_part_t)ui_builder_enum_from_string(part_json->valuestring, "PART");
        lv_state_t state = (lv_state_t)ui_builder_enum_from_string(selector_json->valuestring, "STATE");
        lv_style_selector_t selector = part | state; // Combine part and state for selector


        // Iterate through properties within this style entry
        cJSON *prop = NULL;
        cJSON_ArrayForEach(prop, props_json) { // Iterate through properties object
             const char* prop_name = prop->key;
             if (!prop_name) continue;

            // --- Map style prop_name to lv_obj_set_style_... function ---
            // --- BG ---
            if (strcmp(prop_name, "bg_color") == 0) { lv_obj_set_style_bg_color(obj, ui_builder_parse_color(prop), selector); }
            else if (strcmp(prop_name, "bg_opa") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_bg_opa(obj, (lv_opa_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "bg_grad_color") == 0) { lv_obj_set_style_bg_grad_color(obj, ui_builder_parse_color(prop), selector); }
            else if (strcmp(prop_name, "bg_grad_dir") == 0 && cJSON_IsString(prop) && prop->valuestring) { lv_grad_dir_t val = (lv_grad_dir_t)ui_builder_enum_from_string(prop->valuestring, "GRAD_DIR"); lv_obj_set_style_bg_grad_dir(obj, val, selector); }
             // Add bg_main_stop, bg_grad_stop, bg_image_src (registry), etc.
            else if (strcmp(prop_name, "bg_image_src") == 0 && cJSON_IsString(prop) && prop->valuestring) { const void* src = ui_builder_find_registry_ptr(prop->valuestring, g_builder_state.image_src_registry); if(src) lv_obj_set_style_bg_image_src(obj, src, selector); }

             // --- Border ---
            else if (strcmp(prop_name, "border_color") == 0) { lv_obj_set_style_border_color(obj, ui_builder_parse_color(prop), selector); }
            else if (strcmp(prop_name, "border_width") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_border_width(obj, (lv_coord_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "border_opa") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_border_opa(obj, (lv_opa_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "border_side") == 0 && cJSON_IsString(prop) && prop->valuestring) { lv_border_side_t val = (lv_border_side_t)ui_builder_enum_from_string(prop->valuestring, "BORDER_SIDE"); lv_obj_set_style_border_side(obj, val, selector); }

             // --- Outline ---
            else if (strcmp(prop_name, "outline_color") == 0) { lv_obj_set_style_outline_color(obj, ui_builder_parse_color(prop), selector); }
            else if (strcmp(prop_name, "outline_width") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_outline_width(obj, (lv_coord_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "outline_pad") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_outline_pad(obj, (lv_coord_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "outline_opa") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_outline_opa(obj, (lv_opa_t)prop->valuedouble, selector); }

             // --- Shadow ---
            else if (strcmp(prop_name, "shadow_color") == 0) { lv_obj_set_style_shadow_color(obj, ui_builder_parse_color(prop), selector); }
            else if (strcmp(prop_name, "shadow_width") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_shadow_width(obj, (lv_coord_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "shadow_opa") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_shadow_opa(obj, (lv_opa_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "shadow_offset_x") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_shadow_offset_x(obj, (lv_coord_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "shadow_offset_y") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_shadow_offset_y(obj, (lv_coord_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "shadow_spread") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_shadow_spread(obj, (lv_coord_t)prop->valuedouble, selector); }

             // --- Padding ---
            else if (strcmp(prop_name, "pad_top") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_pad_top(obj, (lv_coord_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "pad_bottom") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_pad_bottom(obj, (lv_coord_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "pad_left") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_pad_left(obj, (lv_coord_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "pad_right") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_pad_right(obj, (lv_coord_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "pad_row") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_pad_row(obj, (lv_coord_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "pad_column") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_pad_column(obj, (lv_coord_t)prop->valuedouble, selector); }

             // --- Text ---
            else if (strcmp(prop_name, "text_color") == 0) { lv_obj_set_style_text_color(obj, ui_builder_parse_color(prop), selector); }
            else if (strcmp(prop_name, "text_opa") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_text_opa(obj, (lv_opa_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "text_font") == 0 && cJSON_IsString(prop) && prop->valuestring) { const lv_font_t* font = (const lv_font_t*)ui_builder_find_registry_ptr(prop->valuestring, g_builder_state.font_registry); if (font) lv_obj_set_style_text_font(obj, font, selector); /* Error reported by find */ }
            else if (strcmp(prop_name, "text_letter_space") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_text_letter_space(obj, (lv_coord_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "text_line_space") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_text_line_space(obj, (lv_coord_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "text_align") == 0 && cJSON_IsString(prop) && prop->valuestring) { lv_text_align_t val = (lv_text_align_t)ui_builder_enum_from_string(prop->valuestring, "TEXT_ALIGN"); lv_obj_set_style_text_align(obj, val, selector); }
            else if (strcmp(prop_name, "text_decor") == 0 && cJSON_IsString(prop) && prop->valuestring) { lv_text_decor_t val = (lv_text_decor_t)ui_builder_enum_from_string(prop->valuestring, "TEXT_DECOR"); lv_obj_set_style_text_decor(obj, val, selector); }

             // --- Size / Transform (Style versions) ---
            else if (strcmp(prop_name, "width") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_width(obj, (lv_coord_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "height") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_height(obj, (lv_coord_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "radius") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_radius(obj, (lv_coord_t)prop->valuedouble, selector); }
            // Note: Transform properties might need lv_value_precise_t in newer LVGL. Casting double might work for int32_t.
            else if (strcmp(prop_name, "transform_scale_x") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_transform_scale_x(obj, (int32_t)(prop->valuedouble * 256.0), selector); } // LVGL uses 256 as 1.0 for scale/zoom
            else if (strcmp(prop_name, "transform_scale_y") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_transform_scale_y(obj, (int32_t)(prop->valuedouble * 256.0), selector); }
            else if (strcmp(prop_name, "transform_rotation") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_transform_rotation(obj, (int32_t)(prop->valuedouble * 10.0), selector); } // LVGL uses angle * 10
            else if (strcmp(prop_name, "transform_pivot_x") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_transform_pivot_x(obj, (lv_coord_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "transform_pivot_y") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_transform_pivot_y(obj, (lv_coord_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "translate_x") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_translate_x(obj, (lv_coord_t)prop->valuedouble, selector); }
            else if (strcmp(prop_name, "translate_y") == 0 && cJSON_IsNumber(prop)) { lv_obj_set_style_translate_y(obj, (lv_coord_t)prop->valuedouble, selector); }


            // Add MANY MANY more style property mappings...
            // line_, arc_, image_, transition_, layout (flex/grid) etc.

            else {
                 ui_builder_report_error("Unsupported style property '%s' for selector %d|%d", prop_name, part, state);
            }
        } // End loop props_json
    } // End loop styles_array
}

static lv_obj_t* build_object_recursive(cJSON *obj_json, lv_obj_t* current_parent) {
    // This function now primarily handles object CREATION and MAP registration.
    // Properties/styles/flags/state application happens within it.
    // Parenting is implicitly handled by passing `current_parent` during creation.
    if (!cJSON_IsObject(obj_json)) { ui_builder_report_error("Invalid object JSON node"); return NULL; }
    cJSON *id_json = cJSON_GetObjectItemCaseSensitive(obj_json, "id");
    cJSON *type_json = cJSON_GetObjectItemCaseSensitive(obj_json, "type");
    if (!cJSON_IsNumber(id_json) || !cJSON_IsString(type_json) || !type_json->valuestring) {
        ui_builder_report_error("Missing id or type in object JSON"); return NULL;
    }

    uint32_t id = (uint32_t)id_json->valuedouble;
    const char *type = type_json->valuestring;
    lv_obj_t *new_obj = NULL;

    // --- Create the LVGL Object ---
    // Map type string to lv_..._create function
    // This list needs to be exhaustive based on lv_def.json 'functions' and 'objects'
    if (strcmp(type, "obj") == 0 || strcmp(type, "screen") == 0) new_obj = lv_obj_create(current_parent);
    else if (strcmp(type, "label") == 0) new_obj = lv_label_create(current_parent);
    else if (strcmp(type, "button") == 0) new_obj = lv_button_create(current_parent);
    else if (strcmp(type, "image") == 0) new_obj = lv_image_create(current_parent);
    else if (strcmp(type, "arc") == 0) new_obj = lv_arc_create(current_parent);
    else if (strcmp(type, "bar") == 0) new_obj = lv_bar_create(current_parent);
    else if (strcmp(type, "checkbox") == 0) new_obj = lv_checkbox_create(current_parent);
    else if (strcmp(type, "dropdown") == 0) new_obj = lv_dropdown_create(current_parent);
    else if (strcmp(type, "slider") == 0) new_obj = lv_slider_create(current_parent);
    else if (strcmp(type, "switch") == 0) new_obj = lv_switch_create(current_parent);
    else if (strcmp(type, "textarea") == 0) new_obj = lv_textarea_create(current_parent);
    else if (strcmp(type, "table") == 0) new_obj = lv_table_create(current_parent);
    else if (strcmp(type, "canvas") == 0) new_obj = lv_canvas_create(current_parent);
    else if (strcmp(type, "chart") == 0) new_obj = lv_chart_create(current_parent);
    else if (strcmp(type, "keyboard") == 0) new_obj = lv_keyboard_create(current_parent);
    else if (strcmp(type, "led") == 0) new_obj = lv_led_create(current_parent);
    else if (strcmp(type, "line") == 0) new_obj = lv_line_create(current_parent);
    else if (strcmp(type, "list") == 0) new_obj = lv_list_create(current_parent);
    else if (strcmp(type, "menu") == 0) new_obj = lv_menu_create(current_parent);
    else if (strcmp(type, "msgbox") == 0) new_obj = lv_msgbox_create(NULL, NULL, NULL, NULL, false); // Msgbox create is different
    else if (strcmp(type, "roller") == 0) new_obj = lv_roller_create(current_parent);
    else if (strcmp(type, "scale") == 0) new_obj = lv_scale_create(current_parent);
    else if (strcmp(type, "spinbox") == 0) new_obj = lv_spinbox_create(current_parent);
    else if (strcmp(type, "spinner") == 0) new_obj = lv_spinner_create(current_parent);
    else if (strcmp(type, "tabview") == 0) new_obj = lv_tabview_create(current_parent, LV_DIR_TOP, LV_DPI_DEF / 3); // Example default args
    else if (strcmp(type, "tileview") == 0) new_obj = lv_tileview_create(current_parent);
    else if (strcmp(type, "win") == 0) new_obj = lv_win_create(current_parent, LV_DPI_DEF / 2); // Example default header height
    // Add other widgets...
    else {
        ui_builder_report_error("Unknown object type '%s', creating base lv_obj.", type);
        new_obj = lv_obj_create(current_parent);
    }

    if (!new_obj) {
        ui_builder_report_error("Failed to create lv_obj for type '%s' with id %u", type, id);
        return NULL;
    }

    // Special handling for msgbox parenting AFTER creation
    if(strcmp(type, "msgbox") == 0 && current_parent != NULL) {
        lv_msgbox_set_parent(new_obj, current_parent);
    }


    // Store mapping from ID to created object *before* applying properties that might need it (e.g., align_to)
    ui_builder_add_obj_to_map(id, new_obj);

    // --- Apply Properties, Flags, States, Styles ---
    cJSON *props = cJSON_GetObjectItemCaseSensitive(obj_json, "properties");
    if (cJSON_IsObject(props)) {
        apply_properties(new_obj, id, props);
    }

    apply_flags_and_states(new_obj, obj_json); // Apply flags/states after props

    cJSON *styles = cJSON_GetObjectItemCaseSensitive(obj_json, "styles");
    if (cJSON_IsArray(styles)) {
        apply_styles(new_obj, styles);
    }

    // Recursion for children is handled by the main loop iterating through the JSON array.
    // This function focuses on creating and configuring *one* object.
    return new_obj;
}


// --- Main Loading Function ---
lv_obj_t* ui_builder_load_json(lv_obj_t* parent_screen_or_obj, const char *json_string) {
    if (!json_string) { ui_builder_report_error("Input JSON string is NULL"); return NULL; }

    // Ensure default screen exists if needed
    if (!parent_screen_or_obj) {
        parent_screen_or_obj = lv_screen_active();
        if (!parent_screen_or_obj) {
            ui_builder_report_error("No active screen and no parent provided.");
            return NULL;
        }
    }

    // Clear the ID map for this specific load, keeps registries intact
    ui_builder_id_map_entry_t *id_current, *id_tmp;
    HASH_ITER(hh, g_builder_state.id_map, id_current, id_tmp) {
        HASH_DEL(g_builder_state.id_map, id_current);
        free(id_current);
    }
    g_builder_state.id_map = NULL; // Reset map


    cJSON *root = cJSON_Parse(json_string);
    if (!root) {
        const char *error_ptr = cJSON_GetErrorPtr();
        ui_builder_report_error("JSON Parse Error near: %s", error_ptr ? error_ptr : "(unknown location)");
        return NULL;
    }

    cJSON *objects_array = cJSON_GetObjectItemCaseSensitive(root, "objects");
    if (!cJSON_IsArray(objects_array)) {
        ui_builder_report_error("Missing 'objects' array in JSON root");
        cJSON_Delete(root);
        return NULL;
    }

    lv_obj_t *first_top_level_obj = NULL; // To return the first object created that has no parent in the JSON

    // --- Create objects (Assumes JSON array allows resolving parents in one pass) ---
    cJSON *obj_json = NULL;
    cJSON_ArrayForEach(obj_json, objects_array) {
        cJSON *parent_id_json = cJSON_GetObjectItemCaseSensitive(obj_json, "parent_id");
        uint32_t parent_id = cJSON_IsNumber(parent_id_json) ? (uint32_t)parent_id_json->valuedouble : 0;

        lv_obj_t *parent_for_creation = NULL;
        if (parent_id == 0) {
             // Top-level object in JSON, attach to the provided parent screen/object
             parent_for_creation = parent_screen_or_obj;
        } else {
            // Find the already created parent object using the ID map
            parent_for_creation = ui_builder_find_obj_by_id(parent_id);
            if (!parent_for_creation) {
                // This implies the JSON wasn't topologically sorted (child before parent)
                // Report error and skip? Or try attaching to default parent?
                // Attaching to default might create wrong hierarchy. Skipping is safer.
                cJSON *id_json = cJSON_GetObjectItemCaseSensitive(obj_json, "id");
                uint32_t current_id = cJSON_IsNumber(id_json) ? (uint32_t)id_json->valuedouble : 0;
                 ui_builder_report_error("Parent object ID %u not found when creating object %u. JSON not topologically sorted?", parent_id, current_id);
                 continue; // Skip creating this object if parent is missing
            }
        }

        // build_object_recursive creates the object, adds to map, applies props/styles/flags/state
        lv_obj_t *created_obj = build_object_recursive(obj_json, parent_for_creation);

        if (!first_top_level_obj && created_obj && parent_id == 0) {
            // Capture the first object created that was explicitly parented to the screen/provided parent
            first_top_level_obj = created_obj;
        }
    }

    // --- Optional Second Pass for Parenting (If topological sort wasn't guaranteed) ---
    // If skipping was done above, this pass wouldn't help.
    // If objects were created attached to a default parent when the real parent wasn't found,
    // this pass could correct it.
    /*
    cJSON_ArrayForEach(obj_json, objects_array) {
         cJSON *id_json = cJSON_GetObjectItemCaseSensitive(obj_json, "id");
         cJSON *parent_id_json = cJSON_GetObjectItemCaseSensitive(obj_json, "parent_id");
         if(!cJSON_IsNumber(id_json) || !cJSON_IsNumber(parent_id_json)) continue;
         uint32_t id = (uint32_t)id_json->valuedouble;
         uint32_t parent_id = (uint32_t)parent_id_json->valuedouble;

         lv_obj_t* obj_to_reparent = ui_builder_find_obj_by_id(id);
         if (!obj_to_reparent) continue; // Object wasn't created?

         lv_obj_t* intended_parent = NULL;
         if (parent_id == 0) {
             intended_parent = parent_screen_or_obj;
         } else {
             intended_parent = ui_builder_find_obj_by_id(parent_id);
             if (!intended_parent) {
                  ui_builder_report_error("Parent ID %u for object %u not found in second pass.", parent_id, id);
                  continue; // Can't find parent
             }
         }

         if (lv_obj_get_parent(obj_to_reparent) != intended_parent) {
              printf("Reparenting obj %u\\n", id); // Debug
              lv_obj_set_parent(obj_to_reparent, intended_parent);
         }
    }
    */

    cJSON_Delete(root);

    // Optionally clear the ID map here if desired after each load.
    // ui_builder_deinit(); // Calling deinit clears registries too, maybe not desired.
    // Manual map clearing:
    // HASH_ITER(hh, g_builder_state.id_map, id_current, id_tmp) { HASH_DEL(g_builder_state.id_map, id_current); free(id_current); }
    // g_builder_state.id_map = NULL;

    return first_top_level_obj; // Return the first top-level object created, or NULL
}
""") # End multi-line string

    return "\n".join(code)


def generate_builder_source(data):
    """Generates the full ui_builder.c source file"""
    string_to_enum_code = generate_builder_enum_from_string_func(data)
    # Pass data and the generated enum function code to the main implementation generator
    full_builder_code = generate_builder_source_impl(data, string_to_enum_code)
    return full_builder_code

# --- Main Execution ---
if __name__ == "__main__":
    if not os.path.exists(INPUT_JSON):
        print(f"Error: Input file '{INPUT_JSON}' not found.")
        exit(1)

    print(f"Loading {INPUT_JSON}...")
    with open(INPUT_JSON, 'r') as f:
        # Load JSON data into the global variable
        lv_data = json.load(f)
    print("JSON loaded.")

    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)

    print(f"Generating {EMU_HEADER}...")
    header_code = generate_emulator_header(lv_data)
    with open(EMU_HEADER, 'w') as f:
        f.write(header_code)

    print(f"Generating {EMU_SOURCE}...")
    source_code = generate_emulator_source(lv_data)
    with open(EMU_SOURCE, 'w') as f:
        f.write(source_code)

    print(f"Generating {BUILDER_HEADER}...")
    #builder_header_code = generate_builder_header(lv_data)
    #with open(BUILDER_HEADER, 'w') as f:
    #    f.write(builder_header_code)

    print(f"Generating {BUILDER_SOURCE}...")
    builder_source_code = generate_builder_source(lv_data)
    with open(BUILDER_SOURCE, 'w') as f:
        f.write(builder_source_code)

    print("-" * 30)
    print("Generation complete.")
    print(f"Output files generated in: '{OUTPUT_DIR}'")
    print(f"\nNOTE: Requires 'cJSON' library (cJSON.c, cJSON.h).")
    print(f"NOTE: Requires 'uthash.h' (header-only library).")
    print(f"NOTE: Review generated code, especially:")
    print(f"      - Enum value assumptions in lv_emu_enum_to_string() (assumes 0, 1, 2...).")
    print(f"      - Correctness of LV_ENUM_MEMBER defines used in ui_builder_enum_from_string().")
    print(f"      - Completeness of widget creation mapping in ui_builder.c.")
    print(f"      - Completeness of property/style handling in apply_properties/apply_styles.")
    print(f"      - Filtering logic in header/source generation (which functions are included/excluded).")
    print("-" * 30)
