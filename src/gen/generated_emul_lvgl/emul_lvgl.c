// Generated by generate_emul_lvgl_wrapper.py. DO NOT EDIT.
#include "emul_lvgl.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <assert.h>

// --- Dependencies ---
#include "cjson/cJSON.h"
#include "uthash.h"

// --- Global State ---
static cJSON *g_root_json_array = NULL;
static uint64_t g_id_counters[100]; // Simple counter array for different opaque types
static const char* g_id_type_names[100];
static int g_id_type_count = 0;
#define MAX_ID_TYPES 100

typedef struct {
    const void *ptr_key; // Key: Original pointer address from user code (use const void* for key safety)
    const char *id;      // Value: Unique string ID (e.g., "label_1") - owned by entry
    cJSON *json_obj;     // Value: Corresponding cJSON object (owned by g_root_json_array or external)
    const char *type_name; // Value: Original LVGL type name (e.g. "lv_obj_t") - owned by entry
    UT_hash_handle hh;   // Makes this structure hashable
} lvgl_registry_entry_t;

static lvgl_registry_entry_t *g_object_registry = NULL; // Hash table head

// Get internal index for managing ID counters per type
static int get_type_index(const char *type_name) {
    // Linear search for existing type
    for (int i = 0; i < g_id_type_count; ++i) {
        if (g_id_type_names[i] != NULL && strcmp(g_id_type_names[i], type_name) == 0) {
            return i;
        }
    }
    // Add new type if space allows
    if (g_id_type_count < MAX_ID_TYPES) {
        // Store a copy of the type name string
        g_id_type_names[g_id_type_count] = strdup(type_name);
        if (!g_id_type_names[g_id_type_count]) {
             perror("Failed to allocate memory for type name");
             assert(false); // Critical error
             return -1;
        }
        g_id_counters[g_id_type_count] = 0; // Initialize counter
        return g_id_type_count++;
    } else {
        // Error handling if too many unique types
        fprintf(stderr, "Error: Exceeded maximum unique opaque types (%d) for ID generation.\n", MAX_ID_TYPES);
        fprintf(stderr, "    Failed type: %s\n", type_name);
        assert(false); // Critical error
        return -1;
    }
}

// Generates a unique ID string (e.g., "lv_obj_t_1") - caller owns returned string
static char* generate_unique_id(const char *base_type_name) {
    int type_index = get_type_index(base_type_name);
    if (type_index < 0) return NULL; // Error handled in get_type_index
    // Increment counter for this type
    uint64_t count = ++g_id_counters[type_index];
    // Calculate required buffer size: type_name + '_' + up to 20 digits (for uint64_t) + null terminator
    size_t buffer_len = strlen(base_type_name) + 1 + 20 + 1;
    char* buffer = (char*)malloc(buffer_len);
    if (!buffer) {
        perror("Failed to allocate buffer for generating ID");
        assert(false); // Critical error
        return NULL;
    }
    // Format the ID string
    // Use PRIu64 for platform-independent uint64_t printing
    snprintf(buffer, buffer_len, "%s_%\" PRIu64 \"", base_type_name, count);
    return buffer; // Ownership transferred to caller
}

// Registers an opaque pointer with its generated ID and cJSON object
static void register_opaque_object(const void *ptr, const char *type_name, char *id, cJSON *json_obj) {
    // Check for NULL pointer - cannot register NULL
    if (ptr == NULL) {
        fprintf(stderr, "Warning: Attempted to register a NULL pointer for type %s with ID %s. Ignoring.\n", type_name, id);
        free(id); // Free the generated ID as it won't be used
        return;
    }
    lvgl_registry_entry_t *entry;
    // Use HASH_FIND_PTR to check if the pointer address is already a key
    HASH_FIND_PTR(g_object_registry, &ptr, entry);
    if (entry == NULL) {
        // Pointer not found, allocate a new registry entry
        entry = (lvgl_registry_entry_t *)malloc(sizeof(lvgl_registry_entry_t));
        if (!entry) {
             perror("Failed to allocate registry entry"); 
             free(id); // Clean up allocated ID
             assert(false); return; // Critical error
        }
        entry->ptr_key = ptr; // Store the const pointer address as key
        entry->id = id; // Store the ID string (entry owns it now)
        entry->json_obj = json_obj; // Store pointer to the cJSON object
        entry->type_name = strdup(type_name); // Store copy of type name (entry owns it)
        if (!entry->type_name) {
             perror("Failed to allocate memory for type name in registry");
             free((void*)entry->id);
             free(entry);
             assert(false); return; // Critical error
        }
        // Add the new entry to the hash table
        HASH_ADD_PTR(g_object_registry, ptr_key, entry);
    } else {
        // Pointer already exists in the registry - this might happen with _init functions
        // fprintf(stderr, "Warning: Pointer %p (type %s) already registered with ID '%s'. Updating with new ID '%s'.\n", ptr, entry->type_name, entry->id, id);
        // Free the old ID and type name associated with the entry
        free((void*)entry->id);
        free((void*)entry->type_name);
        // Update the entry with the new information
        entry->id = id; // Entry takes ownership of the new ID
        entry->json_obj = json_obj; // Update the cJSON object pointer
        entry->type_name = strdup(type_name); // Update the type name (entry owns copy)
        if (!entry->type_name) {
             perror("Failed to allocate memory for updated type name in registry");
             free((void*)entry->id); // Free the new ID as well
             // What to do with the entry? Keep old state? Hard to recover.
             assert(false); return; // Critical error
        }
    }
}

// Finds the cJSON object associated with a given opaque pointer
static cJSON* find_json_object(const void *ptr) {
    if (!ptr) return NULL; // Handle NULL pointers gracefully
    lvgl_registry_entry_t *entry;
    // Search the hash table using the pointer address as the key
    HASH_FIND_PTR(g_object_registry, &ptr, entry);
    if (entry) {
        return entry->json_obj; // Return the associated cJSON object
    } else {
        // Pointer not found in the registry
        // This can happen if an unregistered external pointer (like a font) is used
        // Or if trying to use an object before its constructor/init was called.
        // fprintf(stderr, "Warning: Pointer %p not found in registry during lookup.\n", ptr);
        return NULL; // Indicate not found
    }
}

// Finds the string ID associated with a given opaque pointer
static const char* find_id_by_ptr(const void *ptr) {
    if (!ptr) return NULL;
    lvgl_registry_entry_t *entry;
    HASH_FIND_PTR(g_object_registry, &ptr, entry);
    return entry ? entry->id : NULL; // Return ID string or NULL if not found
}

// --- Marshaling Function Prototypes ---
// Marshals various C types into cJSON values.
static cJSON* marshal_value(const void* value_ptr, const char* c_type_str, const char* base_type_name, bool is_pointer, bool is_enum, bool is_struct, bool is_union, bool is_opaque, const char* arg_name);

// Forward declarations for specific marshalers
static cJSON* marshal_enum_lv_result_t(lv_result_t value);
static cJSON* marshal_enum_lv_rb_color_t(lv_rb_color_t value);
static cJSON* marshal_enum_lv_align_t(lv_align_t value);
static cJSON* marshal_enum_lv_dir_t(lv_dir_t value);
static cJSON* marshal_enum_lv_opa_enum_t(lv_opa_enum_t value);
static cJSON* marshal_enum_lv_color_format_t(lv_color_format_t value);
static cJSON* marshal_enum_lv_palette_t(lv_palette_t value);
static cJSON* marshal_enum_lv_image_compress_t(lv_image_compress_t value);
static cJSON* marshal_enum_lv_font_glyph_format_t(lv_font_glyph_format_t value);
static cJSON* marshal_enum_lv_font_subpx_t(lv_font_subpx_t value);
static cJSON* marshal_enum_lv_font_kerning_t(lv_font_kerning_t value);
static cJSON* marshal_enum_lv_text_flag_t(lv_text_flag_t value);
static cJSON* marshal_enum_lv_text_align_t(lv_text_align_t value);
static cJSON* marshal_enum_lv_text_cmd_state_t(lv_text_cmd_state_t value);
static cJSON* marshal_enum_lv_base_dir_t(lv_base_dir_t value);
static cJSON* marshal_enum_lv_grad_dir_t(lv_grad_dir_t value);
static cJSON* marshal_enum_lv_grad_extend_t(lv_grad_extend_t value);
static cJSON* marshal_enum_lv_layout_t(lv_layout_t value);
static cJSON* marshal_enum_lv_flex_align_t(lv_flex_align_t value);
static cJSON* marshal_enum_lv_flex_flow_t(lv_flex_flow_t value);
static cJSON* marshal_enum_lv_grid_align_t(lv_grid_align_t value);
static cJSON* marshal_enum_lv_blend_mode_t(lv_blend_mode_t value);
static cJSON* marshal_enum_lv_text_decor_t(lv_text_decor_t value);
static cJSON* marshal_enum_lv_border_side_t(lv_border_side_t value);
static cJSON* marshal_enum_lv_style_res_t(lv_style_res_t value);
static cJSON* marshal_enum_lv_event_code_t(lv_event_code_t value);
static cJSON* marshal_enum_lv_display_rotation_t(lv_display_rotation_t value);
static cJSON* marshal_enum_lv_display_render_mode_t(lv_display_render_mode_t value);
static cJSON* marshal_enum_lv_screen_load_anim_t(lv_screen_load_anim_t value);
static cJSON* marshal_enum_lv_obj_tree_walk_res_t(lv_obj_tree_walk_res_t value);
static cJSON* marshal_enum_lv_obj_point_transform_flag_t(lv_obj_point_transform_flag_t value);
static cJSON* marshal_enum_lv_scrollbar_mode_t(lv_scrollbar_mode_t value);
static cJSON* marshal_enum_lv_scroll_snap_t(lv_scroll_snap_t value);
static cJSON* marshal_enum_lv_style_state_cmp_t(lv_style_state_cmp_t value);
static cJSON* marshal_enum_lv_fs_res_t(lv_fs_res_t value);
static cJSON* marshal_enum_lv_fs_mode_t(lv_fs_mode_t value);
static cJSON* marshal_enum_lv_fs_whence_t(lv_fs_whence_t value);
static cJSON* marshal_enum_lv_image_src_t(lv_image_src_t value);
static cJSON* marshal_enum_lv_draw_task_type_t(lv_draw_task_type_t value);
static cJSON* marshal_enum_lv_draw_task_state_t(lv_draw_task_state_t value);
static cJSON* marshal_enum_lv_layer_type_t(lv_layer_type_t value);
static cJSON* marshal_enum_lv_obj_class_editable_t(lv_obj_class_editable_t value);
static cJSON* marshal_enum_lv_obj_class_group_def_t(lv_obj_class_group_def_t value);
static cJSON* marshal_enum_lv_obj_class_theme_inheritable_t(lv_obj_class_theme_inheritable_t value);
static cJSON* marshal_enum_lv_key_t(lv_key_t value);
static cJSON* marshal_enum_lv_group_refocus_policy_t(lv_group_refocus_policy_t value);
static cJSON* marshal_enum_lv_indev_type_t(lv_indev_type_t value);
static cJSON* marshal_enum_lv_indev_state_t(lv_indev_state_t value);
static cJSON* marshal_enum_lv_indev_mode_t(lv_indev_mode_t value);
static cJSON* marshal_enum_lv_indev_gesture_type_t(lv_indev_gesture_type_t value);
static cJSON* marshal_enum_lv_cover_res_t(lv_cover_res_t value);
static cJSON* marshal_enum_lv_state_enum_t(lv_state_enum_t value);
static cJSON* marshal_enum_lv_style_parts_t(lv_style_parts_t value);
static cJSON* marshal_enum_lv_obj_flag_t(lv_obj_flag_t value);
static cJSON* marshal_enum_lv_font_fmt_txt_cmap_type_t(lv_font_fmt_txt_cmap_type_t value);
static cJSON* marshal_enum_lv_font_fmt_txt_bitmap_format_t(lv_font_fmt_txt_bitmap_format_t value);
static cJSON* marshal_enum_lv_image_align_t(lv_image_align_t value);
static cJSON* marshal_enum_lv_animimg_part_t(lv_animimg_part_t value);
static cJSON* marshal_enum_lv_arc_mode_t(lv_arc_mode_t value);
static cJSON* marshal_enum_lv_label_long_mode_t(lv_label_long_mode_t value);
static cJSON* marshal_enum_lv_bar_mode_t(lv_bar_mode_t value);
static cJSON* marshal_enum_lv_bar_orientation_t(lv_bar_orientation_t value);
static cJSON* marshal_enum_lv_buttonmatrix_ctrl_t(lv_buttonmatrix_ctrl_t value);
static cJSON* marshal_enum_lv_chart_type_t(lv_chart_type_t value);
static cJSON* marshal_enum_lv_chart_update_mode_t(lv_chart_update_mode_t value);
static cJSON* marshal_enum_lv_chart_axis_t(lv_chart_axis_t value);
static cJSON* marshal_enum_lv_imagebutton_state_t(lv_imagebutton_state_t value);
static cJSON* marshal_enum_lv_keyboard_mode_t(lv_keyboard_mode_t value);
static cJSON* marshal_enum_lv_menu_mode_header_t(lv_menu_mode_header_t value);
static cJSON* marshal_enum_lv_menu_mode_root_back_button_t(lv_menu_mode_root_back_button_t value);
static cJSON* marshal_enum_lv_roller_mode_t(lv_roller_mode_t value);
static cJSON* marshal_enum_lv_scale_mode_t(lv_scale_mode_t value);
static cJSON* marshal_enum_lv_slider_mode_t(lv_slider_mode_t value);
static cJSON* marshal_enum_lv_slider_orientation_t(lv_slider_orientation_t value);
static cJSON* marshal_enum_lv_span_overflow_t(lv_span_overflow_t value);
static cJSON* marshal_enum_lv_span_mode_t(lv_span_mode_t value);
static cJSON* marshal_enum_lv_switch_orientation_t(lv_switch_orientation_t value);
static cJSON* marshal_enum_lv_table_cell_ctrl_t(lv_table_cell_ctrl_t value);
static cJSON* marshal_enum_lv_subject_type_t(lv_subject_type_t value);
static cJSON* marshal_enum_lv_gridnav_ctrl_t(lv_gridnav_ctrl_t value);
static cJSON* marshal_enum_lv_freetype_font_style_t(lv_freetype_font_style_t value);
static cJSON* marshal_enum_lv_freetype_font_render_mode_t(lv_freetype_font_render_mode_t value);
static cJSON* marshal_enum_lv_freetype_outline_type_t(lv_freetype_outline_type_t value);
static cJSON* marshal_struct_lv_mem_monitor_t(const struct lv_mem_monitor_t* value);
static cJSON* marshal_struct_lv_sqrt_res_t(const struct lv_sqrt_res_t* value);
static cJSON* marshal_struct_lv_anim_bezier3_para_t(const struct lv_anim_bezier3_para_t* value);
static cJSON* marshal_struct_lv_point_t(const struct lv_point_t* value);
static cJSON* marshal_struct_lv_area_t(const struct lv_area_t* value);
static cJSON* marshal_struct_lv_color_t(const struct lv_color_t* value);
static cJSON* marshal_struct_lv_color16_t(const struct lv_color16_t* value);
static cJSON* marshal_struct_lv_color32_t(const struct lv_color32_t* value);
static cJSON* marshal_struct_lv_color_hsv_t(const struct lv_color_hsv_t* value);
static cJSON* marshal_struct_lv_color16a_t(const struct lv_color16a_t* value);
static cJSON* marshal_struct_lv_image_header_t(const struct lv_image_header_t* value);
static cJSON* marshal_struct_lv_img_dsc_t(const struct lv_img_dsc_t* value);
static cJSON* marshal_struct_lv_grad_stop_t(const struct lv_grad_stop_t* value);
static cJSON* marshal_struct_lv_grad_dsc_t(const struct lv_grad_dsc_t* value);
static cJSON* marshal_struct_lv_style_const_prop_t(const struct lv_style_const_prop_t* value);
static cJSON* marshal_struct_lv_event_list_t(const struct lv_event_list_t* value);
static cJSON* marshal_struct_lv_indev_data_t(const struct lv_indev_data_t* value);
static cJSON* marshal_struct_lv_binfont_font_src_t(const struct lv_binfont_font_src_t* value);
static cJSON* marshal_struct_lv_builtin_font_src_t(const struct lv_builtin_font_src_t* value);
static cJSON* marshal_struct_lv_calendar_date_t(const struct lv_calendar_date_t* value);
static cJSON* marshal_struct_lv_span_coords_t(const struct lv_span_coords_t* value);
static cJSON* marshal_struct_lv_tiny_ttf_font_src_t(const struct lv_tiny_ttf_font_src_t* value);
static cJSON* marshal_union_lv_style_value_t(const union lv_style_value_t* value);
static cJSON* marshal_union_lv_subject_value_t(const union lv_subject_value_t* value);

// --- Marshaling Function Implementations ---
// Marshal enum lv_result_t to JSON string
static cJSON* marshal_enum_lv_result_t(lv_result_t value) {
    switch (value) {
        case LV_RESULT_INVALID: return cJSON_CreateString("LV_RESULT_INVALID");
        case LV_RESULT_OK: return cJSON_CreateString("LV_RESULT_OK");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_result_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_rb_color_t to JSON string
static cJSON* marshal_enum_lv_rb_color_t(lv_rb_color_t value) {
    switch (value) {
        case LV_RB_COLOR_RED: return cJSON_CreateString("LV_RB_COLOR_RED");
        case LV_RB_COLOR_BLACK: return cJSON_CreateString("LV_RB_COLOR_BLACK");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_rb_color_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_align_t to JSON string
static cJSON* marshal_enum_lv_align_t(lv_align_t value) {
    switch (value) {
        case LV_ALIGN_DEFAULT: return cJSON_CreateString("LV_ALIGN_DEFAULT");
        case LV_ALIGN_TOP_LEFT: return cJSON_CreateString("LV_ALIGN_TOP_LEFT");
        case LV_ALIGN_TOP_MID: return cJSON_CreateString("LV_ALIGN_TOP_MID");
        case LV_ALIGN_TOP_RIGHT: return cJSON_CreateString("LV_ALIGN_TOP_RIGHT");
        case LV_ALIGN_BOTTOM_LEFT: return cJSON_CreateString("LV_ALIGN_BOTTOM_LEFT");
        case LV_ALIGN_BOTTOM_MID: return cJSON_CreateString("LV_ALIGN_BOTTOM_MID");
        case LV_ALIGN_BOTTOM_RIGHT: return cJSON_CreateString("LV_ALIGN_BOTTOM_RIGHT");
        case LV_ALIGN_LEFT_MID: return cJSON_CreateString("LV_ALIGN_LEFT_MID");
        case LV_ALIGN_RIGHT_MID: return cJSON_CreateString("LV_ALIGN_RIGHT_MID");
        case LV_ALIGN_CENTER: return cJSON_CreateString("LV_ALIGN_CENTER");
        case LV_ALIGN_OUT_TOP_LEFT: return cJSON_CreateString("LV_ALIGN_OUT_TOP_LEFT");
        case LV_ALIGN_OUT_TOP_MID: return cJSON_CreateString("LV_ALIGN_OUT_TOP_MID");
        case LV_ALIGN_OUT_TOP_RIGHT: return cJSON_CreateString("LV_ALIGN_OUT_TOP_RIGHT");
        case LV_ALIGN_OUT_BOTTOM_LEFT: return cJSON_CreateString("LV_ALIGN_OUT_BOTTOM_LEFT");
        case LV_ALIGN_OUT_BOTTOM_MID: return cJSON_CreateString("LV_ALIGN_OUT_BOTTOM_MID");
        case LV_ALIGN_OUT_BOTTOM_RIGHT: return cJSON_CreateString("LV_ALIGN_OUT_BOTTOM_RIGHT");
        case LV_ALIGN_OUT_LEFT_TOP: return cJSON_CreateString("LV_ALIGN_OUT_LEFT_TOP");
        case LV_ALIGN_OUT_LEFT_MID: return cJSON_CreateString("LV_ALIGN_OUT_LEFT_MID");
        case LV_ALIGN_OUT_LEFT_BOTTOM: return cJSON_CreateString("LV_ALIGN_OUT_LEFT_BOTTOM");
        case LV_ALIGN_OUT_RIGHT_TOP: return cJSON_CreateString("LV_ALIGN_OUT_RIGHT_TOP");
        case LV_ALIGN_OUT_RIGHT_MID: return cJSON_CreateString("LV_ALIGN_OUT_RIGHT_MID");
        case LV_ALIGN_OUT_RIGHT_BOTTOM: return cJSON_CreateString("LV_ALIGN_OUT_RIGHT_BOTTOM");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_align_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_dir_t to JSON string
static cJSON* marshal_enum_lv_dir_t(lv_dir_t value) {
    switch (value) {
        case LV_DIR_NONE: return cJSON_CreateString("LV_DIR_NONE");
        case LV_DIR_LEFT: return cJSON_CreateString("LV_DIR_LEFT");
        case LV_DIR_RIGHT: return cJSON_CreateString("LV_DIR_RIGHT");
        case LV_DIR_TOP: return cJSON_CreateString("LV_DIR_TOP");
        case LV_DIR_BOTTOM: return cJSON_CreateString("LV_DIR_BOTTOM");
        case LV_DIR_HOR: return cJSON_CreateString("LV_DIR_HOR");
        case LV_DIR_VER: return cJSON_CreateString("LV_DIR_VER");
        case LV_DIR_ALL: return cJSON_CreateString("LV_DIR_ALL");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_dir_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_opa_enum_t to JSON string
static cJSON* marshal_enum_lv_opa_enum_t(lv_opa_enum_t value) {
    switch (value) {
        case LV_OPA_TRANSP: return cJSON_CreateString("LV_OPA_TRANSP");
        case LV_OPA_0: return cJSON_CreateString("LV_OPA_0");
        case LV_OPA_10: return cJSON_CreateString("LV_OPA_10");
        case LV_OPA_20: return cJSON_CreateString("LV_OPA_20");
        case LV_OPA_30: return cJSON_CreateString("LV_OPA_30");
        case LV_OPA_40: return cJSON_CreateString("LV_OPA_40");
        case LV_OPA_50: return cJSON_CreateString("LV_OPA_50");
        case LV_OPA_60: return cJSON_CreateString("LV_OPA_60");
        case LV_OPA_70: return cJSON_CreateString("LV_OPA_70");
        case LV_OPA_80: return cJSON_CreateString("LV_OPA_80");
        case LV_OPA_90: return cJSON_CreateString("LV_OPA_90");
        case LV_OPA_100: return cJSON_CreateString("LV_OPA_100");
        case LV_OPA_COVER: return cJSON_CreateString("LV_OPA_COVER");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_opa_enum_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_color_format_t to JSON string
static cJSON* marshal_enum_lv_color_format_t(lv_color_format_t value) {
    switch (value) {
        case LV_COLOR_FORMAT_UNKNOWN: return cJSON_CreateString("LV_COLOR_FORMAT_UNKNOWN");
        case LV_COLOR_FORMAT_RAW: return cJSON_CreateString("LV_COLOR_FORMAT_RAW");
        case LV_COLOR_FORMAT_RAW_ALPHA: return cJSON_CreateString("LV_COLOR_FORMAT_RAW_ALPHA");
        case LV_COLOR_FORMAT_L8: return cJSON_CreateString("LV_COLOR_FORMAT_L8");
        case LV_COLOR_FORMAT_I1: return cJSON_CreateString("LV_COLOR_FORMAT_I1");
        case LV_COLOR_FORMAT_I2: return cJSON_CreateString("LV_COLOR_FORMAT_I2");
        case LV_COLOR_FORMAT_I4: return cJSON_CreateString("LV_COLOR_FORMAT_I4");
        case LV_COLOR_FORMAT_I8: return cJSON_CreateString("LV_COLOR_FORMAT_I8");
        case LV_COLOR_FORMAT_A8: return cJSON_CreateString("LV_COLOR_FORMAT_A8");
        case LV_COLOR_FORMAT_RGB565: return cJSON_CreateString("LV_COLOR_FORMAT_RGB565");
        case LV_COLOR_FORMAT_ARGB8565: return cJSON_CreateString("LV_COLOR_FORMAT_ARGB8565");
        case LV_COLOR_FORMAT_RGB565A8: return cJSON_CreateString("LV_COLOR_FORMAT_RGB565A8");
        case LV_COLOR_FORMAT_AL88: return cJSON_CreateString("LV_COLOR_FORMAT_AL88");
        case LV_COLOR_FORMAT_RGB888: return cJSON_CreateString("LV_COLOR_FORMAT_RGB888");
        case LV_COLOR_FORMAT_ARGB8888: return cJSON_CreateString("LV_COLOR_FORMAT_ARGB8888");
        case LV_COLOR_FORMAT_XRGB8888: return cJSON_CreateString("LV_COLOR_FORMAT_XRGB8888");
        case LV_COLOR_FORMAT_ARGB8888_PREMULTIPLIED: return cJSON_CreateString("LV_COLOR_FORMAT_ARGB8888_PREMULTIPLIED");
        case LV_COLOR_FORMAT_A1: return cJSON_CreateString("LV_COLOR_FORMAT_A1");
        case LV_COLOR_FORMAT_A2: return cJSON_CreateString("LV_COLOR_FORMAT_A2");
        case LV_COLOR_FORMAT_A4: return cJSON_CreateString("LV_COLOR_FORMAT_A4");
        case LV_COLOR_FORMAT_ARGB1555: return cJSON_CreateString("LV_COLOR_FORMAT_ARGB1555");
        case LV_COLOR_FORMAT_ARGB4444: return cJSON_CreateString("LV_COLOR_FORMAT_ARGB4444");
        case LV_COLOR_FORMAT_ARGB2222: return cJSON_CreateString("LV_COLOR_FORMAT_ARGB2222");
        case LV_COLOR_FORMAT_YUV_START: return cJSON_CreateString("LV_COLOR_FORMAT_YUV_START");
        case LV_COLOR_FORMAT_I420: return cJSON_CreateString("LV_COLOR_FORMAT_I420");
        case LV_COLOR_FORMAT_I422: return cJSON_CreateString("LV_COLOR_FORMAT_I422");
        case LV_COLOR_FORMAT_I444: return cJSON_CreateString("LV_COLOR_FORMAT_I444");
        case LV_COLOR_FORMAT_I400: return cJSON_CreateString("LV_COLOR_FORMAT_I400");
        case LV_COLOR_FORMAT_NV21: return cJSON_CreateString("LV_COLOR_FORMAT_NV21");
        case LV_COLOR_FORMAT_NV12: return cJSON_CreateString("LV_COLOR_FORMAT_NV12");
        case LV_COLOR_FORMAT_YUY2: return cJSON_CreateString("LV_COLOR_FORMAT_YUY2");
        case LV_COLOR_FORMAT_UYVY: return cJSON_CreateString("LV_COLOR_FORMAT_UYVY");
        case LV_COLOR_FORMAT_YUV_END: return cJSON_CreateString("LV_COLOR_FORMAT_YUV_END");
        case LV_COLOR_FORMAT_PROPRIETARY_START: return cJSON_CreateString("LV_COLOR_FORMAT_PROPRIETARY_START");
        case LV_COLOR_FORMAT_NEMA_TSC_START: return cJSON_CreateString("LV_COLOR_FORMAT_NEMA_TSC_START");
        case LV_COLOR_FORMAT_NEMA_TSC4: return cJSON_CreateString("LV_COLOR_FORMAT_NEMA_TSC4");
        case LV_COLOR_FORMAT_NEMA_TSC6: return cJSON_CreateString("LV_COLOR_FORMAT_NEMA_TSC6");
        case LV_COLOR_FORMAT_NEMA_TSC6A: return cJSON_CreateString("LV_COLOR_FORMAT_NEMA_TSC6A");
        case LV_COLOR_FORMAT_NEMA_TSC6AP: return cJSON_CreateString("LV_COLOR_FORMAT_NEMA_TSC6AP");
        case LV_COLOR_FORMAT_NEMA_TSC12: return cJSON_CreateString("LV_COLOR_FORMAT_NEMA_TSC12");
        case LV_COLOR_FORMAT_NEMA_TSC12A: return cJSON_CreateString("LV_COLOR_FORMAT_NEMA_TSC12A");
        case LV_COLOR_FORMAT_NEMA_TSC_END: return cJSON_CreateString("LV_COLOR_FORMAT_NEMA_TSC_END");
        case LV_COLOR_FORMAT_NATIVE: return cJSON_CreateString("LV_COLOR_FORMAT_NATIVE");
        case LV_COLOR_FORMAT_NATIVE_WITH_ALPHA: return cJSON_CreateString("LV_COLOR_FORMAT_NATIVE_WITH_ALPHA");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_color_format_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_palette_t to JSON string
static cJSON* marshal_enum_lv_palette_t(lv_palette_t value) {
    switch (value) {
        case LV_PALETTE_RED: return cJSON_CreateString("LV_PALETTE_RED");
        case LV_PALETTE_PINK: return cJSON_CreateString("LV_PALETTE_PINK");
        case LV_PALETTE_PURPLE: return cJSON_CreateString("LV_PALETTE_PURPLE");
        case LV_PALETTE_DEEP_PURPLE: return cJSON_CreateString("LV_PALETTE_DEEP_PURPLE");
        case LV_PALETTE_INDIGO: return cJSON_CreateString("LV_PALETTE_INDIGO");
        case LV_PALETTE_BLUE: return cJSON_CreateString("LV_PALETTE_BLUE");
        case LV_PALETTE_LIGHT_BLUE: return cJSON_CreateString("LV_PALETTE_LIGHT_BLUE");
        case LV_PALETTE_CYAN: return cJSON_CreateString("LV_PALETTE_CYAN");
        case LV_PALETTE_TEAL: return cJSON_CreateString("LV_PALETTE_TEAL");
        case LV_PALETTE_GREEN: return cJSON_CreateString("LV_PALETTE_GREEN");
        case LV_PALETTE_LIGHT_GREEN: return cJSON_CreateString("LV_PALETTE_LIGHT_GREEN");
        case LV_PALETTE_LIME: return cJSON_CreateString("LV_PALETTE_LIME");
        case LV_PALETTE_YELLOW: return cJSON_CreateString("LV_PALETTE_YELLOW");
        case LV_PALETTE_AMBER: return cJSON_CreateString("LV_PALETTE_AMBER");
        case LV_PALETTE_ORANGE: return cJSON_CreateString("LV_PALETTE_ORANGE");
        case LV_PALETTE_DEEP_ORANGE: return cJSON_CreateString("LV_PALETTE_DEEP_ORANGE");
        case LV_PALETTE_BROWN: return cJSON_CreateString("LV_PALETTE_BROWN");
        case LV_PALETTE_BLUE_GREY: return cJSON_CreateString("LV_PALETTE_BLUE_GREY");
        case LV_PALETTE_GREY: return cJSON_CreateString("LV_PALETTE_GREY");
        case LV_PALETTE_LAST: return cJSON_CreateString("LV_PALETTE_LAST");
        case LV_PALETTE_NONE: return cJSON_CreateString("LV_PALETTE_NONE");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_palette_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_image_compress_t to JSON string
static cJSON* marshal_enum_lv_image_compress_t(lv_image_compress_t value) {
    switch (value) {
        case LV_IMAGE_COMPRESS_NONE: return cJSON_CreateString("LV_IMAGE_COMPRESS_NONE");
        case LV_IMAGE_COMPRESS_RLE: return cJSON_CreateString("LV_IMAGE_COMPRESS_RLE");
        case LV_IMAGE_COMPRESS_LZ4: return cJSON_CreateString("LV_IMAGE_COMPRESS_LZ4");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_image_compress_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_font_glyph_format_t to JSON string
static cJSON* marshal_enum_lv_font_glyph_format_t(lv_font_glyph_format_t value) {
    switch (value) {
        case LV_FONT_GLYPH_FORMAT_NONE: return cJSON_CreateString("LV_FONT_GLYPH_FORMAT_NONE");
        case LV_FONT_GLYPH_FORMAT_A1: return cJSON_CreateString("LV_FONT_GLYPH_FORMAT_A1");
        case LV_FONT_GLYPH_FORMAT_A2: return cJSON_CreateString("LV_FONT_GLYPH_FORMAT_A2");
        case LV_FONT_GLYPH_FORMAT_A3: return cJSON_CreateString("LV_FONT_GLYPH_FORMAT_A3");
        case LV_FONT_GLYPH_FORMAT_A4: return cJSON_CreateString("LV_FONT_GLYPH_FORMAT_A4");
        case LV_FONT_GLYPH_FORMAT_A8: return cJSON_CreateString("LV_FONT_GLYPH_FORMAT_A8");
        case LV_FONT_GLYPH_FORMAT_A1_ALIGNED: return cJSON_CreateString("LV_FONT_GLYPH_FORMAT_A1_ALIGNED");
        case LV_FONT_GLYPH_FORMAT_A2_ALIGNED: return cJSON_CreateString("LV_FONT_GLYPH_FORMAT_A2_ALIGNED");
        case LV_FONT_GLYPH_FORMAT_A4_ALIGNED: return cJSON_CreateString("LV_FONT_GLYPH_FORMAT_A4_ALIGNED");
        case LV_FONT_GLYPH_FORMAT_A8_ALIGNED: return cJSON_CreateString("LV_FONT_GLYPH_FORMAT_A8_ALIGNED");
        case LV_FONT_GLYPH_FORMAT_IMAGE: return cJSON_CreateString("LV_FONT_GLYPH_FORMAT_IMAGE");
        case LV_FONT_GLYPH_FORMAT_VECTOR: return cJSON_CreateString("LV_FONT_GLYPH_FORMAT_VECTOR");
        case LV_FONT_GLYPH_FORMAT_SVG: return cJSON_CreateString("LV_FONT_GLYPH_FORMAT_SVG");
        case LV_FONT_GLYPH_FORMAT_CUSTOM: return cJSON_CreateString("LV_FONT_GLYPH_FORMAT_CUSTOM");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_font_glyph_format_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_font_subpx_t to JSON string
static cJSON* marshal_enum_lv_font_subpx_t(lv_font_subpx_t value) {
    switch (value) {
        case LV_FONT_SUBPX_NONE: return cJSON_CreateString("LV_FONT_SUBPX_NONE");
        case LV_FONT_SUBPX_HOR: return cJSON_CreateString("LV_FONT_SUBPX_HOR");
        case LV_FONT_SUBPX_VER: return cJSON_CreateString("LV_FONT_SUBPX_VER");
        case LV_FONT_SUBPX_BOTH: return cJSON_CreateString("LV_FONT_SUBPX_BOTH");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_font_subpx_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_font_kerning_t to JSON string
static cJSON* marshal_enum_lv_font_kerning_t(lv_font_kerning_t value) {
    switch (value) {
        case LV_FONT_KERNING_NORMAL: return cJSON_CreateString("LV_FONT_KERNING_NORMAL");
        case LV_FONT_KERNING_NONE: return cJSON_CreateString("LV_FONT_KERNING_NONE");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_font_kerning_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_text_flag_t to JSON string
static cJSON* marshal_enum_lv_text_flag_t(lv_text_flag_t value) {
    switch (value) {
        case LV_TEXT_FLAG_NONE: return cJSON_CreateString("LV_TEXT_FLAG_NONE");
        case LV_TEXT_FLAG_EXPAND: return cJSON_CreateString("LV_TEXT_FLAG_EXPAND");
        case LV_TEXT_FLAG_FIT: return cJSON_CreateString("LV_TEXT_FLAG_FIT");
        case LV_TEXT_FLAG_BREAK_ALL: return cJSON_CreateString("LV_TEXT_FLAG_BREAK_ALL");
        case LV_TEXT_FLAG_RECOLOR: return cJSON_CreateString("LV_TEXT_FLAG_RECOLOR");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_text_flag_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_text_align_t to JSON string
static cJSON* marshal_enum_lv_text_align_t(lv_text_align_t value) {
    switch (value) {
        case LV_TEXT_ALIGN_AUTO: return cJSON_CreateString("LV_TEXT_ALIGN_AUTO");
        case LV_TEXT_ALIGN_LEFT: return cJSON_CreateString("LV_TEXT_ALIGN_LEFT");
        case LV_TEXT_ALIGN_CENTER: return cJSON_CreateString("LV_TEXT_ALIGN_CENTER");
        case LV_TEXT_ALIGN_RIGHT: return cJSON_CreateString("LV_TEXT_ALIGN_RIGHT");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_text_align_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_text_cmd_state_t to JSON string
static cJSON* marshal_enum_lv_text_cmd_state_t(lv_text_cmd_state_t value) {
    switch (value) {
        case LV_TEXT_CMD_STATE_WAIT: return cJSON_CreateString("LV_TEXT_CMD_STATE_WAIT");
        case LV_TEXT_CMD_STATE_PAR: return cJSON_CreateString("LV_TEXT_CMD_STATE_PAR");
        case LV_TEXT_CMD_STATE_IN: return cJSON_CreateString("LV_TEXT_CMD_STATE_IN");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_text_cmd_state_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_base_dir_t to JSON string
static cJSON* marshal_enum_lv_base_dir_t(lv_base_dir_t value) {
    switch (value) {
        case LV_BASE_DIR_LTR: return cJSON_CreateString("LV_BASE_DIR_LTR");
        case LV_BASE_DIR_RTL: return cJSON_CreateString("LV_BASE_DIR_RTL");
        case LV_BASE_DIR_AUTO: return cJSON_CreateString("LV_BASE_DIR_AUTO");
        case LV_BASE_DIR_NEUTRAL: return cJSON_CreateString("LV_BASE_DIR_NEUTRAL");
        case LV_BASE_DIR_WEAK: return cJSON_CreateString("LV_BASE_DIR_WEAK");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_base_dir_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_grad_dir_t to JSON string
static cJSON* marshal_enum_lv_grad_dir_t(lv_grad_dir_t value) {
    switch (value) {
        case LV_GRAD_DIR_NONE: return cJSON_CreateString("LV_GRAD_DIR_NONE");
        case LV_GRAD_DIR_VER: return cJSON_CreateString("LV_GRAD_DIR_VER");
        case LV_GRAD_DIR_HOR: return cJSON_CreateString("LV_GRAD_DIR_HOR");
        case LV_GRAD_DIR_LINEAR: return cJSON_CreateString("LV_GRAD_DIR_LINEAR");
        case LV_GRAD_DIR_RADIAL: return cJSON_CreateString("LV_GRAD_DIR_RADIAL");
        case LV_GRAD_DIR_CONICAL: return cJSON_CreateString("LV_GRAD_DIR_CONICAL");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_grad_dir_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_grad_extend_t to JSON string
static cJSON* marshal_enum_lv_grad_extend_t(lv_grad_extend_t value) {
    switch (value) {
        case LV_GRAD_EXTEND_PAD: return cJSON_CreateString("LV_GRAD_EXTEND_PAD");
        case LV_GRAD_EXTEND_REPEAT: return cJSON_CreateString("LV_GRAD_EXTEND_REPEAT");
        case LV_GRAD_EXTEND_REFLECT: return cJSON_CreateString("LV_GRAD_EXTEND_REFLECT");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_grad_extend_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_layout_t to JSON string
static cJSON* marshal_enum_lv_layout_t(lv_layout_t value) {
    switch (value) {
        case LV_LAYOUT_NONE: return cJSON_CreateString("LV_LAYOUT_NONE");
        case LV_LAYOUT_FLEX: return cJSON_CreateString("LV_LAYOUT_FLEX");
        case LV_LAYOUT_GRID: return cJSON_CreateString("LV_LAYOUT_GRID");
        case LV_LAYOUT_LAST: return cJSON_CreateString("LV_LAYOUT_LAST");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_layout_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_flex_align_t to JSON string
static cJSON* marshal_enum_lv_flex_align_t(lv_flex_align_t value) {
    switch (value) {
        case LV_FLEX_ALIGN_START: return cJSON_CreateString("LV_FLEX_ALIGN_START");
        case LV_FLEX_ALIGN_END: return cJSON_CreateString("LV_FLEX_ALIGN_END");
        case LV_FLEX_ALIGN_CENTER: return cJSON_CreateString("LV_FLEX_ALIGN_CENTER");
        case LV_FLEX_ALIGN_SPACE_EVENLY: return cJSON_CreateString("LV_FLEX_ALIGN_SPACE_EVENLY");
        case LV_FLEX_ALIGN_SPACE_AROUND: return cJSON_CreateString("LV_FLEX_ALIGN_SPACE_AROUND");
        case LV_FLEX_ALIGN_SPACE_BETWEEN: return cJSON_CreateString("LV_FLEX_ALIGN_SPACE_BETWEEN");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_flex_align_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_flex_flow_t to JSON string
static cJSON* marshal_enum_lv_flex_flow_t(lv_flex_flow_t value) {
    switch (value) {
        case LV_FLEX_FLOW_ROW: return cJSON_CreateString("LV_FLEX_FLOW_ROW");
        case LV_FLEX_FLOW_COLUMN: return cJSON_CreateString("LV_FLEX_FLOW_COLUMN");
        case LV_FLEX_FLOW_ROW_WRAP: return cJSON_CreateString("LV_FLEX_FLOW_ROW_WRAP");
        case LV_FLEX_FLOW_ROW_REVERSE: return cJSON_CreateString("LV_FLEX_FLOW_ROW_REVERSE");
        case LV_FLEX_FLOW_ROW_WRAP_REVERSE: return cJSON_CreateString("LV_FLEX_FLOW_ROW_WRAP_REVERSE");
        case LV_FLEX_FLOW_COLUMN_WRAP: return cJSON_CreateString("LV_FLEX_FLOW_COLUMN_WRAP");
        case LV_FLEX_FLOW_COLUMN_REVERSE: return cJSON_CreateString("LV_FLEX_FLOW_COLUMN_REVERSE");
        case LV_FLEX_FLOW_COLUMN_WRAP_REVERSE: return cJSON_CreateString("LV_FLEX_FLOW_COLUMN_WRAP_REVERSE");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_flex_flow_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_grid_align_t to JSON string
static cJSON* marshal_enum_lv_grid_align_t(lv_grid_align_t value) {
    switch (value) {
        case LV_GRID_ALIGN_START: return cJSON_CreateString("LV_GRID_ALIGN_START");
        case LV_GRID_ALIGN_CENTER: return cJSON_CreateString("LV_GRID_ALIGN_CENTER");
        case LV_GRID_ALIGN_END: return cJSON_CreateString("LV_GRID_ALIGN_END");
        case LV_GRID_ALIGN_STRETCH: return cJSON_CreateString("LV_GRID_ALIGN_STRETCH");
        case LV_GRID_ALIGN_SPACE_EVENLY: return cJSON_CreateString("LV_GRID_ALIGN_SPACE_EVENLY");
        case LV_GRID_ALIGN_SPACE_AROUND: return cJSON_CreateString("LV_GRID_ALIGN_SPACE_AROUND");
        case LV_GRID_ALIGN_SPACE_BETWEEN: return cJSON_CreateString("LV_GRID_ALIGN_SPACE_BETWEEN");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_grid_align_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_blend_mode_t to JSON string
static cJSON* marshal_enum_lv_blend_mode_t(lv_blend_mode_t value) {
    switch (value) {
        case LV_BLEND_MODE_NORMAL: return cJSON_CreateString("LV_BLEND_MODE_NORMAL");
        case LV_BLEND_MODE_ADDITIVE: return cJSON_CreateString("LV_BLEND_MODE_ADDITIVE");
        case LV_BLEND_MODE_SUBTRACTIVE: return cJSON_CreateString("LV_BLEND_MODE_SUBTRACTIVE");
        case LV_BLEND_MODE_MULTIPLY: return cJSON_CreateString("LV_BLEND_MODE_MULTIPLY");
        case LV_BLEND_MODE_DIFFERENCE: return cJSON_CreateString("LV_BLEND_MODE_DIFFERENCE");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_blend_mode_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_text_decor_t to JSON string
static cJSON* marshal_enum_lv_text_decor_t(lv_text_decor_t value) {
    switch (value) {
        case LV_TEXT_DECOR_NONE: return cJSON_CreateString("LV_TEXT_DECOR_NONE");
        case LV_TEXT_DECOR_UNDERLINE: return cJSON_CreateString("LV_TEXT_DECOR_UNDERLINE");
        case LV_TEXT_DECOR_STRIKETHROUGH: return cJSON_CreateString("LV_TEXT_DECOR_STRIKETHROUGH");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_text_decor_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_border_side_t to JSON string
static cJSON* marshal_enum_lv_border_side_t(lv_border_side_t value) {
    switch (value) {
        case LV_BORDER_SIDE_NONE: return cJSON_CreateString("LV_BORDER_SIDE_NONE");
        case LV_BORDER_SIDE_BOTTOM: return cJSON_CreateString("LV_BORDER_SIDE_BOTTOM");
        case LV_BORDER_SIDE_TOP: return cJSON_CreateString("LV_BORDER_SIDE_TOP");
        case LV_BORDER_SIDE_LEFT: return cJSON_CreateString("LV_BORDER_SIDE_LEFT");
        case LV_BORDER_SIDE_RIGHT: return cJSON_CreateString("LV_BORDER_SIDE_RIGHT");
        case LV_BORDER_SIDE_FULL: return cJSON_CreateString("LV_BORDER_SIDE_FULL");
        case LV_BORDER_SIDE_INTERNAL: return cJSON_CreateString("LV_BORDER_SIDE_INTERNAL");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_border_side_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_style_res_t to JSON string
static cJSON* marshal_enum_lv_style_res_t(lv_style_res_t value) {
    switch (value) {
        case LV_STYLE_RES_NOT_FOUND: return cJSON_CreateString("LV_STYLE_RES_NOT_FOUND");
        case LV_STYLE_RES_FOUND: return cJSON_CreateString("LV_STYLE_RES_FOUND");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_style_res_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_event_code_t to JSON string
static cJSON* marshal_enum_lv_event_code_t(lv_event_code_t value) {
    switch (value) {
        case LV_EVENT_ALL: return cJSON_CreateString("LV_EVENT_ALL");
        case LV_EVENT_PRESSED: return cJSON_CreateString("LV_EVENT_PRESSED");
        case LV_EVENT_PRESSING: return cJSON_CreateString("LV_EVENT_PRESSING");
        case LV_EVENT_PRESS_LOST: return cJSON_CreateString("LV_EVENT_PRESS_LOST");
        case LV_EVENT_SHORT_CLICKED: return cJSON_CreateString("LV_EVENT_SHORT_CLICKED");
        case LV_EVENT_SINGLE_CLICKED: return cJSON_CreateString("LV_EVENT_SINGLE_CLICKED");
        case LV_EVENT_DOUBLE_CLICKED: return cJSON_CreateString("LV_EVENT_DOUBLE_CLICKED");
        case LV_EVENT_TRIPLE_CLICKED: return cJSON_CreateString("LV_EVENT_TRIPLE_CLICKED");
        case LV_EVENT_LONG_PRESSED: return cJSON_CreateString("LV_EVENT_LONG_PRESSED");
        case LV_EVENT_LONG_PRESSED_REPEAT: return cJSON_CreateString("LV_EVENT_LONG_PRESSED_REPEAT");
        case LV_EVENT_CLICKED: return cJSON_CreateString("LV_EVENT_CLICKED");
        case LV_EVENT_RELEASED: return cJSON_CreateString("LV_EVENT_RELEASED");
        case LV_EVENT_SCROLL_BEGIN: return cJSON_CreateString("LV_EVENT_SCROLL_BEGIN");
        case LV_EVENT_SCROLL_THROW_BEGIN: return cJSON_CreateString("LV_EVENT_SCROLL_THROW_BEGIN");
        case LV_EVENT_SCROLL_END: return cJSON_CreateString("LV_EVENT_SCROLL_END");
        case LV_EVENT_SCROLL: return cJSON_CreateString("LV_EVENT_SCROLL");
        case LV_EVENT_GESTURE: return cJSON_CreateString("LV_EVENT_GESTURE");
        case LV_EVENT_KEY: return cJSON_CreateString("LV_EVENT_KEY");
        case LV_EVENT_ROTARY: return cJSON_CreateString("LV_EVENT_ROTARY");
        case LV_EVENT_FOCUSED: return cJSON_CreateString("LV_EVENT_FOCUSED");
        case LV_EVENT_DEFOCUSED: return cJSON_CreateString("LV_EVENT_DEFOCUSED");
        case LV_EVENT_LEAVE: return cJSON_CreateString("LV_EVENT_LEAVE");
        case LV_EVENT_HIT_TEST: return cJSON_CreateString("LV_EVENT_HIT_TEST");
        case LV_EVENT_INDEV_RESET: return cJSON_CreateString("LV_EVENT_INDEV_RESET");
        case LV_EVENT_HOVER_OVER: return cJSON_CreateString("LV_EVENT_HOVER_OVER");
        case LV_EVENT_HOVER_LEAVE: return cJSON_CreateString("LV_EVENT_HOVER_LEAVE");
        case LV_EVENT_COVER_CHECK: return cJSON_CreateString("LV_EVENT_COVER_CHECK");
        case LV_EVENT_REFR_EXT_DRAW_SIZE: return cJSON_CreateString("LV_EVENT_REFR_EXT_DRAW_SIZE");
        case LV_EVENT_DRAW_MAIN_BEGIN: return cJSON_CreateString("LV_EVENT_DRAW_MAIN_BEGIN");
        case LV_EVENT_DRAW_MAIN: return cJSON_CreateString("LV_EVENT_DRAW_MAIN");
        case LV_EVENT_DRAW_MAIN_END: return cJSON_CreateString("LV_EVENT_DRAW_MAIN_END");
        case LV_EVENT_DRAW_POST_BEGIN: return cJSON_CreateString("LV_EVENT_DRAW_POST_BEGIN");
        case LV_EVENT_DRAW_POST: return cJSON_CreateString("LV_EVENT_DRAW_POST");
        case LV_EVENT_DRAW_POST_END: return cJSON_CreateString("LV_EVENT_DRAW_POST_END");
        case LV_EVENT_DRAW_TASK_ADDED: return cJSON_CreateString("LV_EVENT_DRAW_TASK_ADDED");
        case LV_EVENT_VALUE_CHANGED: return cJSON_CreateString("LV_EVENT_VALUE_CHANGED");
        case LV_EVENT_INSERT: return cJSON_CreateString("LV_EVENT_INSERT");
        case LV_EVENT_REFRESH: return cJSON_CreateString("LV_EVENT_REFRESH");
        case LV_EVENT_READY: return cJSON_CreateString("LV_EVENT_READY");
        case LV_EVENT_CANCEL: return cJSON_CreateString("LV_EVENT_CANCEL");
        case LV_EVENT_CREATE: return cJSON_CreateString("LV_EVENT_CREATE");
        case LV_EVENT_DELETE: return cJSON_CreateString("LV_EVENT_DELETE");
        case LV_EVENT_CHILD_CHANGED: return cJSON_CreateString("LV_EVENT_CHILD_CHANGED");
        case LV_EVENT_CHILD_CREATED: return cJSON_CreateString("LV_EVENT_CHILD_CREATED");
        case LV_EVENT_CHILD_DELETED: return cJSON_CreateString("LV_EVENT_CHILD_DELETED");
        case LV_EVENT_SCREEN_UNLOAD_START: return cJSON_CreateString("LV_EVENT_SCREEN_UNLOAD_START");
        case LV_EVENT_SCREEN_LOAD_START: return cJSON_CreateString("LV_EVENT_SCREEN_LOAD_START");
        case LV_EVENT_SCREEN_LOADED: return cJSON_CreateString("LV_EVENT_SCREEN_LOADED");
        case LV_EVENT_SCREEN_UNLOADED: return cJSON_CreateString("LV_EVENT_SCREEN_UNLOADED");
        case LV_EVENT_SIZE_CHANGED: return cJSON_CreateString("LV_EVENT_SIZE_CHANGED");
        case LV_EVENT_STYLE_CHANGED: return cJSON_CreateString("LV_EVENT_STYLE_CHANGED");
        case LV_EVENT_LAYOUT_CHANGED: return cJSON_CreateString("LV_EVENT_LAYOUT_CHANGED");
        case LV_EVENT_GET_SELF_SIZE: return cJSON_CreateString("LV_EVENT_GET_SELF_SIZE");
        case LV_EVENT_INVALIDATE_AREA: return cJSON_CreateString("LV_EVENT_INVALIDATE_AREA");
        case LV_EVENT_RESOLUTION_CHANGED: return cJSON_CreateString("LV_EVENT_RESOLUTION_CHANGED");
        case LV_EVENT_COLOR_FORMAT_CHANGED: return cJSON_CreateString("LV_EVENT_COLOR_FORMAT_CHANGED");
        case LV_EVENT_REFR_REQUEST: return cJSON_CreateString("LV_EVENT_REFR_REQUEST");
        case LV_EVENT_REFR_START: return cJSON_CreateString("LV_EVENT_REFR_START");
        case LV_EVENT_REFR_READY: return cJSON_CreateString("LV_EVENT_REFR_READY");
        case LV_EVENT_RENDER_START: return cJSON_CreateString("LV_EVENT_RENDER_START");
        case LV_EVENT_RENDER_READY: return cJSON_CreateString("LV_EVENT_RENDER_READY");
        case LV_EVENT_FLUSH_START: return cJSON_CreateString("LV_EVENT_FLUSH_START");
        case LV_EVENT_FLUSH_FINISH: return cJSON_CreateString("LV_EVENT_FLUSH_FINISH");
        case LV_EVENT_FLUSH_WAIT_START: return cJSON_CreateString("LV_EVENT_FLUSH_WAIT_START");
        case LV_EVENT_FLUSH_WAIT_FINISH: return cJSON_CreateString("LV_EVENT_FLUSH_WAIT_FINISH");
        case LV_EVENT_VSYNC: return cJSON_CreateString("LV_EVENT_VSYNC");
        case LV_EVENT_VSYNC_REQUEST: return cJSON_CreateString("LV_EVENT_VSYNC_REQUEST");
        case LV_EVENT_LAST: return cJSON_CreateString("LV_EVENT_LAST");
        case LV_EVENT_PREPROCESS: return cJSON_CreateString("LV_EVENT_PREPROCESS");
        case LV_EVENT_MARKED_DELETING: return cJSON_CreateString("LV_EVENT_MARKED_DELETING");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_event_code_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_display_rotation_t to JSON string
static cJSON* marshal_enum_lv_display_rotation_t(lv_display_rotation_t value) {
    switch (value) {
        case LV_DISPLAY_ROTATION_0: return cJSON_CreateString("LV_DISPLAY_ROTATION_0");
        case LV_DISPLAY_ROTATION_90: return cJSON_CreateString("LV_DISPLAY_ROTATION_90");
        case LV_DISPLAY_ROTATION_180: return cJSON_CreateString("LV_DISPLAY_ROTATION_180");
        case LV_DISPLAY_ROTATION_270: return cJSON_CreateString("LV_DISPLAY_ROTATION_270");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_display_rotation_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_display_render_mode_t to JSON string
static cJSON* marshal_enum_lv_display_render_mode_t(lv_display_render_mode_t value) {
    switch (value) {
        case LV_DISPLAY_RENDER_MODE_PARTIAL: return cJSON_CreateString("LV_DISPLAY_RENDER_MODE_PARTIAL");
        case LV_DISPLAY_RENDER_MODE_DIRECT: return cJSON_CreateString("LV_DISPLAY_RENDER_MODE_DIRECT");
        case LV_DISPLAY_RENDER_MODE_FULL: return cJSON_CreateString("LV_DISPLAY_RENDER_MODE_FULL");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_display_render_mode_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_screen_load_anim_t to JSON string
static cJSON* marshal_enum_lv_screen_load_anim_t(lv_screen_load_anim_t value) {
    switch (value) {
        case LV_SCR_LOAD_ANIM_NONE: return cJSON_CreateString("LV_SCR_LOAD_ANIM_NONE");
        case LV_SCR_LOAD_ANIM_OVER_LEFT: return cJSON_CreateString("LV_SCR_LOAD_ANIM_OVER_LEFT");
        case LV_SCR_LOAD_ANIM_OVER_RIGHT: return cJSON_CreateString("LV_SCR_LOAD_ANIM_OVER_RIGHT");
        case LV_SCR_LOAD_ANIM_OVER_TOP: return cJSON_CreateString("LV_SCR_LOAD_ANIM_OVER_TOP");
        case LV_SCR_LOAD_ANIM_OVER_BOTTOM: return cJSON_CreateString("LV_SCR_LOAD_ANIM_OVER_BOTTOM");
        case LV_SCR_LOAD_ANIM_MOVE_LEFT: return cJSON_CreateString("LV_SCR_LOAD_ANIM_MOVE_LEFT");
        case LV_SCR_LOAD_ANIM_MOVE_RIGHT: return cJSON_CreateString("LV_SCR_LOAD_ANIM_MOVE_RIGHT");
        case LV_SCR_LOAD_ANIM_MOVE_TOP: return cJSON_CreateString("LV_SCR_LOAD_ANIM_MOVE_TOP");
        case LV_SCR_LOAD_ANIM_MOVE_BOTTOM: return cJSON_CreateString("LV_SCR_LOAD_ANIM_MOVE_BOTTOM");
        case LV_SCR_LOAD_ANIM_FADE_IN: return cJSON_CreateString("LV_SCR_LOAD_ANIM_FADE_IN");
        case LV_SCR_LOAD_ANIM_FADE_ON: return cJSON_CreateString("LV_SCR_LOAD_ANIM_FADE_ON");
        case LV_SCR_LOAD_ANIM_FADE_OUT: return cJSON_CreateString("LV_SCR_LOAD_ANIM_FADE_OUT");
        case LV_SCR_LOAD_ANIM_OUT_LEFT: return cJSON_CreateString("LV_SCR_LOAD_ANIM_OUT_LEFT");
        case LV_SCR_LOAD_ANIM_OUT_RIGHT: return cJSON_CreateString("LV_SCR_LOAD_ANIM_OUT_RIGHT");
        case LV_SCR_LOAD_ANIM_OUT_TOP: return cJSON_CreateString("LV_SCR_LOAD_ANIM_OUT_TOP");
        case LV_SCR_LOAD_ANIM_OUT_BOTTOM: return cJSON_CreateString("LV_SCR_LOAD_ANIM_OUT_BOTTOM");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_screen_load_anim_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_obj_tree_walk_res_t to JSON string
static cJSON* marshal_enum_lv_obj_tree_walk_res_t(lv_obj_tree_walk_res_t value) {
    switch (value) {
        case LV_OBJ_TREE_WALK_NEXT: return cJSON_CreateString("LV_OBJ_TREE_WALK_NEXT");
        case LV_OBJ_TREE_WALK_SKIP_CHILDREN: return cJSON_CreateString("LV_OBJ_TREE_WALK_SKIP_CHILDREN");
        case LV_OBJ_TREE_WALK_END: return cJSON_CreateString("LV_OBJ_TREE_WALK_END");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_obj_tree_walk_res_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_obj_point_transform_flag_t to JSON string
static cJSON* marshal_enum_lv_obj_point_transform_flag_t(lv_obj_point_transform_flag_t value) {
    switch (value) {
        case LV_OBJ_POINT_TRANSFORM_FLAG_NONE: return cJSON_CreateString("LV_OBJ_POINT_TRANSFORM_FLAG_NONE");
        case LV_OBJ_POINT_TRANSFORM_FLAG_RECURSIVE: return cJSON_CreateString("LV_OBJ_POINT_TRANSFORM_FLAG_RECURSIVE");
        case LV_OBJ_POINT_TRANSFORM_FLAG_INVERSE: return cJSON_CreateString("LV_OBJ_POINT_TRANSFORM_FLAG_INVERSE");
        case LV_OBJ_POINT_TRANSFORM_FLAG_INVERSE_RECURSIVE: return cJSON_CreateString("LV_OBJ_POINT_TRANSFORM_FLAG_INVERSE_RECURSIVE");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_obj_point_transform_flag_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_scrollbar_mode_t to JSON string
static cJSON* marshal_enum_lv_scrollbar_mode_t(lv_scrollbar_mode_t value) {
    switch (value) {
        case LV_SCROLLBAR_MODE_OFF: return cJSON_CreateString("LV_SCROLLBAR_MODE_OFF");
        case LV_SCROLLBAR_MODE_ON: return cJSON_CreateString("LV_SCROLLBAR_MODE_ON");
        case LV_SCROLLBAR_MODE_ACTIVE: return cJSON_CreateString("LV_SCROLLBAR_MODE_ACTIVE");
        case LV_SCROLLBAR_MODE_AUTO: return cJSON_CreateString("LV_SCROLLBAR_MODE_AUTO");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_scrollbar_mode_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_scroll_snap_t to JSON string
static cJSON* marshal_enum_lv_scroll_snap_t(lv_scroll_snap_t value) {
    switch (value) {
        case LV_SCROLL_SNAP_NONE: return cJSON_CreateString("LV_SCROLL_SNAP_NONE");
        case LV_SCROLL_SNAP_START: return cJSON_CreateString("LV_SCROLL_SNAP_START");
        case LV_SCROLL_SNAP_END: return cJSON_CreateString("LV_SCROLL_SNAP_END");
        case LV_SCROLL_SNAP_CENTER: return cJSON_CreateString("LV_SCROLL_SNAP_CENTER");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_scroll_snap_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_style_state_cmp_t to JSON string
static cJSON* marshal_enum_lv_style_state_cmp_t(lv_style_state_cmp_t value) {
    switch (value) {
        case LV_STYLE_STATE_CMP_SAME: return cJSON_CreateString("LV_STYLE_STATE_CMP_SAME");
        case LV_STYLE_STATE_CMP_DIFF_REDRAW: return cJSON_CreateString("LV_STYLE_STATE_CMP_DIFF_REDRAW");
        case LV_STYLE_STATE_CMP_DIFF_DRAW_PAD: return cJSON_CreateString("LV_STYLE_STATE_CMP_DIFF_DRAW_PAD");
        case LV_STYLE_STATE_CMP_DIFF_LAYOUT: return cJSON_CreateString("LV_STYLE_STATE_CMP_DIFF_LAYOUT");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_style_state_cmp_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_fs_res_t to JSON string
static cJSON* marshal_enum_lv_fs_res_t(lv_fs_res_t value) {
    switch (value) {
        case LV_FS_RES_OK: return cJSON_CreateString("LV_FS_RES_OK");
        case LV_FS_RES_HW_ERR: return cJSON_CreateString("LV_FS_RES_HW_ERR");
        case LV_FS_RES_FS_ERR: return cJSON_CreateString("LV_FS_RES_FS_ERR");
        case LV_FS_RES_NOT_EX: return cJSON_CreateString("LV_FS_RES_NOT_EX");
        case LV_FS_RES_FULL: return cJSON_CreateString("LV_FS_RES_FULL");
        case LV_FS_RES_LOCKED: return cJSON_CreateString("LV_FS_RES_LOCKED");
        case LV_FS_RES_DENIED: return cJSON_CreateString("LV_FS_RES_DENIED");
        case LV_FS_RES_BUSY: return cJSON_CreateString("LV_FS_RES_BUSY");
        case LV_FS_RES_TOUT: return cJSON_CreateString("LV_FS_RES_TOUT");
        case LV_FS_RES_NOT_IMP: return cJSON_CreateString("LV_FS_RES_NOT_IMP");
        case LV_FS_RES_OUT_OF_MEM: return cJSON_CreateString("LV_FS_RES_OUT_OF_MEM");
        case LV_FS_RES_INV_PARAM: return cJSON_CreateString("LV_FS_RES_INV_PARAM");
        case LV_FS_RES_UNKNOWN: return cJSON_CreateString("LV_FS_RES_UNKNOWN");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_fs_res_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_fs_mode_t to JSON string
static cJSON* marshal_enum_lv_fs_mode_t(lv_fs_mode_t value) {
    switch (value) {
        case LV_FS_MODE_WR: return cJSON_CreateString("LV_FS_MODE_WR");
        case LV_FS_MODE_RD: return cJSON_CreateString("LV_FS_MODE_RD");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_fs_mode_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_fs_whence_t to JSON string
static cJSON* marshal_enum_lv_fs_whence_t(lv_fs_whence_t value) {
    switch (value) {
        case LV_FS_SEEK_SET: return cJSON_CreateString("LV_FS_SEEK_SET");
        case LV_FS_SEEK_CUR: return cJSON_CreateString("LV_FS_SEEK_CUR");
        case LV_FS_SEEK_END: return cJSON_CreateString("LV_FS_SEEK_END");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_fs_whence_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_image_src_t to JSON string
static cJSON* marshal_enum_lv_image_src_t(lv_image_src_t value) {
    switch (value) {
        case LV_IMAGE_SRC_VARIABLE: return cJSON_CreateString("LV_IMAGE_SRC_VARIABLE");
        case LV_IMAGE_SRC_FILE: return cJSON_CreateString("LV_IMAGE_SRC_FILE");
        case LV_IMAGE_SRC_SYMBOL: return cJSON_CreateString("LV_IMAGE_SRC_SYMBOL");
        case LV_IMAGE_SRC_UNKNOWN: return cJSON_CreateString("LV_IMAGE_SRC_UNKNOWN");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_image_src_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_draw_task_type_t to JSON string
static cJSON* marshal_enum_lv_draw_task_type_t(lv_draw_task_type_t value) {
    switch (value) {
        case LV_DRAW_TASK_TYPE_NONE: return cJSON_CreateString("LV_DRAW_TASK_TYPE_NONE");
        case LV_DRAW_TASK_TYPE_FILL: return cJSON_CreateString("LV_DRAW_TASK_TYPE_FILL");
        case LV_DRAW_TASK_TYPE_BORDER: return cJSON_CreateString("LV_DRAW_TASK_TYPE_BORDER");
        case LV_DRAW_TASK_TYPE_BOX_SHADOW: return cJSON_CreateString("LV_DRAW_TASK_TYPE_BOX_SHADOW");
        case LV_DRAW_TASK_TYPE_LETTER: return cJSON_CreateString("LV_DRAW_TASK_TYPE_LETTER");
        case LV_DRAW_TASK_TYPE_LABEL: return cJSON_CreateString("LV_DRAW_TASK_TYPE_LABEL");
        case LV_DRAW_TASK_TYPE_IMAGE: return cJSON_CreateString("LV_DRAW_TASK_TYPE_IMAGE");
        case LV_DRAW_TASK_TYPE_LAYER: return cJSON_CreateString("LV_DRAW_TASK_TYPE_LAYER");
        case LV_DRAW_TASK_TYPE_LINE: return cJSON_CreateString("LV_DRAW_TASK_TYPE_LINE");
        case LV_DRAW_TASK_TYPE_ARC: return cJSON_CreateString("LV_DRAW_TASK_TYPE_ARC");
        case LV_DRAW_TASK_TYPE_TRIANGLE: return cJSON_CreateString("LV_DRAW_TASK_TYPE_TRIANGLE");
        case LV_DRAW_TASK_TYPE_MASK_RECTANGLE: return cJSON_CreateString("LV_DRAW_TASK_TYPE_MASK_RECTANGLE");
        case LV_DRAW_TASK_TYPE_MASK_BITMAP: return cJSON_CreateString("LV_DRAW_TASK_TYPE_MASK_BITMAP");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_draw_task_type_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_draw_task_state_t to JSON string
static cJSON* marshal_enum_lv_draw_task_state_t(lv_draw_task_state_t value) {
    switch (value) {
        case LV_DRAW_TASK_STATE_WAITING: return cJSON_CreateString("LV_DRAW_TASK_STATE_WAITING");
        case LV_DRAW_TASK_STATE_QUEUED: return cJSON_CreateString("LV_DRAW_TASK_STATE_QUEUED");
        case LV_DRAW_TASK_STATE_IN_PROGRESS: return cJSON_CreateString("LV_DRAW_TASK_STATE_IN_PROGRESS");
        case LV_DRAW_TASK_STATE_READY: return cJSON_CreateString("LV_DRAW_TASK_STATE_READY");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_draw_task_state_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_layer_type_t to JSON string
static cJSON* marshal_enum_lv_layer_type_t(lv_layer_type_t value) {
    switch (value) {
        case LV_LAYER_TYPE_NONE: return cJSON_CreateString("LV_LAYER_TYPE_NONE");
        case LV_LAYER_TYPE_SIMPLE: return cJSON_CreateString("LV_LAYER_TYPE_SIMPLE");
        case LV_LAYER_TYPE_TRANSFORM: return cJSON_CreateString("LV_LAYER_TYPE_TRANSFORM");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_layer_type_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_obj_class_editable_t to JSON string
static cJSON* marshal_enum_lv_obj_class_editable_t(lv_obj_class_editable_t value) {
    switch (value) {
        case LV_OBJ_CLASS_EDITABLE_INHERIT: return cJSON_CreateString("LV_OBJ_CLASS_EDITABLE_INHERIT");
        case LV_OBJ_CLASS_EDITABLE_TRUE: return cJSON_CreateString("LV_OBJ_CLASS_EDITABLE_TRUE");
        case LV_OBJ_CLASS_EDITABLE_FALSE: return cJSON_CreateString("LV_OBJ_CLASS_EDITABLE_FALSE");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_obj_class_editable_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_obj_class_group_def_t to JSON string
static cJSON* marshal_enum_lv_obj_class_group_def_t(lv_obj_class_group_def_t value) {
    switch (value) {
        case LV_OBJ_CLASS_GROUP_DEF_INHERIT: return cJSON_CreateString("LV_OBJ_CLASS_GROUP_DEF_INHERIT");
        case LV_OBJ_CLASS_GROUP_DEF_TRUE: return cJSON_CreateString("LV_OBJ_CLASS_GROUP_DEF_TRUE");
        case LV_OBJ_CLASS_GROUP_DEF_FALSE: return cJSON_CreateString("LV_OBJ_CLASS_GROUP_DEF_FALSE");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_obj_class_group_def_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_obj_class_theme_inheritable_t to JSON string
static cJSON* marshal_enum_lv_obj_class_theme_inheritable_t(lv_obj_class_theme_inheritable_t value) {
    switch (value) {
        case LV_OBJ_CLASS_THEME_INHERITABLE_FALSE: return cJSON_CreateString("LV_OBJ_CLASS_THEME_INHERITABLE_FALSE");
        case LV_OBJ_CLASS_THEME_INHERITABLE_TRUE: return cJSON_CreateString("LV_OBJ_CLASS_THEME_INHERITABLE_TRUE");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_obj_class_theme_inheritable_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_key_t to JSON string
static cJSON* marshal_enum_lv_key_t(lv_key_t value) {
    switch (value) {
        case LV_KEY_UP: return cJSON_CreateString("LV_KEY_UP");
        case LV_KEY_DOWN: return cJSON_CreateString("LV_KEY_DOWN");
        case LV_KEY_RIGHT: return cJSON_CreateString("LV_KEY_RIGHT");
        case LV_KEY_LEFT: return cJSON_CreateString("LV_KEY_LEFT");
        case LV_KEY_ESC: return cJSON_CreateString("LV_KEY_ESC");
        case LV_KEY_DEL: return cJSON_CreateString("LV_KEY_DEL");
        case LV_KEY_BACKSPACE: return cJSON_CreateString("LV_KEY_BACKSPACE");
        case LV_KEY_ENTER: return cJSON_CreateString("LV_KEY_ENTER");
        case LV_KEY_NEXT: return cJSON_CreateString("LV_KEY_NEXT");
        case LV_KEY_PREV: return cJSON_CreateString("LV_KEY_PREV");
        case LV_KEY_HOME: return cJSON_CreateString("LV_KEY_HOME");
        case LV_KEY_END: return cJSON_CreateString("LV_KEY_END");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_key_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_group_refocus_policy_t to JSON string
static cJSON* marshal_enum_lv_group_refocus_policy_t(lv_group_refocus_policy_t value) {
    switch (value) {
        case LV_GROUP_REFOCUS_POLICY_NEXT: return cJSON_CreateString("LV_GROUP_REFOCUS_POLICY_NEXT");
        case LV_GROUP_REFOCUS_POLICY_PREV: return cJSON_CreateString("LV_GROUP_REFOCUS_POLICY_PREV");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_group_refocus_policy_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_indev_type_t to JSON string
static cJSON* marshal_enum_lv_indev_type_t(lv_indev_type_t value) {
    switch (value) {
        case LV_INDEV_TYPE_NONE: return cJSON_CreateString("LV_INDEV_TYPE_NONE");
        case LV_INDEV_TYPE_POINTER: return cJSON_CreateString("LV_INDEV_TYPE_POINTER");
        case LV_INDEV_TYPE_KEYPAD: return cJSON_CreateString("LV_INDEV_TYPE_KEYPAD");
        case LV_INDEV_TYPE_BUTTON: return cJSON_CreateString("LV_INDEV_TYPE_BUTTON");
        case LV_INDEV_TYPE_ENCODER: return cJSON_CreateString("LV_INDEV_TYPE_ENCODER");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_indev_type_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_indev_state_t to JSON string
static cJSON* marshal_enum_lv_indev_state_t(lv_indev_state_t value) {
    switch (value) {
        case LV_INDEV_STATE_RELEASED: return cJSON_CreateString("LV_INDEV_STATE_RELEASED");
        case LV_INDEV_STATE_PRESSED: return cJSON_CreateString("LV_INDEV_STATE_PRESSED");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_indev_state_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_indev_mode_t to JSON string
static cJSON* marshal_enum_lv_indev_mode_t(lv_indev_mode_t value) {
    switch (value) {
        case LV_INDEV_MODE_NONE: return cJSON_CreateString("LV_INDEV_MODE_NONE");
        case LV_INDEV_MODE_TIMER: return cJSON_CreateString("LV_INDEV_MODE_TIMER");
        case LV_INDEV_MODE_EVENT: return cJSON_CreateString("LV_INDEV_MODE_EVENT");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_indev_mode_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_indev_gesture_type_t to JSON string
static cJSON* marshal_enum_lv_indev_gesture_type_t(lv_indev_gesture_type_t value) {
    switch (value) {
        case LV_INDEV_GESTURE_NONE: return cJSON_CreateString("LV_INDEV_GESTURE_NONE");
        case LV_INDEV_GESTURE_PINCH: return cJSON_CreateString("LV_INDEV_GESTURE_PINCH");
        case LV_INDEV_GESTURE_SWIPE: return cJSON_CreateString("LV_INDEV_GESTURE_SWIPE");
        case LV_INDEV_GESTURE_ROTATE: return cJSON_CreateString("LV_INDEV_GESTURE_ROTATE");
        case LV_INDEV_GESTURE_TWO_FINGERS_SWIPE: return cJSON_CreateString("LV_INDEV_GESTURE_TWO_FINGERS_SWIPE");
        case LV_INDEV_GESTURE_SCROLL: return cJSON_CreateString("LV_INDEV_GESTURE_SCROLL");
        case LV_INDEV_GESTURE_CNT: return cJSON_CreateString("LV_INDEV_GESTURE_CNT");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_indev_gesture_type_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_cover_res_t to JSON string
static cJSON* marshal_enum_lv_cover_res_t(lv_cover_res_t value) {
    switch (value) {
        case LV_COVER_RES_COVER: return cJSON_CreateString("LV_COVER_RES_COVER");
        case LV_COVER_RES_NOT_COVER: return cJSON_CreateString("LV_COVER_RES_NOT_COVER");
        case LV_COVER_RES_MASKED: return cJSON_CreateString("LV_COVER_RES_MASKED");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_cover_res_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_state_enum_t to JSON string
static cJSON* marshal_enum_lv_state_enum_t(lv_state_enum_t value) {
    switch (value) {
        case LV_STATE_DEFAULT: return cJSON_CreateString("LV_STATE_DEFAULT");
        case LV_STATE_CHECKED: return cJSON_CreateString("LV_STATE_CHECKED");
        case LV_STATE_FOCUSED: return cJSON_CreateString("LV_STATE_FOCUSED");
        case LV_STATE_FOCUS_KEY: return cJSON_CreateString("LV_STATE_FOCUS_KEY");
        case LV_STATE_EDITED: return cJSON_CreateString("LV_STATE_EDITED");
        case LV_STATE_HOVERED: return cJSON_CreateString("LV_STATE_HOVERED");
        case LV_STATE_PRESSED: return cJSON_CreateString("LV_STATE_PRESSED");
        case LV_STATE_SCROLLED: return cJSON_CreateString("LV_STATE_SCROLLED");
        case LV_STATE_DISABLED: return cJSON_CreateString("LV_STATE_DISABLED");
        case LV_STATE_USER_1: return cJSON_CreateString("LV_STATE_USER_1");
        case LV_STATE_USER_2: return cJSON_CreateString("LV_STATE_USER_2");
        case LV_STATE_USER_3: return cJSON_CreateString("LV_STATE_USER_3");
        case LV_STATE_USER_4: return cJSON_CreateString("LV_STATE_USER_4");
        case LV_STATE_ANY: return cJSON_CreateString("LV_STATE_ANY");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_state_enum_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_style_parts_t to JSON string
static cJSON* marshal_enum_lv_style_parts_t(lv_style_parts_t value) {
    switch (value) {
        case LV_PART_MAIN: return cJSON_CreateString("LV_PART_MAIN");
        case LV_PART_SCROLLBAR: return cJSON_CreateString("LV_PART_SCROLLBAR");
        case LV_PART_INDICATOR: return cJSON_CreateString("LV_PART_INDICATOR");
        case LV_PART_KNOB: return cJSON_CreateString("LV_PART_KNOB");
        case LV_PART_SELECTED: return cJSON_CreateString("LV_PART_SELECTED");
        case LV_PART_ITEMS: return cJSON_CreateString("LV_PART_ITEMS");
        case LV_PART_CURSOR: return cJSON_CreateString("LV_PART_CURSOR");
        case LV_PART_CUSTOM_FIRST: return cJSON_CreateString("LV_PART_CUSTOM_FIRST");
        case LV_PART_ANY: return cJSON_CreateString("LV_PART_ANY");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_style_parts_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_obj_flag_t to JSON string
static cJSON* marshal_enum_lv_obj_flag_t(lv_obj_flag_t value) {
    switch (value) {
        case LV_OBJ_FLAG_HIDDEN: return cJSON_CreateString("LV_OBJ_FLAG_HIDDEN");
        case LV_OBJ_FLAG_CLICKABLE: return cJSON_CreateString("LV_OBJ_FLAG_CLICKABLE");
        case LV_OBJ_FLAG_CLICK_FOCUSABLE: return cJSON_CreateString("LV_OBJ_FLAG_CLICK_FOCUSABLE");
        case LV_OBJ_FLAG_CHECKABLE: return cJSON_CreateString("LV_OBJ_FLAG_CHECKABLE");
        case LV_OBJ_FLAG_SCROLLABLE: return cJSON_CreateString("LV_OBJ_FLAG_SCROLLABLE");
        case LV_OBJ_FLAG_SCROLL_ELASTIC: return cJSON_CreateString("LV_OBJ_FLAG_SCROLL_ELASTIC");
        case LV_OBJ_FLAG_SCROLL_MOMENTUM: return cJSON_CreateString("LV_OBJ_FLAG_SCROLL_MOMENTUM");
        case LV_OBJ_FLAG_SCROLL_ONE: return cJSON_CreateString("LV_OBJ_FLAG_SCROLL_ONE");
        case LV_OBJ_FLAG_SCROLL_CHAIN_HOR: return cJSON_CreateString("LV_OBJ_FLAG_SCROLL_CHAIN_HOR");
        case LV_OBJ_FLAG_SCROLL_CHAIN_VER: return cJSON_CreateString("LV_OBJ_FLAG_SCROLL_CHAIN_VER");
        case LV_OBJ_FLAG_SCROLL_CHAIN: return cJSON_CreateString("LV_OBJ_FLAG_SCROLL_CHAIN");
        case LV_OBJ_FLAG_SCROLL_ON_FOCUS: return cJSON_CreateString("LV_OBJ_FLAG_SCROLL_ON_FOCUS");
        case LV_OBJ_FLAG_SCROLL_WITH_ARROW: return cJSON_CreateString("LV_OBJ_FLAG_SCROLL_WITH_ARROW");
        case LV_OBJ_FLAG_SNAPPABLE: return cJSON_CreateString("LV_OBJ_FLAG_SNAPPABLE");
        case LV_OBJ_FLAG_PRESS_LOCK: return cJSON_CreateString("LV_OBJ_FLAG_PRESS_LOCK");
        case LV_OBJ_FLAG_EVENT_BUBBLE: return cJSON_CreateString("LV_OBJ_FLAG_EVENT_BUBBLE");
        case LV_OBJ_FLAG_GESTURE_BUBBLE: return cJSON_CreateString("LV_OBJ_FLAG_GESTURE_BUBBLE");
        case LV_OBJ_FLAG_ADV_HITTEST: return cJSON_CreateString("LV_OBJ_FLAG_ADV_HITTEST");
        case LV_OBJ_FLAG_IGNORE_LAYOUT: return cJSON_CreateString("LV_OBJ_FLAG_IGNORE_LAYOUT");
        case LV_OBJ_FLAG_FLOATING: return cJSON_CreateString("LV_OBJ_FLAG_FLOATING");
        case LV_OBJ_FLAG_SEND_DRAW_TASK_EVENTS: return cJSON_CreateString("LV_OBJ_FLAG_SEND_DRAW_TASK_EVENTS");
        case LV_OBJ_FLAG_OVERFLOW_VISIBLE: return cJSON_CreateString("LV_OBJ_FLAG_OVERFLOW_VISIBLE");
        case LV_OBJ_FLAG_FLEX_IN_NEW_TRACK: return cJSON_CreateString("LV_OBJ_FLAG_FLEX_IN_NEW_TRACK");
        case LV_OBJ_FLAG_LAYOUT_1: return cJSON_CreateString("LV_OBJ_FLAG_LAYOUT_1");
        case LV_OBJ_FLAG_LAYOUT_2: return cJSON_CreateString("LV_OBJ_FLAG_LAYOUT_2");
        case LV_OBJ_FLAG_WIDGET_1: return cJSON_CreateString("LV_OBJ_FLAG_WIDGET_1");
        case LV_OBJ_FLAG_WIDGET_2: return cJSON_CreateString("LV_OBJ_FLAG_WIDGET_2");
        case LV_OBJ_FLAG_USER_1: return cJSON_CreateString("LV_OBJ_FLAG_USER_1");
        case LV_OBJ_FLAG_USER_2: return cJSON_CreateString("LV_OBJ_FLAG_USER_2");
        case LV_OBJ_FLAG_USER_3: return cJSON_CreateString("LV_OBJ_FLAG_USER_3");
        case LV_OBJ_FLAG_USER_4: return cJSON_CreateString("LV_OBJ_FLAG_USER_4");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_obj_flag_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_font_fmt_txt_cmap_type_t to JSON string
static cJSON* marshal_enum_lv_font_fmt_txt_cmap_type_t(lv_font_fmt_txt_cmap_type_t value) {
    switch (value) {
        case LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL: return cJSON_CreateString("LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL");
        case LV_FONT_FMT_TXT_CMAP_SPARSE_FULL: return cJSON_CreateString("LV_FONT_FMT_TXT_CMAP_SPARSE_FULL");
        case LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY: return cJSON_CreateString("LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY");
        case LV_FONT_FMT_TXT_CMAP_SPARSE_TINY: return cJSON_CreateString("LV_FONT_FMT_TXT_CMAP_SPARSE_TINY");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_font_fmt_txt_cmap_type_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_font_fmt_txt_bitmap_format_t to JSON string
static cJSON* marshal_enum_lv_font_fmt_txt_bitmap_format_t(lv_font_fmt_txt_bitmap_format_t value) {
    switch (value) {
        case LV_FONT_FMT_TXT_PLAIN: return cJSON_CreateString("LV_FONT_FMT_TXT_PLAIN");
        case LV_FONT_FMT_TXT_COMPRESSED: return cJSON_CreateString("LV_FONT_FMT_TXT_COMPRESSED");
        case LV_FONT_FMT_TXT_COMPRESSED_NO_PREFILTER: return cJSON_CreateString("LV_FONT_FMT_TXT_COMPRESSED_NO_PREFILTER");
        case LV_FONT_FMT_PLAIN_ALIGNED: return cJSON_CreateString("LV_FONT_FMT_PLAIN_ALIGNED");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_font_fmt_txt_bitmap_format_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_image_align_t to JSON string
static cJSON* marshal_enum_lv_image_align_t(lv_image_align_t value) {
    switch (value) {
        case LV_IMAGE_ALIGN_DEFAULT: return cJSON_CreateString("LV_IMAGE_ALIGN_DEFAULT");
        case LV_IMAGE_ALIGN_TOP_LEFT: return cJSON_CreateString("LV_IMAGE_ALIGN_TOP_LEFT");
        case LV_IMAGE_ALIGN_TOP_MID: return cJSON_CreateString("LV_IMAGE_ALIGN_TOP_MID");
        case LV_IMAGE_ALIGN_TOP_RIGHT: return cJSON_CreateString("LV_IMAGE_ALIGN_TOP_RIGHT");
        case LV_IMAGE_ALIGN_BOTTOM_LEFT: return cJSON_CreateString("LV_IMAGE_ALIGN_BOTTOM_LEFT");
        case LV_IMAGE_ALIGN_BOTTOM_MID: return cJSON_CreateString("LV_IMAGE_ALIGN_BOTTOM_MID");
        case LV_IMAGE_ALIGN_BOTTOM_RIGHT: return cJSON_CreateString("LV_IMAGE_ALIGN_BOTTOM_RIGHT");
        case LV_IMAGE_ALIGN_LEFT_MID: return cJSON_CreateString("LV_IMAGE_ALIGN_LEFT_MID");
        case LV_IMAGE_ALIGN_RIGHT_MID: return cJSON_CreateString("LV_IMAGE_ALIGN_RIGHT_MID");
        case LV_IMAGE_ALIGN_CENTER: return cJSON_CreateString("LV_IMAGE_ALIGN_CENTER");
        case LV_IMAGE_ALIGN_AUTO_TRANSFORM: return cJSON_CreateString("LV_IMAGE_ALIGN_AUTO_TRANSFORM");
        case LV_IMAGE_ALIGN_STRETCH: return cJSON_CreateString("LV_IMAGE_ALIGN_STRETCH");
        case LV_IMAGE_ALIGN_TILE: return cJSON_CreateString("LV_IMAGE_ALIGN_TILE");
        case LV_IMAGE_ALIGN_CONTAIN: return cJSON_CreateString("LV_IMAGE_ALIGN_CONTAIN");
        case LV_IMAGE_ALIGN_COVER: return cJSON_CreateString("LV_IMAGE_ALIGN_COVER");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_image_align_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_animimg_part_t to JSON string
static cJSON* marshal_enum_lv_animimg_part_t(lv_animimg_part_t value) {
    switch (value) {
        case LV_ANIM_IMAGE_PART_MAIN: return cJSON_CreateString("LV_ANIM_IMAGE_PART_MAIN");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_animimg_part_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_arc_mode_t to JSON string
static cJSON* marshal_enum_lv_arc_mode_t(lv_arc_mode_t value) {
    switch (value) {
        case LV_ARC_MODE_NORMAL: return cJSON_CreateString("LV_ARC_MODE_NORMAL");
        case LV_ARC_MODE_SYMMETRICAL: return cJSON_CreateString("LV_ARC_MODE_SYMMETRICAL");
        case LV_ARC_MODE_REVERSE: return cJSON_CreateString("LV_ARC_MODE_REVERSE");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_arc_mode_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_label_long_mode_t to JSON string
static cJSON* marshal_enum_lv_label_long_mode_t(lv_label_long_mode_t value) {
    switch (value) {
        case LV_LABEL_LONG_MODE_WRAP: return cJSON_CreateString("LV_LABEL_LONG_MODE_WRAP");
        case LV_LABEL_LONG_MODE_DOTS: return cJSON_CreateString("LV_LABEL_LONG_MODE_DOTS");
        case LV_LABEL_LONG_MODE_SCROLL: return cJSON_CreateString("LV_LABEL_LONG_MODE_SCROLL");
        case LV_LABEL_LONG_MODE_SCROLL_CIRCULAR: return cJSON_CreateString("LV_LABEL_LONG_MODE_SCROLL_CIRCULAR");
        case LV_LABEL_LONG_MODE_CLIP: return cJSON_CreateString("LV_LABEL_LONG_MODE_CLIP");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_label_long_mode_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_bar_mode_t to JSON string
static cJSON* marshal_enum_lv_bar_mode_t(lv_bar_mode_t value) {
    switch (value) {
        case LV_BAR_MODE_NORMAL: return cJSON_CreateString("LV_BAR_MODE_NORMAL");
        case LV_BAR_MODE_SYMMETRICAL: return cJSON_CreateString("LV_BAR_MODE_SYMMETRICAL");
        case LV_BAR_MODE_RANGE: return cJSON_CreateString("LV_BAR_MODE_RANGE");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_bar_mode_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_bar_orientation_t to JSON string
static cJSON* marshal_enum_lv_bar_orientation_t(lv_bar_orientation_t value) {
    switch (value) {
        case LV_BAR_ORIENTATION_AUTO: return cJSON_CreateString("LV_BAR_ORIENTATION_AUTO");
        case LV_BAR_ORIENTATION_HORIZONTAL: return cJSON_CreateString("LV_BAR_ORIENTATION_HORIZONTAL");
        case LV_BAR_ORIENTATION_VERTICAL: return cJSON_CreateString("LV_BAR_ORIENTATION_VERTICAL");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_bar_orientation_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_buttonmatrix_ctrl_t to JSON string
static cJSON* marshal_enum_lv_buttonmatrix_ctrl_t(lv_buttonmatrix_ctrl_t value) {
    switch (value) {
        case LV_BUTTONMATRIX_CTRL_NONE: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_NONE");
        case LV_BUTTONMATRIX_CTRL_WIDTH_1: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_WIDTH_1");
        case LV_BUTTONMATRIX_CTRL_WIDTH_2: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_WIDTH_2");
        case LV_BUTTONMATRIX_CTRL_WIDTH_3: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_WIDTH_3");
        case LV_BUTTONMATRIX_CTRL_WIDTH_4: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_WIDTH_4");
        case LV_BUTTONMATRIX_CTRL_WIDTH_5: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_WIDTH_5");
        case LV_BUTTONMATRIX_CTRL_WIDTH_6: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_WIDTH_6");
        case LV_BUTTONMATRIX_CTRL_WIDTH_7: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_WIDTH_7");
        case LV_BUTTONMATRIX_CTRL_WIDTH_8: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_WIDTH_8");
        case LV_BUTTONMATRIX_CTRL_WIDTH_9: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_WIDTH_9");
        case LV_BUTTONMATRIX_CTRL_WIDTH_10: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_WIDTH_10");
        case LV_BUTTONMATRIX_CTRL_WIDTH_11: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_WIDTH_11");
        case LV_BUTTONMATRIX_CTRL_WIDTH_12: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_WIDTH_12");
        case LV_BUTTONMATRIX_CTRL_WIDTH_13: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_WIDTH_13");
        case LV_BUTTONMATRIX_CTRL_WIDTH_14: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_WIDTH_14");
        case LV_BUTTONMATRIX_CTRL_WIDTH_15: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_WIDTH_15");
        case LV_BUTTONMATRIX_CTRL_HIDDEN: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_HIDDEN");
        case LV_BUTTONMATRIX_CTRL_NO_REPEAT: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_NO_REPEAT");
        case LV_BUTTONMATRIX_CTRL_DISABLED: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_DISABLED");
        case LV_BUTTONMATRIX_CTRL_CHECKABLE: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_CHECKABLE");
        case LV_BUTTONMATRIX_CTRL_CHECKED: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_CHECKED");
        case LV_BUTTONMATRIX_CTRL_CLICK_TRIG: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_CLICK_TRIG");
        case LV_BUTTONMATRIX_CTRL_POPOVER: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_POPOVER");
        case LV_BUTTONMATRIX_CTRL_RECOLOR: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_RECOLOR");
        case LV_BUTTONMATRIX_CTRL_RESERVED_1: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_RESERVED_1");
        case LV_BUTTONMATRIX_CTRL_RESERVED_2: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_RESERVED_2");
        case LV_BUTTONMATRIX_CTRL_CUSTOM_1: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_CUSTOM_1");
        case LV_BUTTONMATRIX_CTRL_CUSTOM_2: return cJSON_CreateString("LV_BUTTONMATRIX_CTRL_CUSTOM_2");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_buttonmatrix_ctrl_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_chart_type_t to JSON string
static cJSON* marshal_enum_lv_chart_type_t(lv_chart_type_t value) {
    switch (value) {
        case LV_CHART_TYPE_NONE: return cJSON_CreateString("LV_CHART_TYPE_NONE");
        case LV_CHART_TYPE_LINE: return cJSON_CreateString("LV_CHART_TYPE_LINE");
        case LV_CHART_TYPE_BAR: return cJSON_CreateString("LV_CHART_TYPE_BAR");
        case LV_CHART_TYPE_SCATTER: return cJSON_CreateString("LV_CHART_TYPE_SCATTER");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_chart_type_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_chart_update_mode_t to JSON string
static cJSON* marshal_enum_lv_chart_update_mode_t(lv_chart_update_mode_t value) {
    switch (value) {
        case LV_CHART_UPDATE_MODE_SHIFT: return cJSON_CreateString("LV_CHART_UPDATE_MODE_SHIFT");
        case LV_CHART_UPDATE_MODE_CIRCULAR: return cJSON_CreateString("LV_CHART_UPDATE_MODE_CIRCULAR");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_chart_update_mode_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_chart_axis_t to JSON string
static cJSON* marshal_enum_lv_chart_axis_t(lv_chart_axis_t value) {
    switch (value) {
        case LV_CHART_AXIS_PRIMARY_Y: return cJSON_CreateString("LV_CHART_AXIS_PRIMARY_Y");
        case LV_CHART_AXIS_SECONDARY_Y: return cJSON_CreateString("LV_CHART_AXIS_SECONDARY_Y");
        case LV_CHART_AXIS_PRIMARY_X: return cJSON_CreateString("LV_CHART_AXIS_PRIMARY_X");
        case LV_CHART_AXIS_SECONDARY_X: return cJSON_CreateString("LV_CHART_AXIS_SECONDARY_X");
        case LV_CHART_AXIS_LAST: return cJSON_CreateString("LV_CHART_AXIS_LAST");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_chart_axis_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_imagebutton_state_t to JSON string
static cJSON* marshal_enum_lv_imagebutton_state_t(lv_imagebutton_state_t value) {
    switch (value) {
        case LV_IMAGEBUTTON_STATE_RELEASED: return cJSON_CreateString("LV_IMAGEBUTTON_STATE_RELEASED");
        case LV_IMAGEBUTTON_STATE_PRESSED: return cJSON_CreateString("LV_IMAGEBUTTON_STATE_PRESSED");
        case LV_IMAGEBUTTON_STATE_DISABLED: return cJSON_CreateString("LV_IMAGEBUTTON_STATE_DISABLED");
        case LV_IMAGEBUTTON_STATE_CHECKED_RELEASED: return cJSON_CreateString("LV_IMAGEBUTTON_STATE_CHECKED_RELEASED");
        case LV_IMAGEBUTTON_STATE_CHECKED_PRESSED: return cJSON_CreateString("LV_IMAGEBUTTON_STATE_CHECKED_PRESSED");
        case LV_IMAGEBUTTON_STATE_CHECKED_DISABLED: return cJSON_CreateString("LV_IMAGEBUTTON_STATE_CHECKED_DISABLED");
        case LV_IMAGEBUTTON_STATE_NUM: return cJSON_CreateString("LV_IMAGEBUTTON_STATE_NUM");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_imagebutton_state_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_keyboard_mode_t to JSON string
static cJSON* marshal_enum_lv_keyboard_mode_t(lv_keyboard_mode_t value) {
    switch (value) {
        case LV_KEYBOARD_MODE_TEXT_LOWER: return cJSON_CreateString("LV_KEYBOARD_MODE_TEXT_LOWER");
        case LV_KEYBOARD_MODE_TEXT_UPPER: return cJSON_CreateString("LV_KEYBOARD_MODE_TEXT_UPPER");
        case LV_KEYBOARD_MODE_SPECIAL: return cJSON_CreateString("LV_KEYBOARD_MODE_SPECIAL");
        case LV_KEYBOARD_MODE_NUMBER: return cJSON_CreateString("LV_KEYBOARD_MODE_NUMBER");
        case LV_KEYBOARD_MODE_USER_1: return cJSON_CreateString("LV_KEYBOARD_MODE_USER_1");
        case LV_KEYBOARD_MODE_USER_2: return cJSON_CreateString("LV_KEYBOARD_MODE_USER_2");
        case LV_KEYBOARD_MODE_USER_3: return cJSON_CreateString("LV_KEYBOARD_MODE_USER_3");
        case LV_KEYBOARD_MODE_USER_4: return cJSON_CreateString("LV_KEYBOARD_MODE_USER_4");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_keyboard_mode_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_menu_mode_header_t to JSON string
static cJSON* marshal_enum_lv_menu_mode_header_t(lv_menu_mode_header_t value) {
    switch (value) {
        case LV_MENU_HEADER_TOP_FIXED: return cJSON_CreateString("LV_MENU_HEADER_TOP_FIXED");
        case LV_MENU_HEADER_TOP_UNFIXED: return cJSON_CreateString("LV_MENU_HEADER_TOP_UNFIXED");
        case LV_MENU_HEADER_BOTTOM_FIXED: return cJSON_CreateString("LV_MENU_HEADER_BOTTOM_FIXED");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_menu_mode_header_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_menu_mode_root_back_button_t to JSON string
static cJSON* marshal_enum_lv_menu_mode_root_back_button_t(lv_menu_mode_root_back_button_t value) {
    switch (value) {
        case LV_MENU_ROOT_BACK_BUTTON_DISABLED: return cJSON_CreateString("LV_MENU_ROOT_BACK_BUTTON_DISABLED");
        case LV_MENU_ROOT_BACK_BUTTON_ENABLED: return cJSON_CreateString("LV_MENU_ROOT_BACK_BUTTON_ENABLED");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_menu_mode_root_back_button_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_roller_mode_t to JSON string
static cJSON* marshal_enum_lv_roller_mode_t(lv_roller_mode_t value) {
    switch (value) {
        case LV_ROLLER_MODE_NORMAL: return cJSON_CreateString("LV_ROLLER_MODE_NORMAL");
        case LV_ROLLER_MODE_INFINITE: return cJSON_CreateString("LV_ROLLER_MODE_INFINITE");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_roller_mode_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_scale_mode_t to JSON string
static cJSON* marshal_enum_lv_scale_mode_t(lv_scale_mode_t value) {
    switch (value) {
        case LV_SCALE_MODE_HORIZONTAL_TOP: return cJSON_CreateString("LV_SCALE_MODE_HORIZONTAL_TOP");
        case LV_SCALE_MODE_HORIZONTAL_BOTTOM: return cJSON_CreateString("LV_SCALE_MODE_HORIZONTAL_BOTTOM");
        case LV_SCALE_MODE_VERTICAL_LEFT: return cJSON_CreateString("LV_SCALE_MODE_VERTICAL_LEFT");
        case LV_SCALE_MODE_VERTICAL_RIGHT: return cJSON_CreateString("LV_SCALE_MODE_VERTICAL_RIGHT");
        case LV_SCALE_MODE_ROUND_INNER: return cJSON_CreateString("LV_SCALE_MODE_ROUND_INNER");
        case LV_SCALE_MODE_ROUND_OUTER: return cJSON_CreateString("LV_SCALE_MODE_ROUND_OUTER");
        case LV_SCALE_MODE_LAST: return cJSON_CreateString("LV_SCALE_MODE_LAST");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_scale_mode_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_slider_mode_t to JSON string
static cJSON* marshal_enum_lv_slider_mode_t(lv_slider_mode_t value) {
    switch (value) {
        case LV_SLIDER_MODE_NORMAL: return cJSON_CreateString("LV_SLIDER_MODE_NORMAL");
        case LV_SLIDER_MODE_SYMMETRICAL: return cJSON_CreateString("LV_SLIDER_MODE_SYMMETRICAL");
        case LV_SLIDER_MODE_RANGE: return cJSON_CreateString("LV_SLIDER_MODE_RANGE");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_slider_mode_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_slider_orientation_t to JSON string
static cJSON* marshal_enum_lv_slider_orientation_t(lv_slider_orientation_t value) {
    switch (value) {
        case LV_SLIDER_ORIENTATION_AUTO: return cJSON_CreateString("LV_SLIDER_ORIENTATION_AUTO");
        case LV_SLIDER_ORIENTATION_HORIZONTAL: return cJSON_CreateString("LV_SLIDER_ORIENTATION_HORIZONTAL");
        case LV_SLIDER_ORIENTATION_VERTICAL: return cJSON_CreateString("LV_SLIDER_ORIENTATION_VERTICAL");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_slider_orientation_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_span_overflow_t to JSON string
static cJSON* marshal_enum_lv_span_overflow_t(lv_span_overflow_t value) {
    switch (value) {
        case LV_SPAN_OVERFLOW_CLIP: return cJSON_CreateString("LV_SPAN_OVERFLOW_CLIP");
        case LV_SPAN_OVERFLOW_ELLIPSIS: return cJSON_CreateString("LV_SPAN_OVERFLOW_ELLIPSIS");
        case LV_SPAN_OVERFLOW_LAST: return cJSON_CreateString("LV_SPAN_OVERFLOW_LAST");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_span_overflow_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_span_mode_t to JSON string
static cJSON* marshal_enum_lv_span_mode_t(lv_span_mode_t value) {
    switch (value) {
        case LV_SPAN_MODE_FIXED: return cJSON_CreateString("LV_SPAN_MODE_FIXED");
        case LV_SPAN_MODE_EXPAND: return cJSON_CreateString("LV_SPAN_MODE_EXPAND");
        case LV_SPAN_MODE_BREAK: return cJSON_CreateString("LV_SPAN_MODE_BREAK");
        case LV_SPAN_MODE_LAST: return cJSON_CreateString("LV_SPAN_MODE_LAST");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_span_mode_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_switch_orientation_t to JSON string
static cJSON* marshal_enum_lv_switch_orientation_t(lv_switch_orientation_t value) {
    switch (value) {
        case LV_SWITCH_ORIENTATION_AUTO: return cJSON_CreateString("LV_SWITCH_ORIENTATION_AUTO");
        case LV_SWITCH_ORIENTATION_HORIZONTAL: return cJSON_CreateString("LV_SWITCH_ORIENTATION_HORIZONTAL");
        case LV_SWITCH_ORIENTATION_VERTICAL: return cJSON_CreateString("LV_SWITCH_ORIENTATION_VERTICAL");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_switch_orientation_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_table_cell_ctrl_t to JSON string
static cJSON* marshal_enum_lv_table_cell_ctrl_t(lv_table_cell_ctrl_t value) {
    switch (value) {
        case LV_TABLE_CELL_CTRL_NONE: return cJSON_CreateString("LV_TABLE_CELL_CTRL_NONE");
        case LV_TABLE_CELL_CTRL_MERGE_RIGHT: return cJSON_CreateString("LV_TABLE_CELL_CTRL_MERGE_RIGHT");
        case LV_TABLE_CELL_CTRL_TEXT_CROP: return cJSON_CreateString("LV_TABLE_CELL_CTRL_TEXT_CROP");
        case LV_TABLE_CELL_CTRL_CUSTOM_1: return cJSON_CreateString("LV_TABLE_CELL_CTRL_CUSTOM_1");
        case LV_TABLE_CELL_CTRL_CUSTOM_2: return cJSON_CreateString("LV_TABLE_CELL_CTRL_CUSTOM_2");
        case LV_TABLE_CELL_CTRL_CUSTOM_3: return cJSON_CreateString("LV_TABLE_CELL_CTRL_CUSTOM_3");
        case LV_TABLE_CELL_CTRL_CUSTOM_4: return cJSON_CreateString("LV_TABLE_CELL_CTRL_CUSTOM_4");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_table_cell_ctrl_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_subject_type_t to JSON string
static cJSON* marshal_enum_lv_subject_type_t(lv_subject_type_t value) {
    switch (value) {
        case LV_SUBJECT_TYPE_INVALID: return cJSON_CreateString("LV_SUBJECT_TYPE_INVALID");
        case LV_SUBJECT_TYPE_NONE: return cJSON_CreateString("LV_SUBJECT_TYPE_NONE");
        case LV_SUBJECT_TYPE_INT: return cJSON_CreateString("LV_SUBJECT_TYPE_INT");
        case LV_SUBJECT_TYPE_POINTER: return cJSON_CreateString("LV_SUBJECT_TYPE_POINTER");
        case LV_SUBJECT_TYPE_COLOR: return cJSON_CreateString("LV_SUBJECT_TYPE_COLOR");
        case LV_SUBJECT_TYPE_GROUP: return cJSON_CreateString("LV_SUBJECT_TYPE_GROUP");
        case LV_SUBJECT_TYPE_STRING: return cJSON_CreateString("LV_SUBJECT_TYPE_STRING");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_subject_type_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_gridnav_ctrl_t to JSON string
static cJSON* marshal_enum_lv_gridnav_ctrl_t(lv_gridnav_ctrl_t value) {
    switch (value) {
        case LV_GRIDNAV_CTRL_NONE: return cJSON_CreateString("LV_GRIDNAV_CTRL_NONE");
        case LV_GRIDNAV_CTRL_ROLLOVER: return cJSON_CreateString("LV_GRIDNAV_CTRL_ROLLOVER");
        case LV_GRIDNAV_CTRL_SCROLL_FIRST: return cJSON_CreateString("LV_GRIDNAV_CTRL_SCROLL_FIRST");
        case LV_GRIDNAV_CTRL_HORIZONTAL_MOVE_ONLY: return cJSON_CreateString("LV_GRIDNAV_CTRL_HORIZONTAL_MOVE_ONLY");
        case LV_GRIDNAV_CTRL_VERTICAL_MOVE_ONLY: return cJSON_CreateString("LV_GRIDNAV_CTRL_VERTICAL_MOVE_ONLY");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_gridnav_ctrl_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_freetype_font_style_t to JSON string
static cJSON* marshal_enum_lv_freetype_font_style_t(lv_freetype_font_style_t value) {
    switch (value) {
        case LV_FREETYPE_FONT_STYLE_NORMAL: return cJSON_CreateString("LV_FREETYPE_FONT_STYLE_NORMAL");
        case LV_FREETYPE_FONT_STYLE_ITALIC: return cJSON_CreateString("LV_FREETYPE_FONT_STYLE_ITALIC");
        case LV_FREETYPE_FONT_STYLE_BOLD: return cJSON_CreateString("LV_FREETYPE_FONT_STYLE_BOLD");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_freetype_font_style_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_freetype_font_render_mode_t to JSON string
static cJSON* marshal_enum_lv_freetype_font_render_mode_t(lv_freetype_font_render_mode_t value) {
    switch (value) {
        case LV_FREETYPE_FONT_RENDER_MODE_BITMAP: return cJSON_CreateString("LV_FREETYPE_FONT_RENDER_MODE_BITMAP");
        case LV_FREETYPE_FONT_RENDER_MODE_OUTLINE: return cJSON_CreateString("LV_FREETYPE_FONT_RENDER_MODE_OUTLINE");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_freetype_font_render_mode_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal enum lv_freetype_outline_type_t to JSON string
static cJSON* marshal_enum_lv_freetype_outline_type_t(lv_freetype_outline_type_t value) {
    switch (value) {
        case LV_FREETYPE_OUTLINE_END: return cJSON_CreateString("LV_FREETYPE_OUTLINE_END");
        case LV_FREETYPE_OUTLINE_MOVE_TO: return cJSON_CreateString("LV_FREETYPE_OUTLINE_MOVE_TO");
        case LV_FREETYPE_OUTLINE_LINE_TO: return cJSON_CreateString("LV_FREETYPE_OUTLINE_LINE_TO");
        case LV_FREETYPE_OUTLINE_CUBIC_TO: return cJSON_CreateString("LV_FREETYPE_OUTLINE_CUBIC_TO");
        case LV_FREETYPE_OUTLINE_CONIC_TO: return cJSON_CreateString("LV_FREETYPE_OUTLINE_CONIC_TO");
        case LV_FREETYPE_OUTLINE_BORDER_START: return cJSON_CreateString("LV_FREETYPE_OUTLINE_BORDER_START");
        default:
            char buf[40]; // Increased size for name + value
            snprintf(buf, sizeof(buf), "lv_freetype_outline_type_t_VALUE(%%d)", (int)value);
            return cJSON_CreateString(buf);
    }
}

// Marshal struct struct lv_mem_monitor_t to JSON object
static cJSON* marshal_struct_lv_mem_monitor_t(const struct lv_mem_monitor_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_mem_monitor_t");
    cJSON *field_json = marshal_value(&value->total_size, "size_t", "size_t", false, false, false, false, false, "total_size");
    if (field_json) {
        cJSON_AddItemToObject(obj, "total_size", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'total_size' in struct lv_mem_monitor_t\n");
        cJSON_AddNullToObject(obj, "total_size");
    }
    cJSON *field_json = marshal_value(&value->free_cnt, "size_t", "size_t", false, false, false, false, false, "free_cnt");
    if (field_json) {
        cJSON_AddItemToObject(obj, "free_cnt", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'free_cnt' in struct lv_mem_monitor_t\n");
        cJSON_AddNullToObject(obj, "free_cnt");
    }
    cJSON *field_json = marshal_value(&value->free_size, "size_t", "size_t", false, false, false, false, false, "free_size");
    if (field_json) {
        cJSON_AddItemToObject(obj, "free_size", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'free_size' in struct lv_mem_monitor_t\n");
        cJSON_AddNullToObject(obj, "free_size");
    }
    cJSON *field_json = marshal_value(&value->free_biggest_size, "size_t", "size_t", false, false, false, false, false, "free_biggest_size");
    if (field_json) {
        cJSON_AddItemToObject(obj, "free_biggest_size", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'free_biggest_size' in struct lv_mem_monitor_t\n");
        cJSON_AddNullToObject(obj, "free_biggest_size");
    }
    cJSON *field_json = marshal_value(&value->used_cnt, "size_t", "size_t", false, false, false, false, false, "used_cnt");
    if (field_json) {
        cJSON_AddItemToObject(obj, "used_cnt", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'used_cnt' in struct lv_mem_monitor_t\n");
        cJSON_AddNullToObject(obj, "used_cnt");
    }
    cJSON *field_json = marshal_value(&value->max_used, "size_t", "size_t", false, false, false, false, false, "max_used");
    if (field_json) {
        cJSON_AddItemToObject(obj, "max_used", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'max_used' in struct lv_mem_monitor_t\n");
        cJSON_AddNullToObject(obj, "max_used");
    }
    cJSON *field_json = marshal_value(&value->used_pct, "uint8_t", "uint8_t", false, false, false, false, false, "used_pct");
    if (field_json) {
        cJSON_AddItemToObject(obj, "used_pct", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'used_pct' in struct lv_mem_monitor_t\n");
        cJSON_AddNullToObject(obj, "used_pct");
    }
    cJSON *field_json = marshal_value(&value->frag_pct, "uint8_t", "uint8_t", false, false, false, false, false, "frag_pct");
    if (field_json) {
        cJSON_AddItemToObject(obj, "frag_pct", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'frag_pct' in struct lv_mem_monitor_t\n");
        cJSON_AddNullToObject(obj, "frag_pct");
    }
    return obj;
}

// Marshal struct struct lv_sqrt_res_t to JSON object
static cJSON* marshal_struct_lv_sqrt_res_t(const struct lv_sqrt_res_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_sqrt_res_t");
    cJSON *field_json = marshal_value(&value->i, "uint16_t", "uint16_t", false, false, false, false, false, "i");
    if (field_json) {
        cJSON_AddItemToObject(obj, "i", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'i' in struct lv_sqrt_res_t\n");
        cJSON_AddNullToObject(obj, "i");
    }
    cJSON *field_json = marshal_value(&value->f, "uint16_t", "uint16_t", false, false, false, false, false, "f");
    if (field_json) {
        cJSON_AddItemToObject(obj, "f", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'f' in struct lv_sqrt_res_t\n");
        cJSON_AddNullToObject(obj, "f");
    }
    return obj;
}

// Marshal struct struct lv_anim_bezier3_para_t to JSON object
static cJSON* marshal_struct_lv_anim_bezier3_para_t(const struct lv_anim_bezier3_para_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_anim_bezier3_para_t");
    cJSON *field_json = marshal_value(&value->x1, "int16_t", "int16_t", false, false, false, false, false, "x1");
    if (field_json) {
        cJSON_AddItemToObject(obj, "x1", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'x1' in struct lv_anim_bezier3_para_t\n");
        cJSON_AddNullToObject(obj, "x1");
    }
    cJSON *field_json = marshal_value(&value->y1, "int16_t", "int16_t", false, false, false, false, false, "y1");
    if (field_json) {
        cJSON_AddItemToObject(obj, "y1", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'y1' in struct lv_anim_bezier3_para_t\n");
        cJSON_AddNullToObject(obj, "y1");
    }
    cJSON *field_json = marshal_value(&value->x2, "int16_t", "int16_t", false, false, false, false, false, "x2");
    if (field_json) {
        cJSON_AddItemToObject(obj, "x2", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'x2' in struct lv_anim_bezier3_para_t\n");
        cJSON_AddNullToObject(obj, "x2");
    }
    cJSON *field_json = marshal_value(&value->y2, "int16_t", "int16_t", false, false, false, false, false, "y2");
    if (field_json) {
        cJSON_AddItemToObject(obj, "y2", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'y2' in struct lv_anim_bezier3_para_t\n");
        cJSON_AddNullToObject(obj, "y2");
    }
    return obj;
}

// Marshal struct struct lv_point_t to JSON object
static cJSON* marshal_struct_lv_point_t(const struct lv_point_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_point_t");
    cJSON *field_json = marshal_value(&value->x, "int32_t", "int32_t", false, false, false, false, false, "x");
    if (field_json) {
        cJSON_AddItemToObject(obj, "x", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'x' in struct lv_point_t\n");
        cJSON_AddNullToObject(obj, "x");
    }
    cJSON *field_json = marshal_value(&value->y, "int32_t", "int32_t", false, false, false, false, false, "y");
    if (field_json) {
        cJSON_AddItemToObject(obj, "y", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'y' in struct lv_point_t\n");
        cJSON_AddNullToObject(obj, "y");
    }
    return obj;
}

// Marshal struct struct lv_area_t to JSON object
static cJSON* marshal_struct_lv_area_t(const struct lv_area_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_area_t");
    cJSON *field_json = marshal_value(&value->x1, "int32_t", "int32_t", false, false, false, false, false, "x1");
    if (field_json) {
        cJSON_AddItemToObject(obj, "x1", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'x1' in struct lv_area_t\n");
        cJSON_AddNullToObject(obj, "x1");
    }
    cJSON *field_json = marshal_value(&value->y1, "int32_t", "int32_t", false, false, false, false, false, "y1");
    if (field_json) {
        cJSON_AddItemToObject(obj, "y1", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'y1' in struct lv_area_t\n");
        cJSON_AddNullToObject(obj, "y1");
    }
    cJSON *field_json = marshal_value(&value->x2, "int32_t", "int32_t", false, false, false, false, false, "x2");
    if (field_json) {
        cJSON_AddItemToObject(obj, "x2", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'x2' in struct lv_area_t\n");
        cJSON_AddNullToObject(obj, "x2");
    }
    cJSON *field_json = marshal_value(&value->y2, "int32_t", "int32_t", false, false, false, false, false, "y2");
    if (field_json) {
        cJSON_AddItemToObject(obj, "y2", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'y2' in struct lv_area_t\n");
        cJSON_AddNullToObject(obj, "y2");
    }
    return obj;
}

// Marshal struct struct lv_color_t to JSON object
static cJSON* marshal_struct_lv_color_t(const struct lv_color_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_color_t");
    cJSON *field_json = marshal_value(&value->blue, "uint8_t", "uint8_t", false, false, false, false, false, "blue");
    if (field_json) {
        cJSON_AddItemToObject(obj, "blue", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'blue' in struct lv_color_t\n");
        cJSON_AddNullToObject(obj, "blue");
    }
    cJSON *field_json = marshal_value(&value->green, "uint8_t", "uint8_t", false, false, false, false, false, "green");
    if (field_json) {
        cJSON_AddItemToObject(obj, "green", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'green' in struct lv_color_t\n");
        cJSON_AddNullToObject(obj, "green");
    }
    cJSON *field_json = marshal_value(&value->red, "uint8_t", "uint8_t", false, false, false, false, false, "red");
    if (field_json) {
        cJSON_AddItemToObject(obj, "red", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'red' in struct lv_color_t\n");
        cJSON_AddNullToObject(obj, "red");
    }
    return obj;
}

// Marshal struct struct lv_color16_t to JSON object
static cJSON* marshal_struct_lv_color16_t(const struct lv_color16_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_color16_t");
    cJSON *field_json = marshal_value(&value->blue, "uint16_t", "uint16_t", false, false, false, false, false, "blue");
    if (field_json) {
        cJSON_AddItemToObject(obj, "blue", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'blue' in struct lv_color16_t\n");
        cJSON_AddNullToObject(obj, "blue");
    }
    cJSON *field_json = marshal_value(&value->green, "uint16_t", "uint16_t", false, false, false, false, false, "green");
    if (field_json) {
        cJSON_AddItemToObject(obj, "green", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'green' in struct lv_color16_t\n");
        cJSON_AddNullToObject(obj, "green");
    }
    cJSON *field_json = marshal_value(&value->red, "uint16_t", "uint16_t", false, false, false, false, false, "red");
    if (field_json) {
        cJSON_AddItemToObject(obj, "red", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'red' in struct lv_color16_t\n");
        cJSON_AddNullToObject(obj, "red");
    }
    return obj;
}

// Marshal struct struct lv_color32_t to JSON object
static cJSON* marshal_struct_lv_color32_t(const struct lv_color32_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_color32_t");
    cJSON *field_json = marshal_value(&value->blue, "uint8_t", "uint8_t", false, false, false, false, false, "blue");
    if (field_json) {
        cJSON_AddItemToObject(obj, "blue", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'blue' in struct lv_color32_t\n");
        cJSON_AddNullToObject(obj, "blue");
    }
    cJSON *field_json = marshal_value(&value->green, "uint8_t", "uint8_t", false, false, false, false, false, "green");
    if (field_json) {
        cJSON_AddItemToObject(obj, "green", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'green' in struct lv_color32_t\n");
        cJSON_AddNullToObject(obj, "green");
    }
    cJSON *field_json = marshal_value(&value->red, "uint8_t", "uint8_t", false, false, false, false, false, "red");
    if (field_json) {
        cJSON_AddItemToObject(obj, "red", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'red' in struct lv_color32_t\n");
        cJSON_AddNullToObject(obj, "red");
    }
    cJSON *field_json = marshal_value(&value->alpha, "uint8_t", "uint8_t", false, false, false, false, false, "alpha");
    if (field_json) {
        cJSON_AddItemToObject(obj, "alpha", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'alpha' in struct lv_color32_t\n");
        cJSON_AddNullToObject(obj, "alpha");
    }
    return obj;
}

// Marshal struct struct lv_color_hsv_t to JSON object
static cJSON* marshal_struct_lv_color_hsv_t(const struct lv_color_hsv_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_color_hsv_t");
    cJSON *field_json = marshal_value(&value->h, "uint16_t", "uint16_t", false, false, false, false, false, "h");
    if (field_json) {
        cJSON_AddItemToObject(obj, "h", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'h' in struct lv_color_hsv_t\n");
        cJSON_AddNullToObject(obj, "h");
    }
    cJSON *field_json = marshal_value(&value->s, "uint8_t", "uint8_t", false, false, false, false, false, "s");
    if (field_json) {
        cJSON_AddItemToObject(obj, "s", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 's' in struct lv_color_hsv_t\n");
        cJSON_AddNullToObject(obj, "s");
    }
    cJSON *field_json = marshal_value(&value->v, "uint8_t", "uint8_t", false, false, false, false, false, "v");
    if (field_json) {
        cJSON_AddItemToObject(obj, "v", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'v' in struct lv_color_hsv_t\n");
        cJSON_AddNullToObject(obj, "v");
    }
    return obj;
}

// Marshal struct struct lv_color16a_t to JSON object
static cJSON* marshal_struct_lv_color16a_t(const struct lv_color16a_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_color16a_t");
    cJSON *field_json = marshal_value(&value->lumi, "uint8_t", "uint8_t", false, false, false, false, false, "lumi");
    if (field_json) {
        cJSON_AddItemToObject(obj, "lumi", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'lumi' in struct lv_color16a_t\n");
        cJSON_AddNullToObject(obj, "lumi");
    }
    cJSON *field_json = marshal_value(&value->alpha, "uint8_t", "uint8_t", false, false, false, false, false, "alpha");
    if (field_json) {
        cJSON_AddItemToObject(obj, "alpha", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'alpha' in struct lv_color16a_t\n");
        cJSON_AddNullToObject(obj, "alpha");
    }
    return obj;
}

// Marshal struct struct lv_image_header_t to JSON object
static cJSON* marshal_struct_lv_image_header_t(const struct lv_image_header_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_image_header_t");
    cJSON *field_json = marshal_value(&value->magic, "uint32_t", "uint32_t", false, false, false, false, false, "magic");
    if (field_json) {
        cJSON_AddItemToObject(obj, "magic", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'magic' in struct lv_image_header_t\n");
        cJSON_AddNullToObject(obj, "magic");
    }
    cJSON *field_json = marshal_value(&value->cf, "uint32_t", "uint32_t", false, false, false, false, false, "cf");
    if (field_json) {
        cJSON_AddItemToObject(obj, "cf", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'cf' in struct lv_image_header_t\n");
        cJSON_AddNullToObject(obj, "cf");
    }
    cJSON *field_json = marshal_value(&value->flags, "uint32_t", "uint32_t", false, false, false, false, false, "flags");
    if (field_json) {
        cJSON_AddItemToObject(obj, "flags", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'flags' in struct lv_image_header_t\n");
        cJSON_AddNullToObject(obj, "flags");
    }
    cJSON *field_json = marshal_value(&value->w, "uint32_t", "uint32_t", false, false, false, false, false, "w");
    if (field_json) {
        cJSON_AddItemToObject(obj, "w", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'w' in struct lv_image_header_t\n");
        cJSON_AddNullToObject(obj, "w");
    }
    cJSON *field_json = marshal_value(&value->h, "uint32_t", "uint32_t", false, false, false, false, false, "h");
    if (field_json) {
        cJSON_AddItemToObject(obj, "h", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'h' in struct lv_image_header_t\n");
        cJSON_AddNullToObject(obj, "h");
    }
    cJSON *field_json = marshal_value(&value->stride, "uint32_t", "uint32_t", false, false, false, false, false, "stride");
    if (field_json) {
        cJSON_AddItemToObject(obj, "stride", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'stride' in struct lv_image_header_t\n");
        cJSON_AddNullToObject(obj, "stride");
    }
    cJSON *field_json = marshal_value(&value->reserved_2, "uint32_t", "uint32_t", false, false, false, false, false, "reserved_2");
    if (field_json) {
        cJSON_AddItemToObject(obj, "reserved_2", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'reserved_2' in struct lv_image_header_t\n");
        cJSON_AddNullToObject(obj, "reserved_2");
    }
    return obj;
}

// Marshal struct struct lv_img_dsc_t to JSON object
static cJSON* marshal_struct_lv_img_dsc_t(const struct lv_img_dsc_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_img_dsc_t");
    cJSON *field_json = marshal_value(&value->header, "struct lv_image_header_t", "lv_image_header_t", false, false, true, false, false, "header");
    if (field_json) {
        cJSON_AddItemToObject(obj, "header", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'header' in struct lv_img_dsc_t\n");
        cJSON_AddNullToObject(obj, "header");
    }
    cJSON *field_json = marshal_value(&value->data_size, "uint32_t", "uint32_t", false, false, false, false, false, "data_size");
    if (field_json) {
        cJSON_AddItemToObject(obj, "data_size", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'data_size' in struct lv_img_dsc_t\n");
        cJSON_AddNullToObject(obj, "data_size");
    }
    cJSON *field_json = marshal_value(&value->data, "uint8_t*", "uint8_t", true, false, false, false, false, "data");
    if (field_json) {
        cJSON_AddItemToObject(obj, "data", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'data' in struct lv_img_dsc_t\n");
        cJSON_AddNullToObject(obj, "data");
    }
    cJSON *field_json = marshal_value(&value->reserved, "void*", "void", true, false, false, false, false, "reserved");
    if (field_json) {
        cJSON_AddItemToObject(obj, "reserved", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'reserved' in struct lv_img_dsc_t\n");
        cJSON_AddNullToObject(obj, "reserved");
    }
    cJSON *field_json = marshal_value(&value->reserved_2, "void*", "void", true, false, false, false, false, "reserved_2");
    if (field_json) {
        cJSON_AddItemToObject(obj, "reserved_2", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'reserved_2' in struct lv_img_dsc_t\n");
        cJSON_AddNullToObject(obj, "reserved_2");
    }
    return obj;
}

// Marshal struct struct lv_grad_stop_t to JSON object
static cJSON* marshal_struct_lv_grad_stop_t(const struct lv_grad_stop_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_grad_stop_t");
    cJSON *field_json = marshal_value(&value->color, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "color");
    if (field_json) {
        cJSON_AddItemToObject(obj, "color", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'color' in struct lv_grad_stop_t\n");
        cJSON_AddNullToObject(obj, "color");
    }
    cJSON *field_json = marshal_value(&value->opa, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "opa");
    if (field_json) {
        cJSON_AddItemToObject(obj, "opa", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'opa' in struct lv_grad_stop_t\n");
        cJSON_AddNullToObject(obj, "opa");
    }
    cJSON *field_json = marshal_value(&value->frac, "uint8_t", "uint8_t", false, false, false, false, false, "frac");
    if (field_json) {
        cJSON_AddItemToObject(obj, "frac", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'frac' in struct lv_grad_stop_t\n");
        cJSON_AddNullToObject(obj, "frac");
    }
    return obj;
}

// Marshal struct struct lv_grad_dsc_t to JSON object
static cJSON* marshal_struct_lv_grad_dsc_t(const struct lv_grad_dsc_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_grad_dsc_t");
    cJSON *field_json = marshal_value(&value->stops, "lv_grad_stop_t[2]", "", false, false, true, false, false, "stops");
    if (field_json) {
        cJSON_AddItemToObject(obj, "stops", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'stops' in struct lv_grad_dsc_t\n");
        cJSON_AddNullToObject(obj, "stops");
    }
    cJSON *field_json = marshal_value(&value->stops_count, "uint8_t", "uint8_t", false, false, false, false, false, "stops_count");
    if (field_json) {
        cJSON_AddItemToObject(obj, "stops_count", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'stops_count' in struct lv_grad_dsc_t\n");
        cJSON_AddNullToObject(obj, "stops_count");
    }
    cJSON *field_json = marshal_value(&value->dir, "lv_grad_dir_t", "lv_grad_dir_t", false, true, false, false, false, "dir");
    if (field_json) {
        cJSON_AddItemToObject(obj, "dir", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'dir' in struct lv_grad_dsc_t\n");
        cJSON_AddNullToObject(obj, "dir");
    }
    cJSON *field_json = marshal_value(&value->extend, "lv_grad_extend_t", "lv_grad_extend_t", false, true, false, false, false, "extend");
    if (field_json) {
        cJSON_AddItemToObject(obj, "extend", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'extend' in struct lv_grad_dsc_t\n");
        cJSON_AddNullToObject(obj, "extend");
    }
    return obj;
}

// Marshal struct struct lv_style_const_prop_t to JSON object
static cJSON* marshal_struct_lv_style_const_prop_t(const struct lv_style_const_prop_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_style_const_prop_t");
    cJSON *field_json = marshal_value(&value->prop, "lv_style_prop_t", "lv_style_prop_t", false, false, false, false, false, "prop");
    if (field_json) {
        cJSON_AddItemToObject(obj, "prop", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'prop' in struct lv_style_const_prop_t\n");
        cJSON_AddNullToObject(obj, "prop");
    }
    cJSON *field_json = marshal_value(&value->value, "union lv_style_value_t", "lv_style_value_t", false, false, false, true, false, "value");
    if (field_json) {
        cJSON_AddItemToObject(obj, "value", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'value' in struct lv_style_const_prop_t\n");
        cJSON_AddNullToObject(obj, "value");
    }
    return obj;
}

// Marshal struct struct lv_event_list_t to JSON object
static cJSON* marshal_struct_lv_event_list_t(const struct lv_event_list_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_event_list_t");
    cJSON *field_json = marshal_value(&value->array, "lv_array_t", "lv_array_t", false, false, false, false, true, "array");
    if (field_json) {
        cJSON_AddItemToObject(obj, "array", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'array' in struct lv_event_list_t\n");
        cJSON_AddNullToObject(obj, "array");
    }
    cJSON *field_json = marshal_value(&value->is_traversing, "uint8_t", "uint8_t", false, false, false, false, false, "is_traversing");
    if (field_json) {
        cJSON_AddItemToObject(obj, "is_traversing", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'is_traversing' in struct lv_event_list_t\n");
        cJSON_AddNullToObject(obj, "is_traversing");
    }
    cJSON *field_json = marshal_value(&value->has_marked_deleting, "uint8_t", "uint8_t", false, false, false, false, false, "has_marked_deleting");
    if (field_json) {
        cJSON_AddItemToObject(obj, "has_marked_deleting", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'has_marked_deleting' in struct lv_event_list_t\n");
        cJSON_AddNullToObject(obj, "has_marked_deleting");
    }
    return obj;
}

// Marshal struct struct lv_indev_data_t to JSON object
static cJSON* marshal_struct_lv_indev_data_t(const struct lv_indev_data_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_indev_data_t");
    cJSON *field_json = marshal_value(&value->point, "struct lv_point_t", "lv_point_t", false, false, true, false, false, "point");
    if (field_json) {
        cJSON_AddItemToObject(obj, "point", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'point' in struct lv_indev_data_t\n");
        cJSON_AddNullToObject(obj, "point");
    }
    cJSON *field_json = marshal_value(&value->key, "uint32_t", "uint32_t", false, false, false, false, false, "key");
    if (field_json) {
        cJSON_AddItemToObject(obj, "key", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'key' in struct lv_indev_data_t\n");
        cJSON_AddNullToObject(obj, "key");
    }
    cJSON *field_json = marshal_value(&value->btn_id, "uint32_t", "uint32_t", false, false, false, false, false, "btn_id");
    if (field_json) {
        cJSON_AddItemToObject(obj, "btn_id", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'btn_id' in struct lv_indev_data_t\n");
        cJSON_AddNullToObject(obj, "btn_id");
    }
    cJSON *field_json = marshal_value(&value->enc_diff, "int16_t", "int16_t", false, false, false, false, false, "enc_diff");
    if (field_json) {
        cJSON_AddItemToObject(obj, "enc_diff", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'enc_diff' in struct lv_indev_data_t\n");
        cJSON_AddNullToObject(obj, "enc_diff");
    }
    cJSON *field_json = marshal_value(&value->state, "lv_indev_state_t", "lv_indev_state_t", false, true, false, false, false, "state");
    if (field_json) {
        cJSON_AddItemToObject(obj, "state", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'state' in struct lv_indev_data_t\n");
        cJSON_AddNullToObject(obj, "state");
    }
    cJSON *field_json = marshal_value(&value->continue_reading, "bool", "bool", false, false, false, false, false, "continue_reading");
    if (field_json) {
        cJSON_AddItemToObject(obj, "continue_reading", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'continue_reading' in struct lv_indev_data_t\n");
        cJSON_AddNullToObject(obj, "continue_reading");
    }
    cJSON *field_json = marshal_value(&value->gesture_type, "lv_indev_gesture_type_t[LV_INDEV_GESTURE_CNT]", "", false, true, false, false, false, "gesture_type");
    if (field_json) {
        cJSON_AddItemToObject(obj, "gesture_type", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'gesture_type' in struct lv_indev_data_t\n");
        cJSON_AddNullToObject(obj, "gesture_type");
    }
    cJSON *field_json = marshal_value(&value->gesture_data, "void*[LV_INDEV_GESTURE_CNT]", "void", false, false, false, false, false, "gesture_data");
    if (field_json) {
        cJSON_AddItemToObject(obj, "gesture_data", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'gesture_data' in struct lv_indev_data_t\n");
        cJSON_AddNullToObject(obj, "gesture_data");
    }
    return obj;
}

// Marshal struct struct lv_binfont_font_src_t to JSON object
static cJSON* marshal_struct_lv_binfont_font_src_t(const struct lv_binfont_font_src_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_binfont_font_src_t");
    cJSON *field_json = marshal_value(&value->font_size, "uint32_t", "uint32_t", false, false, false, false, false, "font_size");
    if (field_json) {
        cJSON_AddItemToObject(obj, "font_size", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'font_size' in struct lv_binfont_font_src_t\n");
        cJSON_AddNullToObject(obj, "font_size");
    }
    cJSON *field_json = marshal_value(&value->path, "char*", "char", true, false, false, false, false, "path");
    if (field_json) {
        cJSON_AddItemToObject(obj, "path", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'path' in struct lv_binfont_font_src_t\n");
        cJSON_AddNullToObject(obj, "path");
    }
    cJSON *field_json = marshal_value(&value->buffer, "void*", "void", true, false, false, false, false, "buffer");
    if (field_json) {
        cJSON_AddItemToObject(obj, "buffer", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'buffer' in struct lv_binfont_font_src_t\n");
        cJSON_AddNullToObject(obj, "buffer");
    }
    cJSON *field_json = marshal_value(&value->buffer_size, "uint32_t", "uint32_t", false, false, false, false, false, "buffer_size");
    if (field_json) {
        cJSON_AddItemToObject(obj, "buffer_size", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'buffer_size' in struct lv_binfont_font_src_t\n");
        cJSON_AddNullToObject(obj, "buffer_size");
    }
    return obj;
}

// Marshal struct struct lv_builtin_font_src_t to JSON object
static cJSON* marshal_struct_lv_builtin_font_src_t(const struct lv_builtin_font_src_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_builtin_font_src_t");
    cJSON *field_json = marshal_value(&value->font_p, "lv_font_t*", "lv_font_t", true, false, false, false, true, "font_p");
    if (field_json) {
        cJSON_AddItemToObject(obj, "font_p", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'font_p' in struct lv_builtin_font_src_t\n");
        cJSON_AddNullToObject(obj, "font_p");
    }
    cJSON *field_json = marshal_value(&value->size, "uint32_t", "uint32_t", false, false, false, false, false, "size");
    if (field_json) {
        cJSON_AddItemToObject(obj, "size", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'size' in struct lv_builtin_font_src_t\n");
        cJSON_AddNullToObject(obj, "size");
    }
    return obj;
}

// Marshal struct struct lv_calendar_date_t to JSON object
static cJSON* marshal_struct_lv_calendar_date_t(const struct lv_calendar_date_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_calendar_date_t");
    cJSON *field_json = marshal_value(&value->year, "uint16_t", "uint16_t", false, false, false, false, false, "year");
    if (field_json) {
        cJSON_AddItemToObject(obj, "year", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'year' in struct lv_calendar_date_t\n");
        cJSON_AddNullToObject(obj, "year");
    }
    cJSON *field_json = marshal_value(&value->month, "int8_t", "int8_t", false, false, false, false, false, "month");
    if (field_json) {
        cJSON_AddItemToObject(obj, "month", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'month' in struct lv_calendar_date_t\n");
        cJSON_AddNullToObject(obj, "month");
    }
    cJSON *field_json = marshal_value(&value->day, "int8_t", "int8_t", false, false, false, false, false, "day");
    if (field_json) {
        cJSON_AddItemToObject(obj, "day", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'day' in struct lv_calendar_date_t\n");
        cJSON_AddNullToObject(obj, "day");
    }
    return obj;
}

// Marshal struct struct lv_span_coords_t to JSON object
static cJSON* marshal_struct_lv_span_coords_t(const struct lv_span_coords_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_span_coords_t");
    cJSON *field_json = marshal_value(&value->heading, "struct lv_area_t", "lv_area_t", false, false, true, false, false, "heading");
    if (field_json) {
        cJSON_AddItemToObject(obj, "heading", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'heading' in struct lv_span_coords_t\n");
        cJSON_AddNullToObject(obj, "heading");
    }
    cJSON *field_json = marshal_value(&value->middle, "struct lv_area_t", "lv_area_t", false, false, true, false, false, "middle");
    if (field_json) {
        cJSON_AddItemToObject(obj, "middle", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'middle' in struct lv_span_coords_t\n");
        cJSON_AddNullToObject(obj, "middle");
    }
    cJSON *field_json = marshal_value(&value->trailing, "struct lv_area_t", "lv_area_t", false, false, true, false, false, "trailing");
    if (field_json) {
        cJSON_AddItemToObject(obj, "trailing", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'trailing' in struct lv_span_coords_t\n");
        cJSON_AddNullToObject(obj, "trailing");
    }
    return obj;
}

// Marshal struct struct lv_tiny_ttf_font_src_t to JSON object
static cJSON* marshal_struct_lv_tiny_ttf_font_src_t(const struct lv_tiny_ttf_font_src_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL; // Allocation check
    cJSON_AddStringToObject(obj, "_struct_type", "lv_tiny_ttf_font_src_t");
    cJSON *field_json = marshal_value(&value->path, "char*", "char", true, false, false, false, false, "path");
    if (field_json) {
        cJSON_AddItemToObject(obj, "path", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'path' in struct lv_tiny_ttf_font_src_t\n");
        cJSON_AddNullToObject(obj, "path");
    }
    cJSON *field_json = marshal_value(&value->data, "void*", "void", true, false, false, false, false, "data");
    if (field_json) {
        cJSON_AddItemToObject(obj, "data", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'data' in struct lv_tiny_ttf_font_src_t\n");
        cJSON_AddNullToObject(obj, "data");
    }
    cJSON *field_json = marshal_value(&value->data_size, "size_t", "size_t", false, false, false, false, false, "data_size");
    if (field_json) {
        cJSON_AddItemToObject(obj, "data_size", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'data_size' in struct lv_tiny_ttf_font_src_t\n");
        cJSON_AddNullToObject(obj, "data_size");
    }
    cJSON *field_json = marshal_value(&value->cache_size, "size_t", "size_t", false, false, false, false, false, "cache_size");
    if (field_json) {
        cJSON_AddItemToObject(obj, "cache_size", field_json);
    } else {
        fprintf(stderr, "Warning: Failed to marshal field 'cache_size' in struct lv_tiny_ttf_font_src_t\n");
        cJSON_AddNullToObject(obj, "cache_size");
    }
    return obj;
}

// Marshal union union lv_style_value_t to JSON object (simplified)
static cJSON* marshal_union_lv_style_value_t(const union lv_style_value_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL;
    cJSON_AddStringToObject(obj, "_union_type", "lv_style_value_t");
    cJSON_AddStringToObject(obj, "_value", "<union_data_omitted>");
    return obj;
}

// Marshal union union lv_subject_value_t to JSON object (simplified)
static cJSON* marshal_union_lv_subject_value_t(const union lv_subject_value_t* value) {
    if (!value) return cJSON_CreateNull();
    cJSON *obj = cJSON_CreateObject();
    if (!obj) return NULL;
    cJSON_AddStringToObject(obj, "_union_type", "lv_subject_value_t");
    cJSON_AddStringToObject(obj, "_value", "<union_data_omitted>");
    return obj;
}


// Generic value marshaler - determines type and calls specific marshalers
static cJSON* marshal_value(const void* value_ptr, const char* c_type_str, const char* base_type_name, bool is_pointer, bool is_enum, bool is_struct, bool is_union, bool is_opaque, const char* arg_name) {
    // Handle NULL pointers early (common case)
    if (is_pointer && (*(const void**)value_ptr) == NULL) {
         return cJSON_CreateNull();
    }
    if (strcmp(c_type_str, "...") == 0) return cJSON_CreateString("<varargs>");
    if (is_opaque && is_pointer) {
        const void* actual_ptr = *(const void**)value_ptr; // Get the actual pointer value
        const char *id = find_id_by_ptr(actual_ptr);
        if (id) {
            return cJSON_CreateString(id); // Found in registry, marshal as ID string
        } else {
           // Handle case where pointer is not NULL but not registered
           // This might be an external resource not registered via emul_lvgl_register_external_ptr
           // Or an internal LVGL pointer we don't track.
           char ptr_buf[40];
           snprintf(ptr_buf, sizeof(ptr_buf), "<unregistered_opaque:%s:%p>", base_type_name ? base_type_name : "?", actual_ptr);
           fprintf(stderr, "Warning: Opaque pointer %p ('%s', type %s) not found in registry for marshaling.\n", actual_ptr, arg_name ? arg_name : "?", base_type_name ? base_type_name : "?");
           return cJSON_CreateString(ptr_buf);
        }
    }
    if (is_enum && !is_pointer) {
        if (strcmp(c_type_str, "lv_result_t") == 0) {
            return marshal_enum_lv_result_t(*(lv_result_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_rb_color_t") == 0) {
            return marshal_enum_lv_rb_color_t(*(lv_rb_color_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_align_t") == 0) {
            return marshal_enum_lv_align_t(*(lv_align_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_dir_t") == 0) {
            return marshal_enum_lv_dir_t(*(lv_dir_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_opa_enum_t") == 0) {
            return marshal_enum_lv_opa_enum_t(*(lv_opa_enum_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_color_format_t") == 0) {
            return marshal_enum_lv_color_format_t(*(lv_color_format_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_palette_t") == 0) {
            return marshal_enum_lv_palette_t(*(lv_palette_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_image_compress_t") == 0) {
            return marshal_enum_lv_image_compress_t(*(lv_image_compress_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_font_glyph_format_t") == 0) {
            return marshal_enum_lv_font_glyph_format_t(*(lv_font_glyph_format_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_font_subpx_t") == 0) {
            return marshal_enum_lv_font_subpx_t(*(lv_font_subpx_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_font_kerning_t") == 0) {
            return marshal_enum_lv_font_kerning_t(*(lv_font_kerning_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_text_flag_t") == 0) {
            return marshal_enum_lv_text_flag_t(*(lv_text_flag_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_text_align_t") == 0) {
            return marshal_enum_lv_text_align_t(*(lv_text_align_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_text_cmd_state_t") == 0) {
            return marshal_enum_lv_text_cmd_state_t(*(lv_text_cmd_state_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_base_dir_t") == 0) {
            return marshal_enum_lv_base_dir_t(*(lv_base_dir_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_grad_dir_t") == 0) {
            return marshal_enum_lv_grad_dir_t(*(lv_grad_dir_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_grad_extend_t") == 0) {
            return marshal_enum_lv_grad_extend_t(*(lv_grad_extend_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_layout_t") == 0) {
            return marshal_enum_lv_layout_t(*(lv_layout_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_flex_align_t") == 0) {
            return marshal_enum_lv_flex_align_t(*(lv_flex_align_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_flex_flow_t") == 0) {
            return marshal_enum_lv_flex_flow_t(*(lv_flex_flow_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_grid_align_t") == 0) {
            return marshal_enum_lv_grid_align_t(*(lv_grid_align_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_blend_mode_t") == 0) {
            return marshal_enum_lv_blend_mode_t(*(lv_blend_mode_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_text_decor_t") == 0) {
            return marshal_enum_lv_text_decor_t(*(lv_text_decor_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_border_side_t") == 0) {
            return marshal_enum_lv_border_side_t(*(lv_border_side_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_style_res_t") == 0) {
            return marshal_enum_lv_style_res_t(*(lv_style_res_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_event_code_t") == 0) {
            return marshal_enum_lv_event_code_t(*(lv_event_code_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_display_rotation_t") == 0) {
            return marshal_enum_lv_display_rotation_t(*(lv_display_rotation_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_display_render_mode_t") == 0) {
            return marshal_enum_lv_display_render_mode_t(*(lv_display_render_mode_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_screen_load_anim_t") == 0) {
            return marshal_enum_lv_screen_load_anim_t(*(lv_screen_load_anim_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_obj_tree_walk_res_t") == 0) {
            return marshal_enum_lv_obj_tree_walk_res_t(*(lv_obj_tree_walk_res_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_obj_point_transform_flag_t") == 0) {
            return marshal_enum_lv_obj_point_transform_flag_t(*(lv_obj_point_transform_flag_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_scrollbar_mode_t") == 0) {
            return marshal_enum_lv_scrollbar_mode_t(*(lv_scrollbar_mode_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_scroll_snap_t") == 0) {
            return marshal_enum_lv_scroll_snap_t(*(lv_scroll_snap_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_style_state_cmp_t") == 0) {
            return marshal_enum_lv_style_state_cmp_t(*(lv_style_state_cmp_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_fs_res_t") == 0) {
            return marshal_enum_lv_fs_res_t(*(lv_fs_res_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_fs_mode_t") == 0) {
            return marshal_enum_lv_fs_mode_t(*(lv_fs_mode_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_fs_whence_t") == 0) {
            return marshal_enum_lv_fs_whence_t(*(lv_fs_whence_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_image_src_t") == 0) {
            return marshal_enum_lv_image_src_t(*(lv_image_src_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_draw_task_type_t") == 0) {
            return marshal_enum_lv_draw_task_type_t(*(lv_draw_task_type_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_draw_task_state_t") == 0) {
            return marshal_enum_lv_draw_task_state_t(*(lv_draw_task_state_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_layer_type_t") == 0) {
            return marshal_enum_lv_layer_type_t(*(lv_layer_type_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_obj_class_editable_t") == 0) {
            return marshal_enum_lv_obj_class_editable_t(*(lv_obj_class_editable_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_obj_class_group_def_t") == 0) {
            return marshal_enum_lv_obj_class_group_def_t(*(lv_obj_class_group_def_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_obj_class_theme_inheritable_t") == 0) {
            return marshal_enum_lv_obj_class_theme_inheritable_t(*(lv_obj_class_theme_inheritable_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_key_t") == 0) {
            return marshal_enum_lv_key_t(*(lv_key_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_group_refocus_policy_t") == 0) {
            return marshal_enum_lv_group_refocus_policy_t(*(lv_group_refocus_policy_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_indev_type_t") == 0) {
            return marshal_enum_lv_indev_type_t(*(lv_indev_type_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_indev_state_t") == 0) {
            return marshal_enum_lv_indev_state_t(*(lv_indev_state_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_indev_mode_t") == 0) {
            return marshal_enum_lv_indev_mode_t(*(lv_indev_mode_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_indev_gesture_type_t") == 0) {
            return marshal_enum_lv_indev_gesture_type_t(*(lv_indev_gesture_type_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_cover_res_t") == 0) {
            return marshal_enum_lv_cover_res_t(*(lv_cover_res_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_state_enum_t") == 0) {
            return marshal_enum_lv_state_enum_t(*(lv_state_enum_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_style_parts_t") == 0) {
            return marshal_enum_lv_style_parts_t(*(lv_style_parts_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_obj_flag_t") == 0) {
            return marshal_enum_lv_obj_flag_t(*(lv_obj_flag_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_font_fmt_txt_cmap_type_t") == 0) {
            return marshal_enum_lv_font_fmt_txt_cmap_type_t(*(lv_font_fmt_txt_cmap_type_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_font_fmt_txt_bitmap_format_t") == 0) {
            return marshal_enum_lv_font_fmt_txt_bitmap_format_t(*(lv_font_fmt_txt_bitmap_format_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_image_align_t") == 0) {
            return marshal_enum_lv_image_align_t(*(lv_image_align_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_animimg_part_t") == 0) {
            return marshal_enum_lv_animimg_part_t(*(lv_animimg_part_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_arc_mode_t") == 0) {
            return marshal_enum_lv_arc_mode_t(*(lv_arc_mode_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_label_long_mode_t") == 0) {
            return marshal_enum_lv_label_long_mode_t(*(lv_label_long_mode_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_bar_mode_t") == 0) {
            return marshal_enum_lv_bar_mode_t(*(lv_bar_mode_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_bar_orientation_t") == 0) {
            return marshal_enum_lv_bar_orientation_t(*(lv_bar_orientation_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_buttonmatrix_ctrl_t") == 0) {
            return marshal_enum_lv_buttonmatrix_ctrl_t(*(lv_buttonmatrix_ctrl_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_chart_type_t") == 0) {
            return marshal_enum_lv_chart_type_t(*(lv_chart_type_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_chart_update_mode_t") == 0) {
            return marshal_enum_lv_chart_update_mode_t(*(lv_chart_update_mode_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_chart_axis_t") == 0) {
            return marshal_enum_lv_chart_axis_t(*(lv_chart_axis_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_imagebutton_state_t") == 0) {
            return marshal_enum_lv_imagebutton_state_t(*(lv_imagebutton_state_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_keyboard_mode_t") == 0) {
            return marshal_enum_lv_keyboard_mode_t(*(lv_keyboard_mode_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_menu_mode_header_t") == 0) {
            return marshal_enum_lv_menu_mode_header_t(*(lv_menu_mode_header_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_menu_mode_root_back_button_t") == 0) {
            return marshal_enum_lv_menu_mode_root_back_button_t(*(lv_menu_mode_root_back_button_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_roller_mode_t") == 0) {
            return marshal_enum_lv_roller_mode_t(*(lv_roller_mode_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_scale_mode_t") == 0) {
            return marshal_enum_lv_scale_mode_t(*(lv_scale_mode_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_slider_mode_t") == 0) {
            return marshal_enum_lv_slider_mode_t(*(lv_slider_mode_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_slider_orientation_t") == 0) {
            return marshal_enum_lv_slider_orientation_t(*(lv_slider_orientation_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_span_overflow_t") == 0) {
            return marshal_enum_lv_span_overflow_t(*(lv_span_overflow_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_span_mode_t") == 0) {
            return marshal_enum_lv_span_mode_t(*(lv_span_mode_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_switch_orientation_t") == 0) {
            return marshal_enum_lv_switch_orientation_t(*(lv_switch_orientation_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_table_cell_ctrl_t") == 0) {
            return marshal_enum_lv_table_cell_ctrl_t(*(lv_table_cell_ctrl_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_subject_type_t") == 0) {
            return marshal_enum_lv_subject_type_t(*(lv_subject_type_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_gridnav_ctrl_t") == 0) {
            return marshal_enum_lv_gridnav_ctrl_t(*(lv_gridnav_ctrl_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_freetype_font_style_t") == 0) {
            return marshal_enum_lv_freetype_font_style_t(*(lv_freetype_font_style_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_freetype_font_render_mode_t") == 0) {
            return marshal_enum_lv_freetype_font_render_mode_t(*(lv_freetype_font_render_mode_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_freetype_outline_type_t") == 0) {
            return marshal_enum_lv_freetype_outline_type_t(*(lv_freetype_outline_type_t*)value_ptr);
        }
        // Fallback for enum type string not matching generated functions
        return cJSON_CreateNumber((double)(*(int*)value_ptr)); // Assume underlying int
    }
    if (is_struct && is_pointer && !is_opaque) {
        if (strcmp(base_type_name, "lv_mem_monitor_t") == 0 || strcmp(c_type_str, "lv_mem_monitor_t*") == 0 || strcmp(c_type_str, "const lv_mem_monitor_t*") == 0 || strcmp(c_type_str, "struct lv_mem_monitor_t*") == 0 || strcmp(c_type_str, "const struct lv_mem_monitor_t*") == 0) {
            return marshal_struct_lv_mem_monitor_t(*(const struct lv_mem_monitor_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_sqrt_res_t") == 0 || strcmp(c_type_str, "lv_sqrt_res_t*") == 0 || strcmp(c_type_str, "const lv_sqrt_res_t*") == 0 || strcmp(c_type_str, "struct lv_sqrt_res_t*") == 0 || strcmp(c_type_str, "const struct lv_sqrt_res_t*") == 0) {
            return marshal_struct_lv_sqrt_res_t(*(const struct lv_sqrt_res_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_anim_bezier3_para_t") == 0 || strcmp(c_type_str, "lv_anim_bezier3_para_t*") == 0 || strcmp(c_type_str, "const lv_anim_bezier3_para_t*") == 0 || strcmp(c_type_str, "struct lv_anim_bezier3_para_t*") == 0 || strcmp(c_type_str, "const struct lv_anim_bezier3_para_t*") == 0) {
            return marshal_struct_lv_anim_bezier3_para_t(*(const struct lv_anim_bezier3_para_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_point_t") == 0 || strcmp(c_type_str, "lv_point_t*") == 0 || strcmp(c_type_str, "const lv_point_t*") == 0 || strcmp(c_type_str, "struct lv_point_t*") == 0 || strcmp(c_type_str, "const struct lv_point_t*") == 0) {
            return marshal_struct_lv_point_t(*(const struct lv_point_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_area_t") == 0 || strcmp(c_type_str, "lv_area_t*") == 0 || strcmp(c_type_str, "const lv_area_t*") == 0 || strcmp(c_type_str, "struct lv_area_t*") == 0 || strcmp(c_type_str, "const struct lv_area_t*") == 0) {
            return marshal_struct_lv_area_t(*(const struct lv_area_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_color_t") == 0 || strcmp(c_type_str, "lv_color_t*") == 0 || strcmp(c_type_str, "const lv_color_t*") == 0 || strcmp(c_type_str, "struct lv_color_t*") == 0 || strcmp(c_type_str, "const struct lv_color_t*") == 0) {
            return marshal_struct_lv_color_t(*(const struct lv_color_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_color16_t") == 0 || strcmp(c_type_str, "lv_color16_t*") == 0 || strcmp(c_type_str, "const lv_color16_t*") == 0 || strcmp(c_type_str, "struct lv_color16_t*") == 0 || strcmp(c_type_str, "const struct lv_color16_t*") == 0) {
            return marshal_struct_lv_color16_t(*(const struct lv_color16_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_color32_t") == 0 || strcmp(c_type_str, "lv_color32_t*") == 0 || strcmp(c_type_str, "const lv_color32_t*") == 0 || strcmp(c_type_str, "struct lv_color32_t*") == 0 || strcmp(c_type_str, "const struct lv_color32_t*") == 0) {
            return marshal_struct_lv_color32_t(*(const struct lv_color32_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_color_hsv_t") == 0 || strcmp(c_type_str, "lv_color_hsv_t*") == 0 || strcmp(c_type_str, "const lv_color_hsv_t*") == 0 || strcmp(c_type_str, "struct lv_color_hsv_t*") == 0 || strcmp(c_type_str, "const struct lv_color_hsv_t*") == 0) {
            return marshal_struct_lv_color_hsv_t(*(const struct lv_color_hsv_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_color16a_t") == 0 || strcmp(c_type_str, "lv_color16a_t*") == 0 || strcmp(c_type_str, "const lv_color16a_t*") == 0 || strcmp(c_type_str, "struct lv_color16a_t*") == 0 || strcmp(c_type_str, "const struct lv_color16a_t*") == 0) {
            return marshal_struct_lv_color16a_t(*(const struct lv_color16a_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_image_header_t") == 0 || strcmp(c_type_str, "lv_image_header_t*") == 0 || strcmp(c_type_str, "const lv_image_header_t*") == 0 || strcmp(c_type_str, "struct lv_image_header_t*") == 0 || strcmp(c_type_str, "const struct lv_image_header_t*") == 0) {
            return marshal_struct_lv_image_header_t(*(const struct lv_image_header_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_img_dsc_t") == 0 || strcmp(c_type_str, "lv_img_dsc_t*") == 0 || strcmp(c_type_str, "const lv_img_dsc_t*") == 0 || strcmp(c_type_str, "struct lv_img_dsc_t*") == 0 || strcmp(c_type_str, "const struct lv_img_dsc_t*") == 0) {
            return marshal_struct_lv_img_dsc_t(*(const struct lv_img_dsc_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_grad_stop_t") == 0 || strcmp(c_type_str, "lv_grad_stop_t*") == 0 || strcmp(c_type_str, "const lv_grad_stop_t*") == 0 || strcmp(c_type_str, "struct lv_grad_stop_t*") == 0 || strcmp(c_type_str, "const struct lv_grad_stop_t*") == 0) {
            return marshal_struct_lv_grad_stop_t(*(const struct lv_grad_stop_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_grad_dsc_t") == 0 || strcmp(c_type_str, "lv_grad_dsc_t*") == 0 || strcmp(c_type_str, "const lv_grad_dsc_t*") == 0 || strcmp(c_type_str, "struct lv_grad_dsc_t*") == 0 || strcmp(c_type_str, "const struct lv_grad_dsc_t*") == 0) {
            return marshal_struct_lv_grad_dsc_t(*(const struct lv_grad_dsc_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_style_const_prop_t") == 0 || strcmp(c_type_str, "lv_style_const_prop_t*") == 0 || strcmp(c_type_str, "const lv_style_const_prop_t*") == 0 || strcmp(c_type_str, "struct lv_style_const_prop_t*") == 0 || strcmp(c_type_str, "const struct lv_style_const_prop_t*") == 0) {
            return marshal_struct_lv_style_const_prop_t(*(const struct lv_style_const_prop_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_event_list_t") == 0 || strcmp(c_type_str, "lv_event_list_t*") == 0 || strcmp(c_type_str, "const lv_event_list_t*") == 0 || strcmp(c_type_str, "struct lv_event_list_t*") == 0 || strcmp(c_type_str, "const struct lv_event_list_t*") == 0) {
            return marshal_struct_lv_event_list_t(*(const struct lv_event_list_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_indev_data_t") == 0 || strcmp(c_type_str, "lv_indev_data_t*") == 0 || strcmp(c_type_str, "const lv_indev_data_t*") == 0 || strcmp(c_type_str, "struct lv_indev_data_t*") == 0 || strcmp(c_type_str, "const struct lv_indev_data_t*") == 0) {
            return marshal_struct_lv_indev_data_t(*(const struct lv_indev_data_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_binfont_font_src_t") == 0 || strcmp(c_type_str, "lv_binfont_font_src_t*") == 0 || strcmp(c_type_str, "const lv_binfont_font_src_t*") == 0 || strcmp(c_type_str, "struct lv_binfont_font_src_t*") == 0 || strcmp(c_type_str, "const struct lv_binfont_font_src_t*") == 0) {
            return marshal_struct_lv_binfont_font_src_t(*(const struct lv_binfont_font_src_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_builtin_font_src_t") == 0 || strcmp(c_type_str, "lv_builtin_font_src_t*") == 0 || strcmp(c_type_str, "const lv_builtin_font_src_t*") == 0 || strcmp(c_type_str, "struct lv_builtin_font_src_t*") == 0 || strcmp(c_type_str, "const struct lv_builtin_font_src_t*") == 0) {
            return marshal_struct_lv_builtin_font_src_t(*(const struct lv_builtin_font_src_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_calendar_date_t") == 0 || strcmp(c_type_str, "lv_calendar_date_t*") == 0 || strcmp(c_type_str, "const lv_calendar_date_t*") == 0 || strcmp(c_type_str, "struct lv_calendar_date_t*") == 0 || strcmp(c_type_str, "const struct lv_calendar_date_t*") == 0) {
            return marshal_struct_lv_calendar_date_t(*(const struct lv_calendar_date_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_span_coords_t") == 0 || strcmp(c_type_str, "lv_span_coords_t*") == 0 || strcmp(c_type_str, "const lv_span_coords_t*") == 0 || strcmp(c_type_str, "struct lv_span_coords_t*") == 0 || strcmp(c_type_str, "const struct lv_span_coords_t*") == 0) {
            return marshal_struct_lv_span_coords_t(*(const struct lv_span_coords_t**)value_ptr);
        }
        if (strcmp(base_type_name, "lv_tiny_ttf_font_src_t") == 0 || strcmp(c_type_str, "lv_tiny_ttf_font_src_t*") == 0 || strcmp(c_type_str, "const lv_tiny_ttf_font_src_t*") == 0 || strcmp(c_type_str, "struct lv_tiny_ttf_font_src_t*") == 0 || strcmp(c_type_str, "const struct lv_tiny_ttf_font_src_t*") == 0) {
            return marshal_struct_lv_tiny_ttf_font_src_t(*(const struct lv_tiny_ttf_font_src_t**)value_ptr);
        }
        // Fallback for unknown concrete struct pointer
        char buf_sp[64]; snprintf(buf_sp, sizeof(buf_sp), "<unhandled_struct_ptr:%s>", base_type_name ? base_type_name : c_type_str); return cJSON_CreateString(buf_sp);
    }
    if (is_struct && !is_pointer && !is_opaque) {
        if (strcmp(c_type_str, "lv_color_t") == 0) {
            return marshal_struct_lv_color_t((const lv_color_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_mem_monitor_t") == 0 || strcmp(c_type_str, "const lv_mem_monitor_t") == 0) {
            return marshal_struct_lv_mem_monitor_t((const struct lv_mem_monitor_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_sqrt_res_t") == 0 || strcmp(c_type_str, "const lv_sqrt_res_t") == 0) {
            return marshal_struct_lv_sqrt_res_t((const struct lv_sqrt_res_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_anim_bezier3_para_t") == 0 || strcmp(c_type_str, "const lv_anim_bezier3_para_t") == 0) {
            return marshal_struct_lv_anim_bezier3_para_t((const struct lv_anim_bezier3_para_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_point_t") == 0 || strcmp(c_type_str, "const lv_point_t") == 0) {
            return marshal_struct_lv_point_t((const struct lv_point_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_area_t") == 0 || strcmp(c_type_str, "const lv_area_t") == 0) {
            return marshal_struct_lv_area_t((const struct lv_area_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_color16_t") == 0 || strcmp(c_type_str, "const lv_color16_t") == 0) {
            return marshal_struct_lv_color16_t((const struct lv_color16_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_color32_t") == 0 || strcmp(c_type_str, "const lv_color32_t") == 0) {
            return marshal_struct_lv_color32_t((const struct lv_color32_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_color_hsv_t") == 0 || strcmp(c_type_str, "const lv_color_hsv_t") == 0) {
            return marshal_struct_lv_color_hsv_t((const struct lv_color_hsv_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_color16a_t") == 0 || strcmp(c_type_str, "const lv_color16a_t") == 0) {
            return marshal_struct_lv_color16a_t((const struct lv_color16a_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_image_header_t") == 0 || strcmp(c_type_str, "const lv_image_header_t") == 0) {
            return marshal_struct_lv_image_header_t((const struct lv_image_header_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_img_dsc_t") == 0 || strcmp(c_type_str, "const lv_img_dsc_t") == 0) {
            return marshal_struct_lv_img_dsc_t((const struct lv_img_dsc_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_grad_stop_t") == 0 || strcmp(c_type_str, "const lv_grad_stop_t") == 0) {
            return marshal_struct_lv_grad_stop_t((const struct lv_grad_stop_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_grad_dsc_t") == 0 || strcmp(c_type_str, "const lv_grad_dsc_t") == 0) {
            return marshal_struct_lv_grad_dsc_t((const struct lv_grad_dsc_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_style_const_prop_t") == 0 || strcmp(c_type_str, "const lv_style_const_prop_t") == 0) {
            return marshal_struct_lv_style_const_prop_t((const struct lv_style_const_prop_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_event_list_t") == 0 || strcmp(c_type_str, "const lv_event_list_t") == 0) {
            return marshal_struct_lv_event_list_t((const struct lv_event_list_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_indev_data_t") == 0 || strcmp(c_type_str, "const lv_indev_data_t") == 0) {
            return marshal_struct_lv_indev_data_t((const struct lv_indev_data_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_binfont_font_src_t") == 0 || strcmp(c_type_str, "const lv_binfont_font_src_t") == 0) {
            return marshal_struct_lv_binfont_font_src_t((const struct lv_binfont_font_src_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_builtin_font_src_t") == 0 || strcmp(c_type_str, "const lv_builtin_font_src_t") == 0) {
            return marshal_struct_lv_builtin_font_src_t((const struct lv_builtin_font_src_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_calendar_date_t") == 0 || strcmp(c_type_str, "const lv_calendar_date_t") == 0) {
            return marshal_struct_lv_calendar_date_t((const struct lv_calendar_date_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_span_coords_t") == 0 || strcmp(c_type_str, "const lv_span_coords_t") == 0) {
            return marshal_struct_lv_span_coords_t((const struct lv_span_coords_t*)value_ptr);
        }
        if (strcmp(c_type_str, "lv_tiny_ttf_font_src_t") == 0 || strcmp(c_type_str, "const lv_tiny_ttf_font_src_t") == 0) {
            return marshal_struct_lv_tiny_ttf_font_src_t((const struct lv_tiny_ttf_font_src_t*)value_ptr);
        }
        // Fallback for unknown struct value
        char buf_sv[64]; snprintf(buf_sv, sizeof(buf_sv), "<unhandled_struct_val:%s>", c_type_str); return cJSON_CreateString(buf_sv);
    }
    if (is_union && !is_opaque) {
        if (is_pointer) {
            if (strcmp(base_type_name, "lv_style_value_t") == 0 || strcmp(c_type_str, "lv_style_value_t*") == 0 || strcmp(c_type_str, "const lv_style_value_t*") == 0 || strcmp(c_type_str, "union lv_style_value_t*") == 0 || strcmp(c_type_str, "const union lv_style_value_t*") == 0) {
                return marshal_union_lv_style_value_t(*(const union lv_style_value_t**)value_ptr);
            }
            if (strcmp(base_type_name, "lv_subject_value_t") == 0 || strcmp(c_type_str, "lv_subject_value_t*") == 0 || strcmp(c_type_str, "const lv_subject_value_t*") == 0 || strcmp(c_type_str, "union lv_subject_value_t*") == 0 || strcmp(c_type_str, "const union lv_subject_value_t*") == 0) {
                return marshal_union_lv_subject_value_t(*(const union lv_subject_value_t**)value_ptr);
            }
        } else { // Passed by value
            if (strcmp(c_type_str, "lv_style_value_t") == 0 || strcmp(c_type_str, "const lv_style_value_t") == 0) {
                return marshal_union_lv_style_value_t((const union lv_style_value_t*)value_ptr);
            }
            if (strcmp(c_type_str, "lv_subject_value_t") == 0 || strcmp(c_type_str, "const lv_subject_value_t") == 0) {
                return marshal_union_lv_subject_value_t((const union lv_subject_value_t*)value_ptr);
            }
        }
        // Fallback for unknown union
        char buf_un[64]; snprintf(buf_un, sizeof(buf_un), "<unhandled_union:%s>", c_type_str); return cJSON_CreateString(buf_un);
    }
    // Check specific C standard types passed by value or pointer
    // Note: value_ptr always points to the value, even if passed by value.
    // String (const char* or char*)
    if (strcmp(c_type_str, "const char*") == 0 || strcmp(c_type_str, "char*") == 0) {
        // value_ptr is const void**, dereference to get the char*
        const char* str_val = *(const char**)value_ptr;
        return str_val ? cJSON_CreateString(str_val) : cJSON_CreateNull();
    }
    // Boolean (bool)
    if (strcmp(c_type_str, "bool") == 0) {
        return cJSON_CreateBool(*(bool*)value_ptr);
    }
    // Floating point (float, double)
    if (strcmp(c_type_str, "float") == 0 || strcmp(c_type_str, "double") == 0 || strcmp(c_type_str, "const float") == 0 || strcmp(c_type_str, "const double") == 0) {
        // Promote float to double for cJSON
        if (strstr(c_type_str, "float")) return cJSON_CreateNumber((double)(*(float*)value_ptr));
        else return cJSON_CreateNumber(*(double*)value_ptr);
    }
    // Integer types (char, short, int, long, size_t, stdint types)
    // Use string comparisons based on the C type name
    if (strcmp(c_type_str, "char") == 0 || strcmp(c_type_str, "signed char") == 0 || strcmp(c_type_str, "const char") == 0 || strcmp(c_type_str, "const signed char") == 0) {
        return cJSON_CreateNumber((double)(*(signed char*)value_ptr));
    }
    if (strcmp(c_type_str, "unsigned char") == 0 || strcmp(c_type_str, "uint8_t") == 0 || strcmp(c_type_str, "const unsigned char") == 0 || strcmp(c_type_str, "const uint8_t") == 0 || strcmp(c_type_str, "lv_opa_t") == 0) { // Include lv_opa_t here
        return cJSON_CreateNumber((double)(*(unsigned char*)value_ptr));
    }
    if (strcmp(c_type_str, "short") == 0 || strcmp(c_type_str, "signed short") == 0 || strcmp(c_type_str, "int16_t") == 0 || strcmp(c_type_str, "const short") == 0 || strcmp(c_type_str, "const signed short") == 0 || strcmp(c_type_str, "const int16_t") == 0 || strcmp(c_type_str, "lv_state_t") == 0) { // Include lv_state_t
        return cJSON_CreateNumber((double)(*(short*)value_ptr));
    }
    if (strcmp(c_type_str, "unsigned short") == 0 || strcmp(c_type_str, "uint16_t") == 0 || strcmp(c_type_str, "const unsigned short") == 0 || strcmp(c_type_str, "const uint16_t") == 0) {
        return cJSON_CreateNumber((double)(*(unsigned short*)value_ptr));
    }
    if (strcmp(c_type_str, "int") == 0 || strcmp(c_type_str, "signed int") == 0 || strcmp(c_type_str, "int32_t") == 0 || strcmp(c_type_str, "const int") == 0 || strcmp(c_type_str, "const signed int") == 0 || strcmp(c_type_str, "const int32_t") == 0 || strcmp(c_type_str, "lv_coord_t") == 0 || strcmp(c_type_str, "lv_res_t") == 0) { // Include lv_coord_t, lv_res_t
        return cJSON_CreateNumber((double)(*(int*)value_ptr));
    }
    if (strcmp(c_type_str, "unsigned int") == 0 || strcmp(c_type_str, "uint32_t") == 0 || strcmp(c_type_str, "const unsigned int") == 0 || strcmp(c_type_str, "const uint32_t") == 0 || strcmp(c_type_str, "lv_part_t") == 0 || strcmp(c_type_str, "lv_style_selector_t") == 0) { // Include lv_part_t, lv_style_selector_t
        // Use unsigned long for intermediate to potentially hold uint32_t correctly before double conversion
        return cJSON_CreateNumber((double)(*(unsigned int*)value_ptr));
    }
    if (strcmp(c_type_str, "long") == 0 || strcmp(c_type_str, "signed long") == 0 || strcmp(c_type_str, "intptr_t") == 0 || strcmp(c_type_str, "int64_t") == 0 || strcmp(c_type_str, "const long") == 0 || strcmp(c_type_str, "const signed long") == 0 || strcmp(c_type_str, "const intptr_t") == 0 || strcmp(c_type_str, "const int64_t") == 0) {
        // Use long long for intermediate for portability before double conversion
        return cJSON_CreateNumber((double)(*(long long*)value_ptr));
    }
    if (strcmp(c_type_str, "unsigned long") == 0 || strcmp(c_type_str, "uintptr_t") == 0 || strcmp(c_type_str, "size_t") == 0 || strcmp(c_type_str, "uint64_t") == 0 || strcmp(c_type_str, "const unsigned long") == 0 || strcmp(c_type_str, "const uintptr_t") == 0 || strcmp(c_type_str, "const size_t") == 0 || strcmp(c_type_str, "const uint64_t") == 0) {
        // Use unsigned long long for intermediate for portability before double conversion
        return cJSON_CreateNumber((double)(*(unsigned long long*)value_ptr));
    }
    if (is_pointer && !is_opaque && !is_struct && !is_union) {
        const void* actual_ptr = *(const void**)value_ptr;
        // Handle void* pointers (e.g., user_data) - represent as string address?
        if (base_type_name && strcmp(base_type_name, "void") == 0) {
            char ptr_buf[32]; snprintf(ptr_buf, sizeof(ptr_buf), "<void*:%p>", actual_ptr);
            return cJSON_CreateString(ptr_buf);
        }
        // Handle function pointers - represent as string name?
        // Base type name might be the function pointer typedef name
        bool is_func_ptr = false;
        if (base_type_name) {
             // Check if base_type_name corresponds to a function_pointer definition
             lvgl_registry_entry_t* details_entry = NULL; // Placeholder
             // Quick check on name convention
             if (strstr(base_type_name, "_cb_t") || strstr(base_type_name, "_f_t")) is_func_ptr = true;
             // Add lookup in api_data if needed for more accuracy
             // details = get_type_details({"name": base_type_name}, api_data);
             // if (details && details.get("json_type") == "function_pointer") is_func_ptr = true;
        }
        if (is_func_ptr) {
            char func_buf[64]; snprintf(func_buf, sizeof(func_buf), "<func_ptr:%s:%p>", base_type_name ? base_type_name : "?", actual_ptr);
            return cJSON_CreateString(func_buf);
        }
        // Other pointers (e.g., pointer to primitive, like int*) - Marshal the value pointed to?
        // This requires knowing the pointee type again. Let's try.
        if (base_type_name) {
             // Marshal the value pointed to by actual_ptr, treating it as non-pointer value
             // Need to determine properties of the *pointee* type
             bool pointee_is_enum = false, pointee_is_struct = false, pointee_is_union = false, pointee_is_opaque = false;
             // Lookup details for base_type_name
             // Simplified: Assume primitives/stdlib if not struct/union/enum
             // Let's fallback to representing address for now to avoid complexity.
             char ptr_buf[64]; snprintf(ptr_buf, sizeof(ptr_buf), "<pointer:%s:%p>", base_type_name, actual_ptr);
             return cJSON_CreateString(ptr_buf);
             // Proper implementation would call: return marshal_value(actual_ptr, pointee_c_type_str, base_type_name, false, pointee_is_enum, ...);
        }
         // Fallback if base_type_name is null or pointee handling fails
         char ptr_buf_fallback[64]; snprintf(ptr_buf_fallback, sizeof(ptr_buf_fallback), "<unhandled_pointer:%p>", actual_ptr);
         return cJSON_CreateString(ptr_buf_fallback);
    }
    // Fallback for completely unknown types/combinations
    fprintf(stderr, "Warning: Could not marshal value for C type '%s' (base: %s, ptr:%d, enum:%d, struct:%d, union:%d, opaque:%d, arg: %s)\n",
            c_type_str, base_type_name ? base_type_name : "N/A", is_pointer, is_enum, is_struct, is_union, is_opaque, arg_name ? arg_name : "N/A");
    char unknown_buf[128];
    snprintf(unknown_buf, sizeof(unknown_buf), "<unknown_marshal_type:%s>", c_type_str);
    return cJSON_CreateString(unknown_buf);
}

// --- Initialization and Cleanup ---

// Initializes the wrapper, call once before using any wrapped functions.
void emul_lvgl_init(void) {
    // Check if already initialized
    if (g_root_json_array != NULL) {
        // fprintf(stderr, "Warning: emul_lvgl_init called multiple times. Resetting state.\n");
        emul_lvgl_destroy(); // Clean up previous state first
    }

    // Create the root JSON array to hold all objects
    g_root_json_array = cJSON_CreateArray();
    if (!g_root_json_array) {
        fprintf(stderr, "Fatal Error: Failed to create root cJSON array.\n");
        assert(false); // Cannot proceed
        return;
    }

    // Reset ID generation state
    memset(g_id_counters, 0, sizeof(g_id_counters));
    // Free any existing type name strings from previous runs
    for(int i = 0; i < g_id_type_count; ++i) {
        free((void*)g_id_type_names[i]);
        g_id_type_names[i] = NULL;
    }
    g_id_type_count = 0;

    // Reset object registry (should be empty after destroy, but double check)
    assert(g_object_registry == NULL);
    g_object_registry = NULL; // Ensure it's NULL

    // printf("LVGL JSON Wrapper Initialized.\n");
}

// Cleans up resources used by the wrapper.
void emul_lvgl_destroy(void) {
    // Delete the main JSON structure (owns all created object JSONs)
    if (g_root_json_array) {
        cJSON_Delete(g_root_json_array);
        g_root_json_array = NULL;
    }

    // Clear the hash table and free associated memory owned by the registry
    lvgl_registry_entry_t *current_entry, *tmp;
    HASH_ITER(hh, g_object_registry, current_entry, tmp) {
        HASH_DEL(g_object_registry, current_entry); // Remove from hash table
        free((void*)current_entry->id); // Free the ID string
        free((void*)current_entry->type_name); // Free the type name string
        // NOTE: current_entry->json_obj is owned by g_root_json_array, which was deleted above.
        free(current_entry); // Free the registry entry struct itself
    }
    g_object_registry = NULL; // Ensure head is NULL

    // Free type name strings used for ID generation
    for(int i = 0; i < g_id_type_count; ++i) {
        free((void*)g_id_type_names[i]);
        g_id_type_names[i] = NULL;
    }
    g_id_type_count = 0;
    memset(g_id_counters, 0, sizeof(g_id_counters));

    // printf("LVGL JSON Wrapper Destroyed.\n");
}

// Exports the current UI state to a JSON file.
bool emul_lvgl_export(const char *filename, bool pretty) {
    if (!g_root_json_array) {
        fprintf(stderr, "Error: emul_lvgl_init() not called or no objects created before export.\n");
        return false;
    }

    // Create the final output structure { "lvgl_simulation": [...] }
    cJSON *output_root = cJSON_CreateObject();
    if (!output_root) {
        fprintf(stderr, "Error: Failed to create output root cJSON object.\n");
        return false;
    }

    // Add the array of objects to the root object.
    // We add the actual array; its ownership is temporarily transferred.
    cJSON_AddItemToObject(output_root, "lvgl_simulation", g_root_json_array);

    // Print the JSON object to a string
    char *json_string = NULL;
    if (pretty) {
        json_string = cJSON_Print(output_root); // Use pretty print
    } else {
        json_string = cJSON_PrintUnformatted(output_root); // Use compact print
    }

    // Detach the array from the output root *before* checking json_string
    // so that g_root_json_array is not deleted if cJSON_Delete(output_root) is called on error.
    cJSON_DetachItemViaPointer(output_root, g_root_json_array);

    if (!json_string) {
        fprintf(stderr, "Error: Failed to print JSON to string (memory allocation failed?).\n");
        cJSON_Delete(output_root); // Delete the container object
        return false;
    }

    // Write the string to the specified file
    FILE *fp = fopen(filename, "w");
    if (!fp) {
        perror("Error opening output file for writing");
        fprintf(stderr, "    Filename: %s\n", filename);
        free(json_string);
        cJSON_Delete(output_root);
        return false;
    }

    // Write the JSON string and close the file
    size_t write_len = strlen(json_string);
    if (fwrite(json_string, 1, write_len, fp) != write_len) {
        perror("Error writing JSON string to file");
        fclose(fp);
        free(json_string);
        cJSON_Delete(output_root);
        // Attempt to remove potentially corrupted file
        remove(filename);
        return false;
    }

    fclose(fp);
    printf("LVGL JSON wrapper: Exported UI state to %s\n", filename);

    // Clean up
    free(json_string);
    cJSON_Delete(output_root); // Delete the container object

    return true;
}

// Registers an external pointer (e.g., font, image src) with a specific ID.
void emul_lvgl_register_external_ptr(const void *ptr, const char *id, const char* type_hint) {
    // Basic validation
    if (!ptr || !id || !type_hint) {
        fprintf(stderr, "Error: Invalid NULL arguments provided to emul_lvgl_register_external_ptr (ptr=%p, id=%s, type_hint=%s).\n", ptr, id ? id : "NULL", type_hint ? type_hint : "NULL");
        assert(false); // Indicate programming error
        return;
    }
    if (strlen(id) == 0) {
        fprintf(stderr, "Error: Empty string provided for ID in emul_lvgl_register_external_ptr.\n");
        assert(false);
        return;
    }

    // Ensure the system is initialized
    if (!g_root_json_array) {
         fprintf(stderr, "Warning: emul_lvgl_init() was not called before emul_lvgl_register_external_ptr. Initializing now.\n");
         emul_lvgl_init();
    }

    // Check if the pointer OR the ID is already registered
    lvgl_registry_entry_t *entry_by_ptr = NULL, *entry_by_id = NULL, *tmp = NULL;
    HASH_FIND_PTR(g_object_registry, &ptr, entry_by_ptr);
    // Need to iterate to check for ID collision
    HASH_ITER(hh, g_object_registry, tmp, entry_by_id) {
        if (strcmp(tmp->id, id) == 0) {
            entry_by_id = tmp; // Found entry with the same ID
            break;
        }
    }

    if (entry_by_ptr != NULL) {
        // Pointer is already registered. Check if ID matches.
        if (strcmp(entry_by_ptr->id, id) == 0) {
            // Already registered with the same ID, nothing to do.
            // fprintf(stderr, "Debug: Pointer %p already registered as '%s'. Skipping duplicate registration.\n", ptr, id);
            return;
        } else {
            // Pointer registered with a DIFFERENT ID. This indicates a problem.
            fprintf(stderr, "Error: Pointer %p already registered with ID '%s', cannot re-register with ID '%s'.\n", ptr, entry_by_ptr->id, id);
            assert(false); // Indicate programming error
            return;
        }
    }

    if (entry_by_id != NULL) {
        // ID is already registered, but the pointer was not found. This is an ID collision.
        fprintf(stderr, "Error: ID '%s' is already registered for pointer %p. Cannot register pointer %p with the same ID.\n", id, entry_by_id->ptr_key, ptr);
        assert(false); // Indicate programming error
        return;
    }

    // Create a placeholder JSON object for this external resource
    cJSON *ext_obj = cJSON_CreateObject();
    if (!ext_obj) {
        perror("Failed to create cJSON object for external pointer registration");
        assert(false); return; // Critical error
    }
    // Use copies of id and type_hint for safety
    char* id_copy = strdup(id);
    if (!id_copy) { perror("strdup failed for id"); cJSON_Delete(ext_obj); assert(false); return; }

    cJSON_AddStringToObject(ext_obj, "id", id_copy); // Add the copy
    cJSON_AddStringToObject(ext_obj, "type", type_hint);
    cJSON_AddStringToObject(ext_obj, "source", "external");

    // Add to the global array (g_root_json_array owns ext_obj now)
    cJSON_AddItemToArray(g_root_json_array, ext_obj);

    // Register the pointer -> ID mapping (Registry takes ownership of id_copy)
    // Note: We pass ext_obj here, but it's just metadata; the pointer itself isn't a cJSON object.
    register_opaque_object(ptr, type_hint, id_copy, ext_obj); // Pass id_copy
}

// --- Wrapped LVGL Function Implementations ---

// Wrapper for: lv_anim_count_running
uint16_t lv_anim_count_running(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_count_running' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint16_t */
    return 0;
}

// Wrapper for: lv_anim_delete_all
void lv_anim_delete_all(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_delete_all' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_anim_get_delay
uint32_t lv_anim_get_delay(lv_anim_t* a) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_get_delay' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_anim_get_repeat_count
uint32_t lv_anim_get_repeat_count(lv_anim_t* a) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_get_repeat_count' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_anim_get_time
uint32_t lv_anim_get_time(lv_anim_t* a) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_get_time' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_anim_get_user_data
void* lv_anim_get_user_data(lv_anim_t* a) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_get_user_data' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_anim_init
void lv_anim_init(lv_anim_t* a) {
    /* Wrapper Type: init */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in init"); assert(false); /* Cannot return if void */ return; }
    const char* type_name = "lv_anim_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "initializer_func", "lv_anim_init");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *init_args_array = cJSON_CreateArray();
    if (!init_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "init_args", init_args_array);
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)a, type_name, obj_id, new_obj_json);
}

// Wrapper for: lv_anim_is_paused
bool lv_anim_is_paused(lv_anim_t* a) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_is_paused' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_anim_pause
void lv_anim_pause(lv_anim_t* a) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_pause' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_anim_pause_for
void lv_anim_pause_for(lv_anim_t* a, uint32_t ms) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_pause_for' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_anim_refr_now
void lv_anim_refr_now(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_refr_now' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_anim_resolve_speed
uint32_t lv_anim_resolve_speed(uint32_t speed, int32_t start, int32_t end) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_resolve_speed' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_anim_resume
void lv_anim_resume(lv_anim_t* a) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_resume' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_anim_set_bezier3_param
void lv_anim_set_bezier3_param(lv_anim_t* a, int16_t x1, int16_t y1, int16_t x2, int16_t y2) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(a);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_anim_set_bezier3_param' called on unknown or unregistered opaque pointer %p.\n", (void*)a);
        // Check if it's maybe NULL
        if (a == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_anim_set_bezier3_param (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_bezier3_param");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&x1, "int16_t", "int16_t", false, false, false, false, false, "x1");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&y1, "int16_t", "int16_t", false, false, false, false, false, "y1");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&x2, "int16_t", "int16_t", false, false, false, false, false, "x2");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_3 = marshal_value(&y2, "int16_t", "int16_t", false, false, false, false, false, "y2");
        if (val_3) cJSON_AddItemToArray(values_array, val_3); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_anim_set_delay
void lv_anim_set_delay(lv_anim_t* a, uint32_t delay) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(a);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_anim_set_delay' called on unknown or unregistered opaque pointer %p.\n", (void*)a);
        // Check if it's maybe NULL
        if (a == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_anim_set_delay (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_delay");
    cJSON *value_json = marshal_value(&delay, "uint32_t", "uint32_t", false, false, false, false, false, "delay");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_anim_set_duration
void lv_anim_set_duration(lv_anim_t* a, uint32_t duration) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(a);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_anim_set_duration' called on unknown or unregistered opaque pointer %p.\n", (void*)a);
        // Check if it's maybe NULL
        if (a == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_anim_set_duration (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_duration");
    cJSON *value_json = marshal_value(&duration, "uint32_t", "uint32_t", false, false, false, false, false, "duration");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_anim_set_early_apply
void lv_anim_set_early_apply(lv_anim_t* a, bool en) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(a);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_anim_set_early_apply' called on unknown or unregistered opaque pointer %p.\n", (void*)a);
        // Check if it's maybe NULL
        if (a == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_anim_set_early_apply (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_early_apply");
    cJSON *value_json = marshal_value(&en, "bool", "bool", false, false, false, false, false, "en");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_anim_set_repeat_count
void lv_anim_set_repeat_count(lv_anim_t* a, uint32_t cnt) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(a);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_anim_set_repeat_count' called on unknown or unregistered opaque pointer %p.\n", (void*)a);
        // Check if it's maybe NULL
        if (a == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_anim_set_repeat_count (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_repeat_count");
    cJSON *value_json = marshal_value(&cnt, "uint32_t", "uint32_t", false, false, false, false, false, "cnt");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_anim_set_repeat_delay
void lv_anim_set_repeat_delay(lv_anim_t* a, uint32_t delay) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(a);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_anim_set_repeat_delay' called on unknown or unregistered opaque pointer %p.\n", (void*)a);
        // Check if it's maybe NULL
        if (a == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_anim_set_repeat_delay (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_repeat_delay");
    cJSON *value_json = marshal_value(&delay, "uint32_t", "uint32_t", false, false, false, false, false, "delay");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_anim_set_reverse_delay
void lv_anim_set_reverse_delay(lv_anim_t* a, uint32_t delay) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(a);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_anim_set_reverse_delay' called on unknown or unregistered opaque pointer %p.\n", (void*)a);
        // Check if it's maybe NULL
        if (a == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_anim_set_reverse_delay (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_reverse_delay");
    cJSON *value_json = marshal_value(&delay, "uint32_t", "uint32_t", false, false, false, false, false, "delay");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_anim_set_reverse_duration
void lv_anim_set_reverse_duration(lv_anim_t* a, uint32_t duration) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(a);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_anim_set_reverse_duration' called on unknown or unregistered opaque pointer %p.\n", (void*)a);
        // Check if it's maybe NULL
        if (a == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_anim_set_reverse_duration (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_reverse_duration");
    cJSON *value_json = marshal_value(&duration, "uint32_t", "uint32_t", false, false, false, false, false, "duration");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_anim_set_reverse_time
void lv_anim_set_reverse_time(lv_anim_t* a, uint32_t duration) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(a);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_anim_set_reverse_time' called on unknown or unregistered opaque pointer %p.\n", (void*)a);
        // Check if it's maybe NULL
        if (a == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_anim_set_reverse_time (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_reverse_time");
    cJSON *value_json = marshal_value(&duration, "uint32_t", "uint32_t", false, false, false, false, false, "duration");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_anim_set_user_data
void lv_anim_set_user_data(lv_anim_t* a, void* user_data) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(a);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_anim_set_user_data' called on unknown or unregistered opaque pointer %p.\n", (void*)a);
        // Check if it's maybe NULL
        if (a == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_anim_set_user_data (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_user_data");
    cJSON *value_json = marshal_value(&user_data, "void*", "void", true, false, false, false, false, "user_data");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_anim_set_values
void lv_anim_set_values(lv_anim_t* a, int32_t start, int32_t end) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(a);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_anim_set_values' called on unknown or unregistered opaque pointer %p.\n", (void*)a);
        // Check if it's maybe NULL
        if (a == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_anim_set_values (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_values");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&start, "int32_t", "int32_t", false, false, false, false, false, "start");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&end, "int32_t", "int32_t", false, false, false, false, false, "end");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_anim_set_var
void lv_anim_set_var(lv_anim_t* a, void* var) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(a);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_anim_set_var' called on unknown or unregistered opaque pointer %p.\n", (void*)a);
        // Check if it's maybe NULL
        if (a == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_anim_set_var (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_var");
    cJSON *value_json = marshal_value(&var, "void*", "void", true, false, false, false, false, "var");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_anim_speed
uint32_t lv_anim_speed(uint32_t speed) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_speed' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_anim_speed_clamped
uint32_t lv_anim_speed_clamped(uint32_t speed, uint32_t min_time, uint32_t max_time) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_speed_clamped' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_anim_speed_to_time
uint32_t lv_anim_speed_to_time(uint32_t speed, int32_t start, int32_t end) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_speed_to_time' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_anim_start
lv_anim_t* lv_anim_start(lv_anim_t* a) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_start' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_anim_t* */
    return NULL;
}

// Wrapper for: lv_anim_timeline_add
void lv_anim_timeline_add(lv_anim_timeline_t* at, uint32_t start_time, lv_anim_t* a) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_timeline_add' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_anim_timeline_create
lv_anim_timeline_t* lv_anim_timeline_create(void) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_anim_timeline_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_anim_timeline_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_anim_timeline_t*)new_obj_json;
}

// Wrapper for: lv_anim_timeline_delete
void lv_anim_timeline_delete(lv_anim_timeline_t* at) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_timeline_delete' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_anim_timeline_get_playtime
uint32_t lv_anim_timeline_get_playtime(lv_anim_timeline_t* at) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_timeline_get_playtime' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_anim_timeline_get_progress
uint16_t lv_anim_timeline_get_progress(lv_anim_timeline_t* at) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_timeline_get_progress' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint16_t */
    return 0;
}

// Wrapper for: lv_anim_timeline_get_repeat_count
uint32_t lv_anim_timeline_get_repeat_count(lv_anim_timeline_t* at) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_timeline_get_repeat_count' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_anim_timeline_get_repeat_delay
uint32_t lv_anim_timeline_get_repeat_delay(lv_anim_timeline_t* at) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_timeline_get_repeat_delay' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_anim_timeline_get_reverse
bool lv_anim_timeline_get_reverse(lv_anim_timeline_t* at) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_timeline_get_reverse' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_anim_timeline_pause
void lv_anim_timeline_pause(lv_anim_timeline_t* at) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_timeline_pause' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_anim_timeline_set_progress
void lv_anim_timeline_set_progress(lv_anim_timeline_t* at, uint16_t progress) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(at);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_anim_timeline_set_progress' called on unknown or unregistered opaque pointer %p.\n", (void*)at);
        // Check if it's maybe NULL
        if (at == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_anim_timeline_set_progress (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "timeline_set_progress");
    cJSON *value_json = marshal_value(&progress, "uint16_t", "uint16_t", false, false, false, false, false, "progress");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_anim_timeline_set_repeat_count
void lv_anim_timeline_set_repeat_count(lv_anim_timeline_t* at, uint32_t cnt) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(at);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_anim_timeline_set_repeat_count' called on unknown or unregistered opaque pointer %p.\n", (void*)at);
        // Check if it's maybe NULL
        if (at == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_anim_timeline_set_repeat_count (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "timeline_set_repeat_count");
    cJSON *value_json = marshal_value(&cnt, "uint32_t", "uint32_t", false, false, false, false, false, "cnt");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_anim_timeline_set_repeat_delay
void lv_anim_timeline_set_repeat_delay(lv_anim_timeline_t* at, uint32_t delay) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(at);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_anim_timeline_set_repeat_delay' called on unknown or unregistered opaque pointer %p.\n", (void*)at);
        // Check if it's maybe NULL
        if (at == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_anim_timeline_set_repeat_delay (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "timeline_set_repeat_delay");
    cJSON *value_json = marshal_value(&delay, "uint32_t", "uint32_t", false, false, false, false, false, "delay");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_anim_timeline_set_reverse
void lv_anim_timeline_set_reverse(lv_anim_timeline_t* at, bool reverse) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(at);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_anim_timeline_set_reverse' called on unknown or unregistered opaque pointer %p.\n", (void*)at);
        // Check if it's maybe NULL
        if (at == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_anim_timeline_set_reverse (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "timeline_set_reverse");
    cJSON *value_json = marshal_value(&reverse, "bool", "bool", false, false, false, false, false, "reverse");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_anim_timeline_start
uint32_t lv_anim_timeline_start(lv_anim_timeline_t* at) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_anim_timeline_start' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_animimg_create
lv_obj_t* lv_animimg_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_animimg_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_animimg_delete
bool lv_animimg_delete(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_animimg_delete' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_animimg_get_anim
lv_anim_t* lv_animimg_get_anim(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_animimg_get_anim' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_anim_t* */
    return NULL;
}

// Wrapper for: lv_animimg_get_duration
uint32_t lv_animimg_get_duration(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_animimg_get_duration' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_animimg_get_repeat_count
uint32_t lv_animimg_get_repeat_count(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_animimg_get_repeat_count' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_animimg_get_src
void** lv_animimg_get_src(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_animimg_get_src' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void** */
    return NULL;
}

// Wrapper for: lv_animimg_get_src_count
uint8_t lv_animimg_get_src_count(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_animimg_get_src_count' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint8_t */
    return 0;
}

// Wrapper for: lv_animimg_set_duration
void lv_animimg_set_duration(lv_obj_t* obj, uint32_t duration) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_animimg_set_duration' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_animimg_set_duration (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "animimg_set_duration");
    cJSON *value_json = marshal_value(&duration, "uint32_t", "uint32_t", false, false, false, false, false, "duration");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_animimg_set_repeat_count
void lv_animimg_set_repeat_count(lv_obj_t* obj, uint32_t count) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_animimg_set_repeat_count' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_animimg_set_repeat_count (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "animimg_set_repeat_count");
    cJSON *value_json = marshal_value(&count, "uint32_t", "uint32_t", false, false, false, false, false, "count");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_animimg_set_reverse_delay
void lv_animimg_set_reverse_delay(lv_obj_t* obj, uint32_t duration) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_animimg_set_reverse_delay' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_animimg_set_reverse_delay (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "animimg_set_reverse_delay");
    cJSON *value_json = marshal_value(&duration, "uint32_t", "uint32_t", false, false, false, false, false, "duration");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_animimg_set_reverse_duration
void lv_animimg_set_reverse_duration(lv_obj_t* obj, uint32_t duration) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_animimg_set_reverse_duration' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_animimg_set_reverse_duration (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "animimg_set_reverse_duration");
    cJSON *value_json = marshal_value(&duration, "uint32_t", "uint32_t", false, false, false, false, false, "duration");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_animimg_set_src
void lv_animimg_set_src(lv_obj_t* obj, void* dsc[], size_t num, bool reverse) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_animimg_set_src' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_animimg_set_src (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "animimg_set_src");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&dsc, "void*[]", "void", false, false, false, false, false, "dsc");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&num, "size_t", "size_t", false, false, false, false, false, "num");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&reverse, "bool", "bool", false, false, false, false, false, "reverse");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_animimg_start
void lv_animimg_start(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_animimg_start' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_arc_align_obj_to_angle
void lv_arc_align_obj_to_angle(lv_obj_t* obj, lv_obj_t* obj_to_align, int32_t r_offset) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_arc_align_obj_to_angle' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_arc_bind_value
lv_observer_t* lv_arc_bind_value(lv_obj_t* obj, lv_subject_t* subject) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_arc_bind_value' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_observer_t* */
    return NULL;
}

// Wrapper for: lv_arc_create
lv_obj_t* lv_arc_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_arc_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_arc_get_angle_end
lv_value_precise_t lv_arc_get_angle_end(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_arc_get_angle_end' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_value_precise_t */
    return 0;
}

// Wrapper for: lv_arc_get_angle_start
lv_value_precise_t lv_arc_get_angle_start(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_arc_get_angle_start' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_value_precise_t */
    return 0;
}

// Wrapper for: lv_arc_get_bg_angle_end
lv_value_precise_t lv_arc_get_bg_angle_end(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_arc_get_bg_angle_end' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_value_precise_t */
    return 0;
}

// Wrapper for: lv_arc_get_bg_angle_start
lv_value_precise_t lv_arc_get_bg_angle_start(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_arc_get_bg_angle_start' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_value_precise_t */
    return 0;
}

// Wrapper for: lv_arc_get_knob_offset
int32_t lv_arc_get_knob_offset(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_arc_get_knob_offset' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_arc_get_max_value
int32_t lv_arc_get_max_value(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_arc_get_max_value' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_arc_get_min_value
int32_t lv_arc_get_min_value(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_arc_get_min_value' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_arc_get_mode
lv_arc_mode_t lv_arc_get_mode(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_arc_get_mode' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_arc_mode_t */
    return 0;
}

// Wrapper for: lv_arc_get_rotation
int32_t lv_arc_get_rotation(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_arc_get_rotation' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_arc_get_value
int32_t lv_arc_get_value(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_arc_get_value' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_arc_rotate_obj_to_angle
void lv_arc_rotate_obj_to_angle(lv_obj_t* obj, lv_obj_t* obj_to_rotate, int32_t r_offset) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_arc_rotate_obj_to_angle' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_arc_set_angles
void lv_arc_set_angles(lv_obj_t* obj, lv_value_precise_t start, lv_value_precise_t end) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_arc_set_angles' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_arc_set_angles (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "arc_set_angles");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&start, "lv_value_precise_t", "lv_value_precise_t", false, false, false, false, false, "start");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&end, "lv_value_precise_t", "lv_value_precise_t", false, false, false, false, false, "end");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_arc_set_bg_angles
void lv_arc_set_bg_angles(lv_obj_t* obj, lv_value_precise_t start, lv_value_precise_t end) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_arc_set_bg_angles' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_arc_set_bg_angles (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "arc_set_bg_angles");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&start, "lv_value_precise_t", "lv_value_precise_t", false, false, false, false, false, "start");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&end, "lv_value_precise_t", "lv_value_precise_t", false, false, false, false, false, "end");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_arc_set_bg_end_angle
void lv_arc_set_bg_end_angle(lv_obj_t* obj, lv_value_precise_t end) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_arc_set_bg_end_angle' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_arc_set_bg_end_angle (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "arc_set_bg_end_angle");
    cJSON *value_json = marshal_value(&end, "lv_value_precise_t", "lv_value_precise_t", false, false, false, false, false, "end");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_arc_set_bg_start_angle
void lv_arc_set_bg_start_angle(lv_obj_t* obj, lv_value_precise_t start) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_arc_set_bg_start_angle' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_arc_set_bg_start_angle (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "arc_set_bg_start_angle");
    cJSON *value_json = marshal_value(&start, "lv_value_precise_t", "lv_value_precise_t", false, false, false, false, false, "start");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_arc_set_change_rate
void lv_arc_set_change_rate(lv_obj_t* obj, uint32_t rate) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_arc_set_change_rate' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_arc_set_change_rate (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "arc_set_change_rate");
    cJSON *value_json = marshal_value(&rate, "uint32_t", "uint32_t", false, false, false, false, false, "rate");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_arc_set_end_angle
void lv_arc_set_end_angle(lv_obj_t* obj, lv_value_precise_t end) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_arc_set_end_angle' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_arc_set_end_angle (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "arc_set_end_angle");
    cJSON *value_json = marshal_value(&end, "lv_value_precise_t", "lv_value_precise_t", false, false, false, false, false, "end");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_arc_set_knob_offset
void lv_arc_set_knob_offset(lv_obj_t* obj, int32_t offset) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_arc_set_knob_offset' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_arc_set_knob_offset (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "arc_set_knob_offset");
    cJSON *value_json = marshal_value(&offset, "int32_t", "int32_t", false, false, false, false, false, "offset");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_arc_set_mode
void lv_arc_set_mode(lv_obj_t* obj, lv_arc_mode_t type) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_arc_set_mode' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_arc_set_mode (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "arc_set_mode");
    cJSON *value_json = marshal_value(&type, "lv_arc_mode_t", "lv_arc_mode_t", false, true, false, false, false, "type");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_arc_set_range
void lv_arc_set_range(lv_obj_t* obj, int32_t min, int32_t max) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_arc_set_range' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_arc_set_range (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "arc_set_range");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&min, "int32_t", "int32_t", false, false, false, false, false, "min");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&max, "int32_t", "int32_t", false, false, false, false, false, "max");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_arc_set_rotation
void lv_arc_set_rotation(lv_obj_t* obj, int32_t rotation) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_arc_set_rotation' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_arc_set_rotation (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "arc_set_rotation");
    cJSON *value_json = marshal_value(&rotation, "int32_t", "int32_t", false, false, false, false, false, "rotation");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_arc_set_start_angle
void lv_arc_set_start_angle(lv_obj_t* obj, lv_value_precise_t start) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_arc_set_start_angle' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_arc_set_start_angle (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "arc_set_start_angle");
    cJSON *value_json = marshal_value(&start, "lv_value_precise_t", "lv_value_precise_t", false, false, false, false, false, "start");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_arc_set_value
void lv_arc_set_value(lv_obj_t* obj, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_arc_set_value' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_arc_set_value (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "arc_set_value");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_area_align
void lv_area_align(struct lv_area_t* base, struct lv_area_t* to_align, lv_align_t align, int32_t ofs_x, int32_t ofs_y) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_area_align' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_area_copy
void lv_area_copy(struct lv_area_t* dest, struct lv_area_t* src) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_area_copy' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_area_get_height
int32_t lv_area_get_height(struct lv_area_t* area_p) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_area_get_height' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_area_get_size
uint32_t lv_area_get_size(struct lv_area_t* area_p) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_area_get_size' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_area_get_width
int32_t lv_area_get_width(struct lv_area_t* area_p) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_area_get_width' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_area_increase
void lv_area_increase(struct lv_area_t* area, int32_t w_extra, int32_t h_extra) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_area_increase' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_area_move
void lv_area_move(struct lv_area_t* area, int32_t x_ofs, int32_t y_ofs) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_area_move' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_area_set
void lv_area_set(struct lv_area_t* area_p, int32_t x1, int32_t y1, int32_t x2, int32_t y2) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_area_set' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_area_set_height
void lv_area_set_height(struct lv_area_t* area_p, int32_t h) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_area_set_height' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_area_set_width
void lv_area_set_width(struct lv_area_t* area_p, int32_t w) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_area_set_width' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_array_assign
lv_result_t lv_array_assign(lv_array_t* array, uint32_t index, void* value) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_array_assign' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_array_at
void* lv_array_at(lv_array_t* array, uint32_t index) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_array_at' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_array_back
void* lv_array_back(lv_array_t* array) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_array_back' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_array_capacity
uint32_t lv_array_capacity(lv_array_t* array) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_array_capacity' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_array_clear
void lv_array_clear(lv_array_t* array) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_array_clear' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_array_concat
lv_result_t lv_array_concat(lv_array_t* array, lv_array_t* other) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_array_concat' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_array_copy
void lv_array_copy(lv_array_t* target, lv_array_t* source) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_array_copy' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_array_deinit
void lv_array_deinit(lv_array_t* array) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_array_deinit' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_array_erase
lv_result_t lv_array_erase(lv_array_t* array, uint32_t start, uint32_t end) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_array_erase' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_array_front
void* lv_array_front(lv_array_t* array) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_array_front' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_array_init
void lv_array_init(lv_array_t* array, uint32_t capacity, uint32_t element_size) {
    /* Wrapper Type: init */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in init"); assert(false); /* Cannot return if void */ return; }
    const char* type_name = "lv_array_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "initializer_func", "lv_array_init");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *init_args_array = cJSON_CreateArray();
    if (!init_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "init_args", init_args_array);
    cJSON* marshaled_arg = marshal_value(&capacity, "uint32_t", "uint32_t", false, false, false, false, false, "capacity");
    if (marshaled_arg) {
        cJSON_AddItemToArray(init_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(init_args_array, cJSON_CreateNull());
    }
    cJSON* marshaled_arg = marshal_value(&element_size, "uint32_t", "uint32_t", false, false, false, false, false, "element_size");
    if (marshaled_arg) {
        cJSON_AddItemToArray(init_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(init_args_array, cJSON_CreateNull());
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)array, type_name, obj_id, new_obj_json);
}

// Wrapper for: lv_array_init_from_buf
void lv_array_init_from_buf(lv_array_t* array, void* buf, uint32_t capacity, uint32_t element_size) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_array_init_from_buf' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_array_is_empty
bool lv_array_is_empty(lv_array_t* array) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_array_is_empty' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_array_is_full
bool lv_array_is_full(lv_array_t* array) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_array_is_full' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_array_push_back
lv_result_t lv_array_push_back(lv_array_t* array, void* element) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_array_push_back' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_array_remove
lv_result_t lv_array_remove(lv_array_t* array, uint32_t index) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_array_remove' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_array_resize
bool lv_array_resize(lv_array_t* array, uint32_t new_capacity) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_array_resize' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_array_shrink
void lv_array_shrink(lv_array_t* array) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_array_shrink' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_array_size
uint32_t lv_array_size(lv_array_t* array) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_array_size' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_atan2
uint16_t lv_atan2(int x, int y) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_atan2' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint16_t */
    return 0;
}

// Wrapper for: lv_bar_create
lv_obj_t* lv_bar_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_bar_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_bar_get_max_value
int32_t lv_bar_get_max_value(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_bar_get_max_value' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_bar_get_min_value
int32_t lv_bar_get_min_value(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_bar_get_min_value' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_bar_get_mode
lv_bar_mode_t lv_bar_get_mode(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_bar_get_mode' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_bar_mode_t */
    return 0;
}

// Wrapper for: lv_bar_get_orientation
lv_bar_orientation_t lv_bar_get_orientation(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_bar_get_orientation' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_bar_orientation_t */
    return 0;
}

// Wrapper for: lv_bar_get_start_value
int32_t lv_bar_get_start_value(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_bar_get_start_value' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_bar_get_value
int32_t lv_bar_get_value(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_bar_get_value' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_bar_is_symmetrical
bool lv_bar_is_symmetrical(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_bar_is_symmetrical' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_bar_set_mode
void lv_bar_set_mode(lv_obj_t* obj, lv_bar_mode_t mode) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_bar_set_mode' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_bar_set_mode (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bar_set_mode");
    cJSON *value_json = marshal_value(&mode, "lv_bar_mode_t", "lv_bar_mode_t", false, true, false, false, false, "mode");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_bar_set_orientation
void lv_bar_set_orientation(lv_obj_t* obj, lv_bar_orientation_t orientation) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_bar_set_orientation' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_bar_set_orientation (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bar_set_orientation");
    cJSON *value_json = marshal_value(&orientation, "lv_bar_orientation_t", "lv_bar_orientation_t", false, true, false, false, false, "orientation");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_bar_set_range
void lv_bar_set_range(lv_obj_t* obj, int32_t min, int32_t max) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_bar_set_range' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_bar_set_range (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bar_set_range");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&min, "int32_t", "int32_t", false, false, false, false, false, "min");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&max, "int32_t", "int32_t", false, false, false, false, false, "max");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_bar_set_start_value
void lv_bar_set_start_value(lv_obj_t* obj, int32_t start_value, lv_anim_enable_t anim) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_bar_set_start_value' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_bar_set_start_value (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bar_set_start_value");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&start_value, "int32_t", "int32_t", false, false, false, false, false, "start_value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&anim, "lv_anim_enable_t", "lv_anim_enable_t", false, false, false, false, false, "anim");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_bar_set_value
void lv_bar_set_value(lv_obj_t* obj, int32_t value, lv_anim_enable_t anim) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_bar_set_value' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_bar_set_value (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bar_set_value");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&anim, "lv_anim_enable_t", "lv_anim_enable_t", false, false, false, false, false, "anim");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_barcode_create
lv_obj_t* lv_barcode_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_barcode_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_barcode_get_dark_color
struct lv_color_t lv_barcode_get_dark_color(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_barcode_get_dark_color' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_t */
    return 0;
}

// Wrapper for: lv_barcode_get_light_color
struct lv_color_t lv_barcode_get_light_color(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_barcode_get_light_color' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_t */
    return 0;
}

// Wrapper for: lv_barcode_get_scale
uint16_t lv_barcode_get_scale(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_barcode_get_scale' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint16_t */
    return 0;
}

// Wrapper for: lv_barcode_set_dark_color
void lv_barcode_set_dark_color(lv_obj_t* obj, struct lv_color_t color) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_barcode_set_dark_color' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_barcode_set_dark_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "barcode_set_dark_color");
    cJSON *value_json = marshal_value(&color, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "color");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_barcode_set_direction
void lv_barcode_set_direction(lv_obj_t* obj, lv_dir_t direction) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_barcode_set_direction' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_barcode_set_direction (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "barcode_set_direction");
    cJSON *value_json = marshal_value(&direction, "lv_dir_t", "lv_dir_t", false, true, false, false, false, "direction");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_barcode_set_light_color
void lv_barcode_set_light_color(lv_obj_t* obj, struct lv_color_t color) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_barcode_set_light_color' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_barcode_set_light_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "barcode_set_light_color");
    cJSON *value_json = marshal_value(&color, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "color");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_barcode_set_scale
void lv_barcode_set_scale(lv_obj_t* obj, uint16_t scale) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_barcode_set_scale' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_barcode_set_scale (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "barcode_set_scale");
    cJSON *value_json = marshal_value(&scale, "uint16_t", "uint16_t", false, false, false, false, false, "scale");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_barcode_set_tiled
void lv_barcode_set_tiled(lv_obj_t* obj, bool tiled) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_barcode_set_tiled' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_barcode_set_tiled (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "barcode_set_tiled");
    cJSON *value_json = marshal_value(&tiled, "bool", "bool", false, false, false, false, false, "tiled");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_barcode_update
lv_result_t lv_barcode_update(lv_obj_t* obj, char* data) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_barcode_update' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return 0;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_barcode_update (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return 0;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "barcode_update");
    cJSON *value_json = marshal_value(&data, "char*", "char", true, false, false, false, false, "data");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
    /* Warning: Setter function 'lv_barcode_update' has non-void return type 'lv_result_t'. Returning default. */
    return 0;
}

// Wrapper for: lv_bezier3
int32_t lv_bezier3(int32_t t, int32_t u0, uint32_t u1, int32_t u2, int32_t u3) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_bezier3' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_bidi_calculate_align
void lv_bidi_calculate_align(lv_text_align_t* align, lv_base_dir_t* base_dir, char* txt) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_bidi_calculate_align' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_bidi_set_custom_neutrals_static
void lv_bidi_set_custom_neutrals_static(char* neutrals) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_bidi_set_custom_neutrals_static' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_bin_decoder_close
void lv_bin_decoder_close(lv_image_decoder_t* decoder, lv_image_decoder_dsc_t* dsc) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_bin_decoder_close' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_bin_decoder_get_area
lv_result_t lv_bin_decoder_get_area(lv_image_decoder_t* decoder, lv_image_decoder_dsc_t* dsc, struct lv_area_t* full_area, struct lv_area_t* decoded_area) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_bin_decoder_get_area' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_bin_decoder_info
lv_result_t lv_bin_decoder_info(lv_image_decoder_t* decoder, lv_image_decoder_dsc_t* dsc, struct lv_image_header_t* header) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_bin_decoder_info' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_bin_decoder_init
void lv_bin_decoder_init(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_bin_decoder_init' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_bin_decoder_open
lv_result_t lv_bin_decoder_open(lv_image_decoder_t* decoder, lv_image_decoder_dsc_t* dsc) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_bin_decoder_open' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_binfont_create
lv_font_t* lv_binfont_create(char* path) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_font_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_binfont_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&path, "char*", "char", true, false, false, false, false, "path");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_font_t*)new_obj_json;
}

// Wrapper for: lv_binfont_destroy
void lv_binfont_destroy(lv_font_t* font) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_binfont_destroy' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_bmp_deinit
void lv_bmp_deinit(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_bmp_deinit' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_bmp_init
void lv_bmp_init(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_bmp_init' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_button_create
lv_obj_t* lv_button_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_button_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_buttonmatrix_clear_button_ctrl
void lv_buttonmatrix_clear_button_ctrl(lv_obj_t* obj, uint32_t btn_id, lv_buttonmatrix_ctrl_t ctrl) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_buttonmatrix_clear_button_ctrl' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_buttonmatrix_clear_button_ctrl_all
void lv_buttonmatrix_clear_button_ctrl_all(lv_obj_t* obj, lv_buttonmatrix_ctrl_t ctrl) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_buttonmatrix_clear_button_ctrl_all' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_buttonmatrix_create
lv_obj_t* lv_buttonmatrix_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_buttonmatrix_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_buttonmatrix_get_button_text
char* lv_buttonmatrix_get_button_text(lv_obj_t* obj, uint32_t btn_id) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_buttonmatrix_get_button_text' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_buttonmatrix_get_map
char** lv_buttonmatrix_get_map(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_buttonmatrix_get_map' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char** */
    return NULL;
}

// Wrapper for: lv_buttonmatrix_get_one_checked
bool lv_buttonmatrix_get_one_checked(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_buttonmatrix_get_one_checked' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_buttonmatrix_get_selected_button
uint32_t lv_buttonmatrix_get_selected_button(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_buttonmatrix_get_selected_button' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_buttonmatrix_has_button_ctrl
bool lv_buttonmatrix_has_button_ctrl(lv_obj_t* obj, uint32_t btn_id, lv_buttonmatrix_ctrl_t ctrl) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_buttonmatrix_has_button_ctrl' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_buttonmatrix_set_button_ctrl
void lv_buttonmatrix_set_button_ctrl(lv_obj_t* obj, uint32_t btn_id, lv_buttonmatrix_ctrl_t ctrl) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_buttonmatrix_set_button_ctrl' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_buttonmatrix_set_button_ctrl (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "buttonmatrix_set_button_ctrl");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&btn_id, "uint32_t", "uint32_t", false, false, false, false, false, "btn_id");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&ctrl, "lv_buttonmatrix_ctrl_t", "lv_buttonmatrix_ctrl_t", false, true, false, false, false, "ctrl");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_buttonmatrix_set_button_ctrl_all
void lv_buttonmatrix_set_button_ctrl_all(lv_obj_t* obj, lv_buttonmatrix_ctrl_t ctrl) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_buttonmatrix_set_button_ctrl_all' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_buttonmatrix_set_button_ctrl_all (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "buttonmatrix_set_button_ctrl_all");
    cJSON *value_json = marshal_value(&ctrl, "lv_buttonmatrix_ctrl_t", "lv_buttonmatrix_ctrl_t", false, true, false, false, false, "ctrl");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_buttonmatrix_set_button_width
void lv_buttonmatrix_set_button_width(lv_obj_t* obj, uint32_t btn_id, uint32_t width) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_buttonmatrix_set_button_width' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_buttonmatrix_set_button_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "buttonmatrix_set_button_width");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&btn_id, "uint32_t", "uint32_t", false, false, false, false, false, "btn_id");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&width, "uint32_t", "uint32_t", false, false, false, false, false, "width");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_buttonmatrix_set_ctrl_map
void lv_buttonmatrix_set_ctrl_map(lv_obj_t* obj, const lv_buttonmatrix_ctrl_t ctrl_map[]) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_buttonmatrix_set_ctrl_map' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_buttonmatrix_set_ctrl_map (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "buttonmatrix_set_ctrl_map");
    cJSON *value_json = marshal_value(&ctrl_map, "const lv_buttonmatrix_ctrl_t[]", "", false, true, false, false, false, "ctrl_map");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_buttonmatrix_set_map
void lv_buttonmatrix_set_map(lv_obj_t* obj, char* map[]) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_buttonmatrix_set_map' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_buttonmatrix_set_map (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "buttonmatrix_set_map");
    cJSON *value_json = marshal_value(&map, "char*[]", "char", false, false, false, false, false, "map");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_buttonmatrix_set_one_checked
void lv_buttonmatrix_set_one_checked(lv_obj_t* obj, bool en) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_buttonmatrix_set_one_checked' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_buttonmatrix_set_one_checked (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "buttonmatrix_set_one_checked");
    cJSON *value_json = marshal_value(&en, "bool", "bool", false, false, false, false, false, "en");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_buttonmatrix_set_selected_button
void lv_buttonmatrix_set_selected_button(lv_obj_t* obj, uint32_t btn_id) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_buttonmatrix_set_selected_button' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_buttonmatrix_set_selected_button (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "buttonmatrix_set_selected_button");
    cJSON *value_json = marshal_value(&btn_id, "uint32_t", "uint32_t", false, false, false, false, false, "btn_id");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_calendar_create
lv_obj_t* lv_calendar_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_calendar_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_calendar_get_btnmatrix
lv_obj_t* lv_calendar_get_btnmatrix(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_calendar_get_btnmatrix' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_calendar_get_highlighted_dates
struct lv_calendar_date_t* lv_calendar_get_highlighted_dates(lv_obj_t* calendar) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_calendar_get_highlighted_dates' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type struct lv_calendar_date_t* */
    return NULL;
}

// Wrapper for: lv_calendar_get_highlighted_dates_num
size_t lv_calendar_get_highlighted_dates_num(lv_obj_t* calendar) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_calendar_get_highlighted_dates_num' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type size_t */
    return 0;
}

// Wrapper for: lv_calendar_get_pressed_date
lv_result_t lv_calendar_get_pressed_date(lv_obj_t* calendar, struct lv_calendar_date_t* date) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_calendar_get_pressed_date' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_calendar_get_showed_date
struct lv_calendar_date_t* lv_calendar_get_showed_date(lv_obj_t* calendar) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_calendar_get_showed_date' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type struct lv_calendar_date_t* */
    return NULL;
}

// Wrapper for: lv_calendar_get_today_date
struct lv_calendar_date_t* lv_calendar_get_today_date(lv_obj_t* calendar) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_calendar_get_today_date' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type struct lv_calendar_date_t* */
    return NULL;
}

// Wrapper for: lv_calendar_header_arrow_create
lv_obj_t* lv_calendar_header_arrow_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_calendar_header_arrow_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_calendar_header_dropdown_create
lv_obj_t* lv_calendar_header_dropdown_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_calendar_header_dropdown_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_calendar_header_dropdown_set_year_list
void lv_calendar_header_dropdown_set_year_list(lv_obj_t* parent, char* years_list) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(parent);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_calendar_header_dropdown_set_year_list' called on unknown or unregistered opaque pointer %p.\n", (void*)parent);
        // Check if it's maybe NULL
        if (parent == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_calendar_header_dropdown_set_year_list (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "calendar_header_dropdown_set_year_list");
    cJSON *value_json = marshal_value(&years_list, "char*", "char", true, false, false, false, false, "years_list");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_calendar_set_day_names
void lv_calendar_set_day_names(lv_obj_t* obj, char** day_names) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_calendar_set_day_names' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_calendar_set_day_names (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "calendar_set_day_names");
    cJSON *value_json = marshal_value(&day_names, "char**", "char", true, false, false, false, false, "day_names");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_calendar_set_highlighted_dates
void lv_calendar_set_highlighted_dates(lv_obj_t* obj, lv_calendar_date_t highlighted[], size_t date_num) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_calendar_set_highlighted_dates' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_calendar_set_highlighted_dates (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "calendar_set_highlighted_dates");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&highlighted, "lv_calendar_date_t[]", "", false, false, true, false, false, "highlighted");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&date_num, "size_t", "size_t", false, false, false, false, false, "date_num");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_calendar_set_month_shown
void lv_calendar_set_month_shown(lv_obj_t* obj, uint32_t year, uint32_t month) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_calendar_set_month_shown' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_calendar_set_month_shown (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "calendar_set_month_shown");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&year, "uint32_t", "uint32_t", false, false, false, false, false, "year");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&month, "uint32_t", "uint32_t", false, false, false, false, false, "month");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_calendar_set_today_date
void lv_calendar_set_today_date(lv_obj_t* obj, uint32_t year, uint32_t month, uint32_t day) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_calendar_set_today_date' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_calendar_set_today_date (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "calendar_set_today_date");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&year, "uint32_t", "uint32_t", false, false, false, false, false, "year");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&month, "uint32_t", "uint32_t", false, false, false, false, false, "month");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&day, "uint32_t", "uint32_t", false, false, false, false, false, "day");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_calloc
void* lv_calloc(size_t num, size_t size) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_calloc' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_canvas_buf_size
uint32_t lv_canvas_buf_size(int32_t w, int32_t h, uint8_t bpp, uint8_t stride) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_canvas_buf_size' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_canvas_copy_buf
void lv_canvas_copy_buf(lv_obj_t* obj, struct lv_area_t* canvas_area, lv_draw_buf_t* dest_buf, struct lv_area_t* dest_area) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_canvas_copy_buf' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_canvas_create
lv_obj_t* lv_canvas_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_canvas_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_canvas_fill_bg
void lv_canvas_fill_bg(lv_obj_t* obj, struct lv_color_t color, lv_opa_t opa) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_canvas_fill_bg' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_canvas_finish_layer
void lv_canvas_finish_layer(lv_obj_t* canvas, lv_layer_t* layer) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_canvas_finish_layer' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_canvas_get_buf
void* lv_canvas_get_buf(lv_obj_t* canvas) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_canvas_get_buf' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_canvas_get_draw_buf
lv_draw_buf_t* lv_canvas_get_draw_buf(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_canvas_get_draw_buf' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_draw_buf_t* */
    return NULL;
}

// Wrapper for: lv_canvas_get_px
struct lv_color32_t lv_canvas_get_px(lv_obj_t* obj, int32_t x, int32_t y) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_canvas_get_px' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color32_t */
    return 0;
}

// Wrapper for: lv_canvas_init_layer
void lv_canvas_init_layer(lv_obj_t* canvas, lv_layer_t* layer) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_canvas_init_layer' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_canvas_set_buffer
void lv_canvas_set_buffer(lv_obj_t* obj, void* buf, int32_t w, int32_t h, lv_color_format_t cf) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_canvas_set_buffer' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_canvas_set_buffer (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "canvas_set_buffer");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&buf, "void*", "void", true, false, false, false, false, "buf");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&w, "int32_t", "int32_t", false, false, false, false, false, "w");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&h, "int32_t", "int32_t", false, false, false, false, false, "h");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_3 = marshal_value(&cf, "lv_color_format_t", "lv_color_format_t", false, true, false, false, false, "cf");
        if (val_3) cJSON_AddItemToArray(values_array, val_3); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_canvas_set_draw_buf
void lv_canvas_set_draw_buf(lv_obj_t* obj, lv_draw_buf_t* draw_buf) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_canvas_set_draw_buf' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_canvas_set_draw_buf (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "canvas_set_draw_buf");
    cJSON *value_json = marshal_value(&draw_buf, "lv_draw_buf_t*", "lv_draw_buf_t", true, false, false, false, true, "draw_buf");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_canvas_set_palette
void lv_canvas_set_palette(lv_obj_t* obj, uint8_t index, struct lv_color32_t color) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_canvas_set_palette' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_canvas_set_palette (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "canvas_set_palette");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&index, "uint8_t", "uint8_t", false, false, false, false, false, "index");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&color, "struct lv_color32_t", "lv_color32_t", false, false, true, false, false, "color");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_canvas_set_px
void lv_canvas_set_px(lv_obj_t* obj, int32_t x, int32_t y, struct lv_color_t color, lv_opa_t opa) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_canvas_set_px' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_canvas_set_px (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "canvas_set_px");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&x, "int32_t", "int32_t", false, false, false, false, false, "x");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&y, "int32_t", "int32_t", false, false, false, false, false, "y");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&color, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "color");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_3 = marshal_value(&opa, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "opa");
        if (val_3) cJSON_AddItemToArray(values_array, val_3); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_chart_add_cursor
lv_chart_cursor_t* lv_chart_add_cursor(lv_obj_t* obj, struct lv_color_t color, lv_dir_t dir) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_chart_cursor_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_chart_add_cursor");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&obj, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "obj");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&color, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "color");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&dir, "lv_dir_t", "lv_dir_t", false, true, false, false, false, "dir");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_chart_cursor_t*)new_obj_json;
}

// Wrapper for: lv_chart_add_series
lv_chart_series_t* lv_chart_add_series(lv_obj_t* obj, struct lv_color_t color, lv_chart_axis_t axis) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_chart_series_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_chart_add_series");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&obj, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "obj");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&color, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "color");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&axis, "lv_chart_axis_t", "lv_chart_axis_t", false, true, false, false, false, "axis");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_chart_series_t*)new_obj_json;
}

// Wrapper for: lv_chart_create
lv_obj_t* lv_chart_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_chart_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_chart_get_cursor_point
struct lv_point_t lv_chart_get_cursor_point(lv_obj_t* chart, lv_chart_cursor_t* cursor) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_chart_get_cursor_point' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_point_t */
    return 0;
}

// Wrapper for: lv_chart_get_first_point_center_offset
int32_t lv_chart_get_first_point_center_offset(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_chart_get_first_point_center_offset' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_chart_get_point_count
uint32_t lv_chart_get_point_count(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_chart_get_point_count' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_chart_get_point_pos_by_id
void lv_chart_get_point_pos_by_id(lv_obj_t* obj, lv_chart_series_t* ser, uint32_t id, struct lv_point_t* p_out) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_chart_get_point_pos_by_id' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_chart_get_pressed_point
uint32_t lv_chart_get_pressed_point(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_chart_get_pressed_point' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_chart_get_series_color
struct lv_color_t lv_chart_get_series_color(lv_obj_t* chart, lv_chart_series_t* series) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_chart_get_series_color' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_t */
    return 0;
}

// Wrapper for: lv_chart_get_series_next
lv_chart_series_t* lv_chart_get_series_next(lv_obj_t* chart, lv_chart_series_t* ser) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_chart_get_series_next' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_chart_series_t* */
    return NULL;
}

// Wrapper for: lv_chart_get_series_x_array
int32_t* lv_chart_get_series_x_array(lv_obj_t* obj, lv_chart_series_t* ser) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_chart_get_series_x_array' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type int32_t* */
    return NULL;
}

// Wrapper for: lv_chart_get_series_y_array
int32_t* lv_chart_get_series_y_array(lv_obj_t* obj, lv_chart_series_t* ser) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_chart_get_series_y_array' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type int32_t* */
    return NULL;
}

// Wrapper for: lv_chart_get_type
lv_chart_type_t lv_chart_get_type(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_chart_get_type' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_chart_type_t */
    return 0;
}

// Wrapper for: lv_chart_get_x_start_point
uint32_t lv_chart_get_x_start_point(lv_obj_t* obj, lv_chart_series_t* ser) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_chart_get_x_start_point' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_chart_hide_series
void lv_chart_hide_series(lv_obj_t* chart, lv_chart_series_t* series, bool hide) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_chart_hide_series' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_chart_refresh
void lv_chart_refresh(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_chart_refresh' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_chart_remove_series
void lv_chart_remove_series(lv_obj_t* obj, lv_chart_series_t* series) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_chart_remove_series' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_chart_remove_series (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "chart_remove_series");
    cJSON *value_json = marshal_value(&series, "lv_chart_series_t*", "lv_chart_series_t", true, false, false, false, true, "series");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_chart_set_all_values
void lv_chart_set_all_values(lv_obj_t* obj, lv_chart_series_t* ser, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_chart_set_all_values' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_chart_set_all_values (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "chart_set_all_values");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&ser, "lv_chart_series_t*", "lv_chart_series_t", true, false, false, false, true, "ser");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_chart_set_axis_range
void lv_chart_set_axis_range(lv_obj_t* obj, lv_chart_axis_t axis, int32_t min, int32_t max) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_chart_set_axis_range' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_chart_set_axis_range (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "chart_set_axis_range");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&axis, "lv_chart_axis_t", "lv_chart_axis_t", false, true, false, false, false, "axis");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&min, "int32_t", "int32_t", false, false, false, false, false, "min");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&max, "int32_t", "int32_t", false, false, false, false, false, "max");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_chart_set_cursor_point
void lv_chart_set_cursor_point(lv_obj_t* chart, lv_chart_cursor_t* cursor, lv_chart_series_t* ser, uint32_t point_id) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(chart);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_chart_set_cursor_point' called on unknown or unregistered opaque pointer %p.\n", (void*)chart);
        // Check if it's maybe NULL
        if (chart == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_chart_set_cursor_point (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "chart_set_cursor_point");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&cursor, "lv_chart_cursor_t*", "lv_chart_cursor_t", true, false, false, false, true, "cursor");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&ser, "lv_chart_series_t*", "lv_chart_series_t", true, false, false, false, true, "ser");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&point_id, "uint32_t", "uint32_t", false, false, false, false, false, "point_id");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_chart_set_cursor_pos
void lv_chart_set_cursor_pos(lv_obj_t* chart, lv_chart_cursor_t* cursor, struct lv_point_t* pos) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(chart);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_chart_set_cursor_pos' called on unknown or unregistered opaque pointer %p.\n", (void*)chart);
        // Check if it's maybe NULL
        if (chart == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_chart_set_cursor_pos (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "chart_set_cursor_pos");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&cursor, "lv_chart_cursor_t*", "lv_chart_cursor_t", true, false, false, false, true, "cursor");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&pos, "struct lv_point_t*", "lv_point_t", true, false, true, false, false, "pos");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_chart_set_div_line_count
void lv_chart_set_div_line_count(lv_obj_t* obj, uint8_t hdiv, uint8_t vdiv) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_chart_set_div_line_count' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_chart_set_div_line_count (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "chart_set_div_line_count");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&hdiv, "uint8_t", "uint8_t", false, false, false, false, false, "hdiv");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&vdiv, "uint8_t", "uint8_t", false, false, false, false, false, "vdiv");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_chart_set_next_value
void lv_chart_set_next_value(lv_obj_t* obj, lv_chart_series_t* ser, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_chart_set_next_value' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_chart_set_next_value (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "chart_set_next_value");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&ser, "lv_chart_series_t*", "lv_chart_series_t", true, false, false, false, true, "ser");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_chart_set_next_value2
void lv_chart_set_next_value2(lv_obj_t* obj, lv_chart_series_t* ser, int32_t x_value, int32_t y_value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_chart_set_next_value2' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_chart_set_next_value2 (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "chart_set_next_value2");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&ser, "lv_chart_series_t*", "lv_chart_series_t", true, false, false, false, true, "ser");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&x_value, "int32_t", "int32_t", false, false, false, false, false, "x_value");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&y_value, "int32_t", "int32_t", false, false, false, false, false, "y_value");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_chart_set_point_count
void lv_chart_set_point_count(lv_obj_t* obj, uint32_t cnt) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_chart_set_point_count' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_chart_set_point_count (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "chart_set_point_count");
    cJSON *value_json = marshal_value(&cnt, "uint32_t", "uint32_t", false, false, false, false, false, "cnt");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_chart_set_series_color
void lv_chart_set_series_color(lv_obj_t* chart, lv_chart_series_t* series, struct lv_color_t color) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(chart);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_chart_set_series_color' called on unknown or unregistered opaque pointer %p.\n", (void*)chart);
        // Check if it's maybe NULL
        if (chart == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_chart_set_series_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "chart_set_series_color");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&series, "lv_chart_series_t*", "lv_chart_series_t", true, false, false, false, true, "series");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&color, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "color");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_chart_set_series_ext_x_array
void lv_chart_set_series_ext_x_array(lv_obj_t* obj, lv_chart_series_t* ser, int32_t array[]) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_chart_set_series_ext_x_array' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_chart_set_series_ext_x_array (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "chart_set_series_ext_x_array");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&ser, "lv_chart_series_t*", "lv_chart_series_t", true, false, false, false, true, "ser");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&array, "int32_t[]", "", false, false, false, false, false, "array");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_chart_set_series_ext_y_array
void lv_chart_set_series_ext_y_array(lv_obj_t* obj, lv_chart_series_t* ser, int32_t array[]) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_chart_set_series_ext_y_array' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_chart_set_series_ext_y_array (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "chart_set_series_ext_y_array");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&ser, "lv_chart_series_t*", "lv_chart_series_t", true, false, false, false, true, "ser");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&array, "int32_t[]", "", false, false, false, false, false, "array");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_chart_set_series_value_by_id
void lv_chart_set_series_value_by_id(lv_obj_t* obj, lv_chart_series_t* ser, uint32_t id, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_chart_set_series_value_by_id' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_chart_set_series_value_by_id (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "chart_set_series_value_by_id");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&ser, "lv_chart_series_t*", "lv_chart_series_t", true, false, false, false, true, "ser");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&id, "uint32_t", "uint32_t", false, false, false, false, false, "id");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_chart_set_series_value_by_id2
void lv_chart_set_series_value_by_id2(lv_obj_t* obj, lv_chart_series_t* ser, uint32_t id, int32_t x_value, int32_t y_value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_chart_set_series_value_by_id2' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_chart_set_series_value_by_id2 (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "chart_set_series_value_by_id2");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&ser, "lv_chart_series_t*", "lv_chart_series_t", true, false, false, false, true, "ser");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&id, "uint32_t", "uint32_t", false, false, false, false, false, "id");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&x_value, "int32_t", "int32_t", false, false, false, false, false, "x_value");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_3 = marshal_value(&y_value, "int32_t", "int32_t", false, false, false, false, false, "y_value");
        if (val_3) cJSON_AddItemToArray(values_array, val_3); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_chart_set_series_values
void lv_chart_set_series_values(lv_obj_t* obj, lv_chart_series_t* ser, const int32_t values[], size_t values_cnt) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_chart_set_series_values' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_chart_set_series_values (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "chart_set_series_values");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&ser, "lv_chart_series_t*", "lv_chart_series_t", true, false, false, false, true, "ser");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&values, "const int32_t[]", "", false, false, false, false, false, "values");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&values_cnt, "size_t", "size_t", false, false, false, false, false, "values_cnt");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_chart_set_series_values2
void lv_chart_set_series_values2(lv_obj_t* obj, lv_chart_series_t* ser, const int32_t x_values[], const int32_t y_values[], size_t values_cnt) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_chart_set_series_values2' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_chart_set_series_values2 (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "chart_set_series_values2");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&ser, "lv_chart_series_t*", "lv_chart_series_t", true, false, false, false, true, "ser");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&x_values, "const int32_t[]", "", false, false, false, false, false, "x_values");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&y_values, "const int32_t[]", "", false, false, false, false, false, "y_values");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_3 = marshal_value(&values_cnt, "size_t", "size_t", false, false, false, false, false, "values_cnt");
        if (val_3) cJSON_AddItemToArray(values_array, val_3); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_chart_set_type
void lv_chart_set_type(lv_obj_t* obj, lv_chart_type_t type) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_chart_set_type' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_chart_set_type (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "chart_set_type");
    cJSON *value_json = marshal_value(&type, "lv_chart_type_t", "lv_chart_type_t", false, true, false, false, false, "type");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_chart_set_update_mode
void lv_chart_set_update_mode(lv_obj_t* obj, lv_chart_update_mode_t update_mode) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_chart_set_update_mode' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_chart_set_update_mode (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "chart_set_update_mode");
    cJSON *value_json = marshal_value(&update_mode, "lv_chart_update_mode_t", "lv_chart_update_mode_t", false, true, false, false, false, "update_mode");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_chart_set_x_start_point
void lv_chart_set_x_start_point(lv_obj_t* obj, lv_chart_series_t* ser, uint32_t id) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_chart_set_x_start_point' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_chart_set_x_start_point (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "chart_set_x_start_point");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&ser, "lv_chart_series_t*", "lv_chart_series_t", true, false, false, false, true, "ser");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&id, "uint32_t", "uint32_t", false, false, false, false, false, "id");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_checkbox_create
lv_obj_t* lv_checkbox_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_checkbox_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_checkbox_get_text
char* lv_checkbox_get_text(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_checkbox_get_text' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_checkbox_set_text
void lv_checkbox_set_text(lv_obj_t* obj, char* txt) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_checkbox_set_text' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_checkbox_set_text (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "checkbox_set_text");
    cJSON *value_json = marshal_value(&txt, "char*", "char", true, false, false, false, false, "txt");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_checkbox_set_text_static
void lv_checkbox_set_text_static(lv_obj_t* obj, char* txt) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_checkbox_set_text_static' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_checkbox_set_text_static (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "checkbox_set_text_static");
    cJSON *value_json = marshal_value(&txt, "char*", "char", true, false, false, false, false, "txt");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_circle_buf_capacity
uint32_t lv_circle_buf_capacity(lv_circle_buf_t* circle_buf) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_circle_buf_capacity' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_circle_buf_create
lv_circle_buf_t* lv_circle_buf_create(uint32_t capacity, uint32_t element_size) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_circle_buf_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_circle_buf_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&capacity, "uint32_t", "uint32_t", false, false, false, false, false, "capacity");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&element_size, "uint32_t", "uint32_t", false, false, false, false, false, "element_size");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_circle_buf_t*)new_obj_json;
}

// Wrapper for: lv_circle_buf_create_from_array
lv_circle_buf_t* lv_circle_buf_create_from_array(lv_array_t* array) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_circle_buf_create_from_array' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_circle_buf_t* */
    return NULL;
}

// Wrapper for: lv_circle_buf_create_from_buf
lv_circle_buf_t* lv_circle_buf_create_from_buf(void* buf, uint32_t capacity, uint32_t element_size) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_circle_buf_create_from_buf' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_circle_buf_t* */
    return NULL;
}

// Wrapper for: lv_circle_buf_destroy
void lv_circle_buf_destroy(lv_circle_buf_t* circle_buf) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_circle_buf_destroy' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_circle_buf_head
void* lv_circle_buf_head(lv_circle_buf_t* circle_buf) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_circle_buf_head' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_circle_buf_is_empty
bool lv_circle_buf_is_empty(lv_circle_buf_t* circle_buf) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_circle_buf_is_empty' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_circle_buf_is_full
bool lv_circle_buf_is_full(lv_circle_buf_t* circle_buf) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_circle_buf_is_full' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_circle_buf_peek
lv_result_t lv_circle_buf_peek(lv_circle_buf_t* circle_buf, void* data) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_circle_buf_peek' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_circle_buf_peek_at
lv_result_t lv_circle_buf_peek_at(lv_circle_buf_t* circle_buf, uint32_t index, void* data) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_circle_buf_peek_at' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_circle_buf_read
lv_result_t lv_circle_buf_read(lv_circle_buf_t* circle_buf, void* data) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_circle_buf_read' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_circle_buf_remain
uint32_t lv_circle_buf_remain(lv_circle_buf_t* circle_buf) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_circle_buf_remain' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_circle_buf_reset
void lv_circle_buf_reset(lv_circle_buf_t* circle_buf) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_circle_buf_reset' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_circle_buf_resize
lv_result_t lv_circle_buf_resize(lv_circle_buf_t* circle_buf, uint32_t capacity) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_circle_buf_resize' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_circle_buf_size
uint32_t lv_circle_buf_size(lv_circle_buf_t* circle_buf) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_circle_buf_size' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_circle_buf_skip
lv_result_t lv_circle_buf_skip(lv_circle_buf_t* circle_buf) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_circle_buf_skip' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_circle_buf_tail
void* lv_circle_buf_tail(lv_circle_buf_t* circle_buf) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_circle_buf_tail' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_circle_buf_write
lv_result_t lv_circle_buf_write(lv_circle_buf_t* circle_buf, void* data) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_circle_buf_write' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_clamp_height
int32_t lv_clamp_height(int32_t height, int32_t min_height, int32_t max_height, int32_t ref_height) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_clamp_height' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_clamp_width
int32_t lv_clamp_width(int32_t width, int32_t min_width, int32_t max_width, int32_t ref_width) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_clamp_width' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_color16_luminance
uint8_t lv_color16_luminance(const struct lv_color16_t c) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color16_luminance' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint8_t */
    return 0;
}

// Wrapper for: lv_color16_premultiply
void lv_color16_premultiply(struct lv_color16_t* c, lv_opa_t a) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color16_premultiply' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_color24_luminance
uint8_t lv_color24_luminance(uint8_t* c) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color24_luminance' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint8_t */
    return 0;
}

// Wrapper for: lv_color32_eq
bool lv_color32_eq(struct lv_color32_t c1, struct lv_color32_t c2) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color32_eq' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_color32_luminance
uint8_t lv_color32_luminance(struct lv_color32_t c) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color32_luminance' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint8_t */
    return 0;
}

// Wrapper for: lv_color32_make
struct lv_color32_t lv_color32_make(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color32_make' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color32_t */
    return 0;
}

// Wrapper for: lv_color_16_16_mix
uint16_t lv_color_16_16_mix(uint16_t c1, uint16_t c2, uint8_t mix) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_16_16_mix' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint16_t */
    return 0;
}

// Wrapper for: lv_color_black
struct lv_color_t lv_color_black(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_black' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_t */
    return 0;
}

// Wrapper for: lv_color_brightness
uint8_t lv_color_brightness(struct lv_color_t c) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_brightness' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint8_t */
    return 0;
}

// Wrapper for: lv_color_darken
struct lv_color_t lv_color_darken(struct lv_color_t c, lv_opa_t lvl) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_darken' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_t */
    return 0;
}

// Wrapper for: lv_color_eq
bool lv_color_eq(struct lv_color_t c1, struct lv_color_t c2) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_eq' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_color_format_get_bpp
uint8_t lv_color_format_get_bpp(lv_color_format_t cf) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_format_get_bpp' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint8_t */
    return 0;
}

// Wrapper for: lv_color_format_get_size
uint8_t lv_color_format_get_size(lv_color_format_t cf) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_format_get_size' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint8_t */
    return 0;
}

// Wrapper for: lv_color_format_has_alpha
bool lv_color_format_has_alpha(lv_color_format_t src_cf) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_format_has_alpha' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_color_hex
struct lv_color_t lv_color_hex(uint32_t c) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_hex' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_t */
    return 0;
}

// Wrapper for: lv_color_hex3
struct lv_color_t lv_color_hex3(uint32_t c) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_hex3' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_t */
    return 0;
}

// Wrapper for: lv_color_hsv_to_rgb
struct lv_color_t lv_color_hsv_to_rgb(uint16_t h, uint8_t s, uint8_t v) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_hsv_to_rgb' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_t */
    return 0;
}

// Wrapper for: lv_color_lighten
struct lv_color_t lv_color_lighten(struct lv_color_t c, lv_opa_t lvl) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_lighten' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_t */
    return 0;
}

// Wrapper for: lv_color_luminance
uint8_t lv_color_luminance(struct lv_color_t c) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_luminance' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint8_t */
    return 0;
}

// Wrapper for: lv_color_make
struct lv_color_t lv_color_make(uint8_t r, uint8_t g, uint8_t b) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_make' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_t */
    return 0;
}

// Wrapper for: lv_color_mix
struct lv_color_t lv_color_mix(struct lv_color_t c1, struct lv_color_t c2, uint8_t mix) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_mix' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_t */
    return 0;
}

// Wrapper for: lv_color_mix32
struct lv_color32_t lv_color_mix32(struct lv_color32_t fg, struct lv_color32_t bg) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_mix32' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color32_t */
    return 0;
}

// Wrapper for: lv_color_mix32_premultiplied
struct lv_color32_t lv_color_mix32_premultiplied(struct lv_color32_t fg, struct lv_color32_t bg) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_mix32_premultiplied' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color32_t */
    return 0;
}

// Wrapper for: lv_color_over32
struct lv_color32_t lv_color_over32(struct lv_color32_t fg, struct lv_color32_t bg) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_over32' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color32_t */
    return 0;
}

// Wrapper for: lv_color_premultiply
void lv_color_premultiply(struct lv_color32_t* c) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_premultiply' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_color_rgb_to_hsv
struct lv_color_hsv_t lv_color_rgb_to_hsv(uint8_t r8, uint8_t g8, uint8_t b8) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_rgb_to_hsv' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_hsv_t */
    return 0;
}

// Wrapper for: lv_color_to_32
struct lv_color32_t lv_color_to_32(struct lv_color_t color, lv_opa_t opa) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_to_32' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color32_t */
    return 0;
}

// Wrapper for: lv_color_to_hsv
struct lv_color_hsv_t lv_color_to_hsv(struct lv_color_t color) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_to_hsv' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_hsv_t */
    return 0;
}

// Wrapper for: lv_color_to_int
uint32_t lv_color_to_int(struct lv_color_t c) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_to_int' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_color_to_u16
uint16_t lv_color_to_u16(struct lv_color_t color) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_to_u16' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint16_t */
    return 0;
}

// Wrapper for: lv_color_to_u32
uint32_t lv_color_to_u32(struct lv_color_t color) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_to_u32' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_color_white
struct lv_color_t lv_color_white(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_color_white' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_t */
    return 0;
}

// Wrapper for: lv_cubic_bezier
int32_t lv_cubic_bezier(int32_t x, int32_t x1, int32_t y1, int32_t x2, int32_t y2) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_cubic_bezier' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_delay_ms
void lv_delay_ms(uint32_t ms) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_delay_ms' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_display_create
lv_display_t* lv_display_create(int32_t hor_res, int32_t ver_res) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_display_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_display_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&hor_res, "int32_t", "int32_t", false, false, false, false, false, "hor_res");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&ver_res, "int32_t", "int32_t", false, false, false, false, false, "ver_res");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_display_t*)new_obj_json;
}

// Wrapper for: lv_display_delete
void lv_display_delete(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_delete' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_display_delete_event
bool lv_display_delete_event(lv_display_t* disp, uint32_t index) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_delete_event' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_display_delete_refr_timer
void lv_display_delete_refr_timer(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_delete_refr_timer' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_display_dpx
int32_t lv_display_dpx(lv_display_t* disp, int32_t n) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_dpx' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_display_enable_invalidation
void lv_display_enable_invalidation(lv_display_t* disp, bool en) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(disp);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_display_enable_invalidation' called on unknown or unregistered opaque pointer %p.\n", (void*)disp);
        // Check if it's maybe NULL
        if (disp == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_display_enable_invalidation (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "enable_invalidation");
    cJSON *value_json = marshal_value(&en, "bool", "bool", false, false, false, false, false, "en");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_display_get_antialiasing
bool lv_display_get_antialiasing(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_antialiasing' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_display_get_buf_active
lv_draw_buf_t* lv_display_get_buf_active(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_buf_active' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_draw_buf_t* */
    return NULL;
}

// Wrapper for: lv_display_get_color_format
lv_color_format_t lv_display_get_color_format(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_color_format' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_color_format_t */
    return 0;
}

// Wrapper for: lv_display_get_default
lv_display_t* lv_display_get_default(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_default' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_display_t* */
    return NULL;
}

// Wrapper for: lv_display_get_dpi
int32_t lv_display_get_dpi(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_dpi' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_display_get_draw_buf_size
uint32_t lv_display_get_draw_buf_size(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_draw_buf_size' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_display_get_driver_data
void* lv_display_get_driver_data(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_driver_data' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_display_get_horizontal_resolution
int32_t lv_display_get_horizontal_resolution(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_horizontal_resolution' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_display_get_inactive_time
uint32_t lv_display_get_inactive_time(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_inactive_time' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_display_get_invalidated_draw_buf_size
uint32_t lv_display_get_invalidated_draw_buf_size(lv_display_t* disp, uint32_t width, uint32_t height) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_invalidated_draw_buf_size' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_display_get_layer_bottom
lv_obj_t* lv_display_get_layer_bottom(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_layer_bottom' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_display_get_layer_sys
lv_obj_t* lv_display_get_layer_sys(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_layer_sys' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_display_get_layer_top
lv_obj_t* lv_display_get_layer_top(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_layer_top' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_display_get_matrix_rotation
bool lv_display_get_matrix_rotation(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_matrix_rotation' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_display_get_next
lv_display_t* lv_display_get_next(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_next' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_display_t* */
    return NULL;
}

// Wrapper for: lv_display_get_offset_x
int32_t lv_display_get_offset_x(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_offset_x' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_display_get_offset_y
int32_t lv_display_get_offset_y(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_offset_y' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_display_get_original_horizontal_resolution
int32_t lv_display_get_original_horizontal_resolution(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_original_horizontal_resolution' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_display_get_original_vertical_resolution
int32_t lv_display_get_original_vertical_resolution(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_original_vertical_resolution' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_display_get_physical_horizontal_resolution
int32_t lv_display_get_physical_horizontal_resolution(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_physical_horizontal_resolution' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_display_get_physical_vertical_resolution
int32_t lv_display_get_physical_vertical_resolution(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_physical_vertical_resolution' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_display_get_refr_timer
lv_timer_t* lv_display_get_refr_timer(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_refr_timer' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_timer_t* */
    return NULL;
}

// Wrapper for: lv_display_get_rotation
lv_display_rotation_t lv_display_get_rotation(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_rotation' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_display_rotation_t */
    return 0;
}

// Wrapper for: lv_display_get_screen_active
lv_obj_t* lv_display_get_screen_active(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_screen_active' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_display_get_screen_prev
lv_obj_t* lv_display_get_screen_prev(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_screen_prev' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_display_get_theme
lv_theme_t* lv_display_get_theme(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_theme' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_theme_t* */
    return NULL;
}

// Wrapper for: lv_display_get_tile_cnt
uint32_t lv_display_get_tile_cnt(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_tile_cnt' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_display_get_user_data
void* lv_display_get_user_data(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_user_data' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_display_get_vertical_resolution
int32_t lv_display_get_vertical_resolution(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_get_vertical_resolution' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_display_is_double_buffered
bool lv_display_is_double_buffered(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_is_double_buffered' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_display_is_invalidation_enabled
bool lv_display_is_invalidation_enabled(lv_display_t* disp) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(disp);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_display_is_invalidation_enabled' called on unknown or unregistered opaque pointer %p.\n", (void*)disp);
        // Check if it's maybe NULL
        if (disp == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return false;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_display_is_invalidation_enabled (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return false;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "is_invalidation_enabled");
    cJSON *value_json = cJSON_CreateTrue();
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
    /* Warning: Setter function 'lv_display_is_invalidation_enabled' has non-void return type 'bool'. Returning default. */
    return false;
}

// Wrapper for: lv_display_refr_timer
void lv_display_refr_timer(lv_timer_t* timer) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_refr_timer' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_display_rotate_area
void lv_display_rotate_area(lv_display_t* disp, struct lv_area_t* area) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_rotate_area' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_display_send_vsync_event
lv_result_t lv_display_send_vsync_event(lv_display_t* disp, void* param) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_send_vsync_event' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_display_set_antialiasing
void lv_display_set_antialiasing(lv_display_t* disp, bool en) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(disp);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_display_set_antialiasing' called on unknown or unregistered opaque pointer %p.\n", (void*)disp);
        // Check if it's maybe NULL
        if (disp == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_display_set_antialiasing (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_antialiasing");
    cJSON *value_json = marshal_value(&en, "bool", "bool", false, false, false, false, false, "en");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_display_set_color_format
void lv_display_set_color_format(lv_display_t* disp, lv_color_format_t color_format) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(disp);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_display_set_color_format' called on unknown or unregistered opaque pointer %p.\n", (void*)disp);
        // Check if it's maybe NULL
        if (disp == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_display_set_color_format (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_color_format");
    cJSON *value_json = marshal_value(&color_format, "lv_color_format_t", "lv_color_format_t", false, true, false, false, false, "color_format");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_display_set_default
void lv_display_set_default(lv_display_t* disp) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(disp);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_display_set_default' called on unknown or unregistered opaque pointer %p.\n", (void*)disp);
        // Check if it's maybe NULL
        if (disp == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_display_set_default (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_default");
    cJSON *value_json = cJSON_CreateTrue();
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_display_set_dpi
void lv_display_set_dpi(lv_display_t* disp, int32_t dpi) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(disp);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_display_set_dpi' called on unknown or unregistered opaque pointer %p.\n", (void*)disp);
        // Check if it's maybe NULL
        if (disp == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_display_set_dpi (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_dpi");
    cJSON *value_json = marshal_value(&dpi, "int32_t", "int32_t", false, false, false, false, false, "dpi");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_display_set_draw_buffers
void lv_display_set_draw_buffers(lv_display_t* disp, lv_draw_buf_t* buf1, lv_draw_buf_t* buf2) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(disp);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_display_set_draw_buffers' called on unknown or unregistered opaque pointer %p.\n", (void*)disp);
        // Check if it's maybe NULL
        if (disp == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_display_set_draw_buffers (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_draw_buffers");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&buf1, "lv_draw_buf_t*", "lv_draw_buf_t", true, false, false, false, true, "buf1");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&buf2, "lv_draw_buf_t*", "lv_draw_buf_t", true, false, false, false, true, "buf2");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_display_set_driver_data
void lv_display_set_driver_data(lv_display_t* disp, void* driver_data) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(disp);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_display_set_driver_data' called on unknown or unregistered opaque pointer %p.\n", (void*)disp);
        // Check if it's maybe NULL
        if (disp == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_display_set_driver_data (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_driver_data");
    cJSON *value_json = marshal_value(&driver_data, "void*", "void", true, false, false, false, false, "driver_data");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_display_set_matrix_rotation
void lv_display_set_matrix_rotation(lv_display_t* disp, bool enable) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(disp);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_display_set_matrix_rotation' called on unknown or unregistered opaque pointer %p.\n", (void*)disp);
        // Check if it's maybe NULL
        if (disp == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_display_set_matrix_rotation (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_matrix_rotation");
    cJSON *value_json = marshal_value(&enable, "bool", "bool", false, false, false, false, false, "enable");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_display_set_offset
void lv_display_set_offset(lv_display_t* disp, int32_t x, int32_t y) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(disp);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_display_set_offset' called on unknown or unregistered opaque pointer %p.\n", (void*)disp);
        // Check if it's maybe NULL
        if (disp == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_display_set_offset (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_offset");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&x, "int32_t", "int32_t", false, false, false, false, false, "x");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&y, "int32_t", "int32_t", false, false, false, false, false, "y");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_display_set_physical_resolution
void lv_display_set_physical_resolution(lv_display_t* disp, int32_t hor_res, int32_t ver_res) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(disp);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_display_set_physical_resolution' called on unknown or unregistered opaque pointer %p.\n", (void*)disp);
        // Check if it's maybe NULL
        if (disp == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_display_set_physical_resolution (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_physical_resolution");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&hor_res, "int32_t", "int32_t", false, false, false, false, false, "hor_res");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&ver_res, "int32_t", "int32_t", false, false, false, false, false, "ver_res");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_display_set_render_mode
void lv_display_set_render_mode(lv_display_t* disp, lv_display_render_mode_t render_mode) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(disp);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_display_set_render_mode' called on unknown or unregistered opaque pointer %p.\n", (void*)disp);
        // Check if it's maybe NULL
        if (disp == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_display_set_render_mode (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_render_mode");
    cJSON *value_json = marshal_value(&render_mode, "lv_display_render_mode_t", "lv_display_render_mode_t", false, true, false, false, false, "render_mode");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_display_set_resolution
void lv_display_set_resolution(lv_display_t* disp, int32_t hor_res, int32_t ver_res) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(disp);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_display_set_resolution' called on unknown or unregistered opaque pointer %p.\n", (void*)disp);
        // Check if it's maybe NULL
        if (disp == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_display_set_resolution (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_resolution");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&hor_res, "int32_t", "int32_t", false, false, false, false, false, "hor_res");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&ver_res, "int32_t", "int32_t", false, false, false, false, false, "ver_res");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_display_set_rotation
void lv_display_set_rotation(lv_display_t* disp, lv_display_rotation_t rotation) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(disp);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_display_set_rotation' called on unknown or unregistered opaque pointer %p.\n", (void*)disp);
        // Check if it's maybe NULL
        if (disp == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_display_set_rotation (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_rotation");
    cJSON *value_json = marshal_value(&rotation, "lv_display_rotation_t", "lv_display_rotation_t", false, true, false, false, false, "rotation");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_display_set_theme
void lv_display_set_theme(lv_display_t* disp, lv_theme_t* th) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(disp);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_display_set_theme' called on unknown or unregistered opaque pointer %p.\n", (void*)disp);
        // Check if it's maybe NULL
        if (disp == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_display_set_theme (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_theme");
    cJSON *value_json = marshal_value(&th, "lv_theme_t*", "lv_theme_t", true, false, false, false, true, "th");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_display_set_tile_cnt
void lv_display_set_tile_cnt(lv_display_t* disp, uint32_t tile_cnt) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(disp);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_display_set_tile_cnt' called on unknown or unregistered opaque pointer %p.\n", (void*)disp);
        // Check if it's maybe NULL
        if (disp == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_display_set_tile_cnt (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_tile_cnt");
    cJSON *value_json = marshal_value(&tile_cnt, "uint32_t", "uint32_t", false, false, false, false, false, "tile_cnt");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_display_set_user_data
void lv_display_set_user_data(lv_display_t* disp, void* user_data) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(disp);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_display_set_user_data' called on unknown or unregistered opaque pointer %p.\n", (void*)disp);
        // Check if it's maybe NULL
        if (disp == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_display_set_user_data (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_user_data");
    cJSON *value_json = marshal_value(&user_data, "void*", "void", true, false, false, false, false, "user_data");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_display_trigger_activity
void lv_display_trigger_activity(lv_display_t* disp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_display_trigger_activity' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_dpx
int32_t lv_dpx(int32_t n) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_dpx' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_dropdown_add_option
void lv_dropdown_add_option(lv_obj_t* obj, char* option, uint32_t pos) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_dropdown_add_option' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_dropdown_add_option (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "dropdown_add_option");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&option, "char*", "char", true, false, false, false, false, "option");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&pos, "uint32_t", "uint32_t", false, false, false, false, false, "pos");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_dropdown_bind_value
lv_observer_t* lv_dropdown_bind_value(lv_obj_t* obj, lv_subject_t* subject) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_dropdown_bind_value' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_observer_t* */
    return NULL;
}

// Wrapper for: lv_dropdown_clear_options
void lv_dropdown_clear_options(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_dropdown_clear_options' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_dropdown_close
void lv_dropdown_close(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_dropdown_close' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_dropdown_create
lv_obj_t* lv_dropdown_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_dropdown_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_dropdown_get_dir
lv_dir_t lv_dropdown_get_dir(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_dropdown_get_dir' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_dir_t */
    return 0;
}

// Wrapper for: lv_dropdown_get_list
lv_obj_t* lv_dropdown_get_list(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_dropdown_get_list' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_dropdown_get_option_count
uint32_t lv_dropdown_get_option_count(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_dropdown_get_option_count' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_dropdown_get_option_index
int32_t lv_dropdown_get_option_index(lv_obj_t* obj, char* option) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_dropdown_get_option_index' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_dropdown_get_options
char* lv_dropdown_get_options(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_dropdown_get_options' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_dropdown_get_selected
uint32_t lv_dropdown_get_selected(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_dropdown_get_selected' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_dropdown_get_selected_highlight
bool lv_dropdown_get_selected_highlight(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_dropdown_get_selected_highlight' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_dropdown_get_selected_str
void lv_dropdown_get_selected_str(lv_obj_t* obj, char* buf, uint32_t buf_size) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_dropdown_get_selected_str' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_dropdown_get_symbol
char* lv_dropdown_get_symbol(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_dropdown_get_symbol' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_dropdown_get_text
char* lv_dropdown_get_text(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_dropdown_get_text' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_dropdown_is_open
bool lv_dropdown_is_open(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_dropdown_is_open' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_dropdown_open
void lv_dropdown_open(lv_obj_t* dropdown_obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_dropdown_open' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_dropdown_set_dir
void lv_dropdown_set_dir(lv_obj_t* obj, lv_dir_t dir) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_dropdown_set_dir' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_dropdown_set_dir (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "dropdown_set_dir");
    cJSON *value_json = marshal_value(&dir, "lv_dir_t", "lv_dir_t", false, true, false, false, false, "dir");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_dropdown_set_options
void lv_dropdown_set_options(lv_obj_t* obj, char* options) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_dropdown_set_options' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_dropdown_set_options (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "dropdown_set_options");
    cJSON *value_json = marshal_value(&options, "char*", "char", true, false, false, false, false, "options");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_dropdown_set_options_static
void lv_dropdown_set_options_static(lv_obj_t* obj, char* options) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_dropdown_set_options_static' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_dropdown_set_options_static (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "dropdown_set_options_static");
    cJSON *value_json = marshal_value(&options, "char*", "char", true, false, false, false, false, "options");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_dropdown_set_selected
void lv_dropdown_set_selected(lv_obj_t* obj, uint32_t sel_opt, lv_anim_enable_t anim) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_dropdown_set_selected' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_dropdown_set_selected (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "dropdown_set_selected");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&sel_opt, "uint32_t", "uint32_t", false, false, false, false, false, "sel_opt");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&anim, "lv_anim_enable_t", "lv_anim_enable_t", false, false, false, false, false, "anim");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_dropdown_set_selected_highlight
void lv_dropdown_set_selected_highlight(lv_obj_t* obj, bool en) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_dropdown_set_selected_highlight' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_dropdown_set_selected_highlight (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "dropdown_set_selected_highlight");
    cJSON *value_json = marshal_value(&en, "bool", "bool", false, false, false, false, false, "en");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_dropdown_set_symbol
void lv_dropdown_set_symbol(lv_obj_t* obj, void* symbol) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_dropdown_set_symbol' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_dropdown_set_symbol (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "dropdown_set_symbol");
    cJSON *value_json = marshal_value(&symbol, "void*", "void", true, false, false, false, false, "symbol");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_dropdown_set_text
void lv_dropdown_set_text(lv_obj_t* obj, char* txt) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_dropdown_set_text' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_dropdown_set_text (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "dropdown_set_text");
    cJSON *value_json = marshal_value(&txt, "char*", "char", true, false, false, false, false, "txt");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_event_code_get_name
char* lv_event_code_get_name(lv_event_code_t code) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_event_code_get_name' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_event_remove
bool lv_event_remove(struct lv_event_list_t* list, uint32_t index) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_event_remove' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_event_remove_all
void lv_event_remove_all(struct lv_event_list_t* list) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_event_remove_all' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_event_remove_dsc
bool lv_event_remove_dsc(struct lv_event_list_t* list, lv_event_dsc_t* dsc) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_event_remove_dsc' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_event_set_cover_res
void lv_event_set_cover_res(lv_event_t* e, lv_cover_res_t res) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(e);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_event_set_cover_res' called on unknown or unregistered opaque pointer %p.\n", (void*)e);
        // Check if it's maybe NULL
        if (e == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_event_set_cover_res (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "event_set_cover_res");
    cJSON *value_json = marshal_value(&res, "lv_cover_res_t", "lv_cover_res_t", false, true, false, false, false, "res");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_event_set_ext_draw_size
void lv_event_set_ext_draw_size(lv_event_t* e, int32_t size) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(e);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_event_set_ext_draw_size' called on unknown or unregistered opaque pointer %p.\n", (void*)e);
        // Check if it's maybe NULL
        if (e == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_event_set_ext_draw_size (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "event_set_ext_draw_size");
    cJSON *value_json = marshal_value(&size, "int32_t", "int32_t", false, false, false, false, false, "size");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_event_stop_bubbling
void lv_event_stop_bubbling(lv_event_t* e) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_event_stop_bubbling' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_event_stop_processing
void lv_event_stop_processing(lv_event_t* e) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_event_stop_processing' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_flex_init
void lv_flex_init(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_flex_init' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_font_info_is_equal
bool lv_font_info_is_equal(lv_font_info_t* ft_info_1, lv_font_info_t* ft_info_2) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_font_info_is_equal' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_font_set_kerning
void lv_font_set_kerning(lv_font_t* font, lv_font_kerning_t kerning) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(font);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_font_set_kerning' called on unknown or unregistered opaque pointer %p.\n", (void*)font);
        // Check if it's maybe NULL
        if (font == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_font_set_kerning (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "font_set_kerning");
    cJSON *value_json = marshal_value(&kerning, "lv_font_kerning_t", "lv_font_kerning_t", false, true, false, false, false, "kerning");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_fragment_create
lv_fragment_t* lv_fragment_create(lv_fragment_class_t* cls, void* args) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_fragment_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_fragment_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&cls, "lv_fragment_class_t*", "lv_fragment_class_t", true, false, false, false, true, "cls");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&args, "void*", "void", true, false, false, false, false, "args");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_fragment_t*)new_obj_json;
}

// Wrapper for: lv_fragment_create_obj
lv_obj_t* lv_fragment_create_obj(lv_fragment_t* fragment, lv_obj_t* container) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_fragment_create_obj");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&fragment, "lv_fragment_t*", "lv_fragment_t", true, false, false, false, true, "fragment");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&container, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "container");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_fragment_delete
void lv_fragment_delete(lv_fragment_t* fragment) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_fragment_delete' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_fragment_delete_obj
void lv_fragment_delete_obj(lv_fragment_t* fragment) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_fragment_delete_obj' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_fragment_get_container
lv_obj_t** lv_fragment_get_container(lv_fragment_t* fragment) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_fragment_get_container' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t** */
    return NULL;
}

// Wrapper for: lv_fragment_get_manager
lv_fragment_manager_t* lv_fragment_get_manager(lv_fragment_t* fragment) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_fragment_get_manager' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_fragment_manager_t* */
    return NULL;
}

// Wrapper for: lv_fragment_get_parent
lv_fragment_t* lv_fragment_get_parent(lv_fragment_t* fragment) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_fragment_get_parent' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_fragment_t* */
    return NULL;
}

// Wrapper for: lv_fragment_manager_add
void lv_fragment_manager_add(lv_fragment_manager_t* manager, lv_fragment_t* fragment, lv_obj_t** container) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_fragment_manager_add' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_fragment_manager_create
lv_fragment_manager_t* lv_fragment_manager_create(lv_fragment_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_fragment_manager_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_fragment_manager_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_fragment_t*", "lv_fragment_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_fragment_manager_t*)new_obj_json;
}

// Wrapper for: lv_fragment_manager_create_obj
void lv_fragment_manager_create_obj(lv_fragment_manager_t* manager) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_fragment_manager_create_obj' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_fragment_manager_delete
void lv_fragment_manager_delete(lv_fragment_manager_t* manager) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_fragment_manager_delete' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_fragment_manager_delete_obj
void lv_fragment_manager_delete_obj(lv_fragment_manager_t* manager) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_fragment_manager_delete_obj' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_fragment_manager_find_by_container
lv_fragment_t* lv_fragment_manager_find_by_container(lv_fragment_manager_t* manager, lv_obj_t* container) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_fragment_manager_find_by_container' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_fragment_t* */
    return NULL;
}

// Wrapper for: lv_fragment_manager_get_parent_fragment
lv_fragment_t* lv_fragment_manager_get_parent_fragment(lv_fragment_manager_t* manager) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_fragment_manager_get_parent_fragment' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_fragment_t* */
    return NULL;
}

// Wrapper for: lv_fragment_manager_get_stack_size
size_t lv_fragment_manager_get_stack_size(lv_fragment_manager_t* manager) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_fragment_manager_get_stack_size' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type size_t */
    return 0;
}

// Wrapper for: lv_fragment_manager_get_top
lv_fragment_t* lv_fragment_manager_get_top(lv_fragment_manager_t* manager) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_fragment_manager_get_top' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_fragment_t* */
    return NULL;
}

// Wrapper for: lv_fragment_manager_pop
bool lv_fragment_manager_pop(lv_fragment_manager_t* manager) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_fragment_manager_pop' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_fragment_manager_push
void lv_fragment_manager_push(lv_fragment_manager_t* manager, lv_fragment_t* fragment, lv_obj_t** container) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_fragment_manager_push' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_fragment_manager_remove
void lv_fragment_manager_remove(lv_fragment_manager_t* manager, lv_fragment_t* fragment) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_fragment_manager_remove' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_fragment_manager_replace
void lv_fragment_manager_replace(lv_fragment_manager_t* manager, lv_fragment_t* fragment, lv_obj_t** container) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_fragment_manager_replace' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_fragment_manager_send_event
bool lv_fragment_manager_send_event(lv_fragment_manager_t* manager, int code, void* userdata) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_fragment_manager_send_event' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_fragment_recreate_obj
void lv_fragment_recreate_obj(lv_fragment_t* fragment) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_fragment_recreate_obj' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_gif_create
lv_obj_t* lv_gif_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_gif_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_gif_get_loop_count
int32_t lv_gif_get_loop_count(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_gif_get_loop_count' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_gif_is_loaded
bool lv_gif_is_loaded(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_gif_is_loaded' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_gif_pause
void lv_gif_pause(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_gif_pause' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_gif_restart
void lv_gif_restart(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_gif_restart' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_gif_resume
void lv_gif_resume(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_gif_resume' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_gif_set_loop_count
void lv_gif_set_loop_count(lv_obj_t* obj, int32_t count) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_gif_set_loop_count' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_gif_set_loop_count (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "gif_set_loop_count");
    cJSON *value_json = marshal_value(&count, "int32_t", "int32_t", false, false, false, false, false, "count");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_gif_set_src
void lv_gif_set_src(lv_obj_t* obj, void* src) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_gif_set_src' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_gif_set_src (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "gif_set_src");
    cJSON *value_json = marshal_value(&src, "void*", "void", true, false, false, false, false, "src");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_grad_horizontal_init
void lv_grad_horizontal_init(struct lv_grad_dsc_t* dsc) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_grad_horizontal_init' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_grad_init_stops
void lv_grad_init_stops(struct lv_grad_dsc_t* grad, const lv_color_t colors[], const lv_opa_t opa[], const uint8_t fracs[], int num_stops) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_grad_init_stops' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_grad_vertical_init
void lv_grad_vertical_init(struct lv_grad_dsc_t* dsc) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_grad_vertical_init' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_grid_fr
int32_t lv_grid_fr(uint8_t x) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_grid_fr' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_grid_init
void lv_grid_init(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_grid_init' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_gridnav_add
void lv_gridnav_add(lv_obj_t* obj, lv_gridnav_ctrl_t ctrl) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_gridnav_add' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_gridnav_remove
void lv_gridnav_remove(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_gridnav_remove' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_gridnav_set_focused
void lv_gridnav_set_focused(lv_obj_t* cont, lv_obj_t* to_focus, lv_anim_enable_t anim_en) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(cont);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_gridnav_set_focused' called on unknown or unregistered opaque pointer %p.\n", (void*)cont);
        // Check if it's maybe NULL
        if (cont == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_gridnav_set_focused (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "gridnav_set_focused");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&to_focus, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "to_focus");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&anim_en, "lv_anim_enable_t", "lv_anim_enable_t", false, false, false, false, false, "anim_en");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_group_add_obj
void lv_group_add_obj(lv_group_t* group, lv_obj_t* obj) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(group);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_group_add_obj' called on unknown or unregistered opaque pointer %p.\n", (void*)group);
        // Check if it's maybe NULL
        if (group == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_group_add_obj (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "add_obj");
    cJSON *value_json = marshal_value(&obj, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "obj");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_group_by_index
lv_group_t* lv_group_by_index(uint32_t index) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_group_by_index' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_group_t* */
    return NULL;
}

// Wrapper for: lv_group_create
lv_group_t* lv_group_create(void) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_group_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_group_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_group_t*)new_obj_json;
}

// Wrapper for: lv_group_delete
void lv_group_delete(lv_group_t* group) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_group_delete' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_group_focus_freeze
void lv_group_focus_freeze(lv_group_t* group, bool en) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_group_focus_freeze' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_group_focus_next
void lv_group_focus_next(lv_group_t* group) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_group_focus_next' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_group_focus_obj
void lv_group_focus_obj(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_group_focus_obj' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_group_focus_prev
void lv_group_focus_prev(lv_group_t* group) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_group_focus_prev' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_group_get_count
uint32_t lv_group_get_count(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_group_get_count' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_group_get_default
lv_group_t* lv_group_get_default(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_group_get_default' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_group_t* */
    return NULL;
}

// Wrapper for: lv_group_get_editing
bool lv_group_get_editing(lv_group_t* group) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_group_get_editing' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_group_get_focused
lv_obj_t* lv_group_get_focused(lv_group_t* group) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_group_get_focused' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_group_get_obj_by_index
lv_obj_t* lv_group_get_obj_by_index(lv_group_t* group, uint32_t index) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_group_get_obj_by_index' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_group_get_obj_count
uint32_t lv_group_get_obj_count(lv_group_t* group) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_group_get_obj_count' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_group_get_wrap
bool lv_group_get_wrap(lv_group_t* group) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_group_get_wrap' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_group_remove_all_objs
void lv_group_remove_all_objs(lv_group_t* group) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(group);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_group_remove_all_objs' called on unknown or unregistered opaque pointer %p.\n", (void*)group);
        // Check if it's maybe NULL
        if (group == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_group_remove_all_objs (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "remove_all_objs");
    cJSON *value_json = cJSON_CreateTrue();
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_group_remove_obj
void lv_group_remove_obj(lv_obj_t* obj) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_group_remove_obj' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_group_remove_obj (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "remove_obj");
    cJSON *value_json = cJSON_CreateTrue();
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_group_send_data
lv_result_t lv_group_send_data(lv_group_t* group, uint32_t c) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_group_send_data' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_group_set_default
void lv_group_set_default(lv_group_t* group) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(group);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_group_set_default' called on unknown or unregistered opaque pointer %p.\n", (void*)group);
        // Check if it's maybe NULL
        if (group == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_group_set_default (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_default");
    cJSON *value_json = cJSON_CreateTrue();
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_group_set_editing
void lv_group_set_editing(lv_group_t* group, bool edit) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(group);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_group_set_editing' called on unknown or unregistered opaque pointer %p.\n", (void*)group);
        // Check if it's maybe NULL
        if (group == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_group_set_editing (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_editing");
    cJSON *value_json = marshal_value(&edit, "bool", "bool", false, false, false, false, false, "edit");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_group_set_refocus_policy
void lv_group_set_refocus_policy(lv_group_t* group, lv_group_refocus_policy_t policy) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(group);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_group_set_refocus_policy' called on unknown or unregistered opaque pointer %p.\n", (void*)group);
        // Check if it's maybe NULL
        if (group == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_group_set_refocus_policy (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_refocus_policy");
    cJSON *value_json = marshal_value(&policy, "lv_group_refocus_policy_t", "lv_group_refocus_policy_t", false, true, false, false, false, "policy");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_group_set_wrap
void lv_group_set_wrap(lv_group_t* group, bool en) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(group);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_group_set_wrap' called on unknown or unregistered opaque pointer %p.\n", (void*)group);
        // Check if it's maybe NULL
        if (group == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_group_set_wrap (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_wrap");
    cJSON *value_json = marshal_value(&en, "bool", "bool", false, false, false, false, false, "en");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_group_swap_obj
void lv_group_swap_obj(lv_obj_t* obj1, lv_obj_t* obj2) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_group_swap_obj' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_image_buf_free
void lv_image_buf_free(lv_image_dsc_t* dsc) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_buf_free' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_image_buf_set_palette
void lv_image_buf_set_palette(lv_image_dsc_t* dsc, uint8_t id, struct lv_color32_t c) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_buf_set_palette' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_image_create
lv_obj_t* lv_image_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_image_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_image_decoder_add_to_cache
lv_cache_entry_t* lv_image_decoder_add_to_cache(lv_image_decoder_t* decoder, lv_image_cache_data_t* search_key, lv_draw_buf_t* decoded, void* user_data) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_cache_entry_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_image_decoder_add_to_cache");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&decoder, "lv_image_decoder_t*", "lv_image_decoder_t", true, false, false, false, true, "decoder");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&search_key, "lv_image_cache_data_t*", "lv_image_cache_data_t", true, false, false, false, true, "search_key");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&decoded, "lv_draw_buf_t*", "lv_draw_buf_t", true, false, false, false, true, "decoded");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&user_data, "void*", "void", true, false, false, false, false, "user_data");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_cache_entry_t*)new_obj_json;
}

// Wrapper for: lv_image_decoder_close
void lv_image_decoder_close(lv_image_decoder_dsc_t* dsc) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_decoder_close' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_image_decoder_create
lv_image_decoder_t* lv_image_decoder_create(void) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_image_decoder_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_image_decoder_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_image_decoder_t*)new_obj_json;
}

// Wrapper for: lv_image_decoder_delete
void lv_image_decoder_delete(lv_image_decoder_t* decoder) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_decoder_delete' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_image_decoder_open
lv_result_t lv_image_decoder_open(lv_image_decoder_dsc_t* dsc, void* src, lv_image_decoder_args_t* args) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_decoder_open' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_image_decoder_post_process
lv_draw_buf_t* lv_image_decoder_post_process(lv_image_decoder_dsc_t* dsc, lv_draw_buf_t* decoded) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_decoder_post_process' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_draw_buf_t* */
    return NULL;
}

// Wrapper for: lv_image_get_antialias
bool lv_image_get_antialias(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_get_antialias' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_image_get_blend_mode
lv_blend_mode_t lv_image_get_blend_mode(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_get_blend_mode' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_blend_mode_t */
    return 0;
}

// Wrapper for: lv_image_get_inner_align
lv_image_align_t lv_image_get_inner_align(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_get_inner_align' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_image_align_t */
    return 0;
}

// Wrapper for: lv_image_get_offset_x
int32_t lv_image_get_offset_x(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_get_offset_x' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_image_get_offset_y
int32_t lv_image_get_offset_y(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_get_offset_y' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_image_get_pivot
void lv_image_get_pivot(lv_obj_t* obj, struct lv_point_t* pivot) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_get_pivot' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_image_get_rotation
int32_t lv_image_get_rotation(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_get_rotation' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_image_get_scale
int32_t lv_image_get_scale(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_get_scale' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_image_get_scale_x
int32_t lv_image_get_scale_x(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_get_scale_x' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_image_get_scale_y
int32_t lv_image_get_scale_y(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_get_scale_y' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_image_get_src
void* lv_image_get_src(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_get_src' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_image_get_src_height
int32_t lv_image_get_src_height(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_get_src_height' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_image_get_src_width
int32_t lv_image_get_src_width(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_get_src_width' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_image_get_transformed_height
int32_t lv_image_get_transformed_height(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_get_transformed_height' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_image_get_transformed_width
int32_t lv_image_get_transformed_width(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_get_transformed_width' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_image_set_antialias
void lv_image_set_antialias(lv_obj_t* obj, bool antialias) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_image_set_antialias' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_image_set_antialias (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "image_set_antialias");
    cJSON *value_json = marshal_value(&antialias, "bool", "bool", false, false, false, false, false, "antialias");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_image_set_blend_mode
void lv_image_set_blend_mode(lv_obj_t* obj, lv_blend_mode_t blend_mode) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_image_set_blend_mode' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_image_set_blend_mode (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "image_set_blend_mode");
    cJSON *value_json = marshal_value(&blend_mode, "lv_blend_mode_t", "lv_blend_mode_t", false, true, false, false, false, "blend_mode");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_image_set_inner_align
void lv_image_set_inner_align(lv_obj_t* obj, lv_image_align_t align) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_image_set_inner_align' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_image_set_inner_align (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "image_set_inner_align");
    cJSON *value_json = marshal_value(&align, "lv_image_align_t", "lv_image_align_t", false, true, false, false, false, "align");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_image_set_offset_x
void lv_image_set_offset_x(lv_obj_t* obj, int32_t x) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_image_set_offset_x' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_image_set_offset_x (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "image_set_offset_x");
    cJSON *value_json = marshal_value(&x, "int32_t", "int32_t", false, false, false, false, false, "x");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_image_set_offset_y
void lv_image_set_offset_y(lv_obj_t* obj, int32_t y) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_image_set_offset_y' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_image_set_offset_y (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "image_set_offset_y");
    cJSON *value_json = marshal_value(&y, "int32_t", "int32_t", false, false, false, false, false, "y");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_image_set_pivot
void lv_image_set_pivot(lv_obj_t* obj, int32_t x, int32_t y) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_image_set_pivot' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_image_set_pivot (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "image_set_pivot");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&x, "int32_t", "int32_t", false, false, false, false, false, "x");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&y, "int32_t", "int32_t", false, false, false, false, false, "y");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_image_set_rotation
void lv_image_set_rotation(lv_obj_t* obj, int32_t angle) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_image_set_rotation' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_image_set_rotation (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "image_set_rotation");
    cJSON *value_json = marshal_value(&angle, "int32_t", "int32_t", false, false, false, false, false, "angle");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_image_set_scale
void lv_image_set_scale(lv_obj_t* obj, uint32_t zoom) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_image_set_scale' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_image_set_scale (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "image_set_scale");
    cJSON *value_json = marshal_value(&zoom, "uint32_t", "uint32_t", false, false, false, false, false, "zoom");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_image_set_scale_x
void lv_image_set_scale_x(lv_obj_t* obj, uint32_t zoom) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_image_set_scale_x' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_image_set_scale_x (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "image_set_scale_x");
    cJSON *value_json = marshal_value(&zoom, "uint32_t", "uint32_t", false, false, false, false, false, "zoom");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_image_set_scale_y
void lv_image_set_scale_y(lv_obj_t* obj, uint32_t zoom) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_image_set_scale_y' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_image_set_scale_y (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "image_set_scale_y");
    cJSON *value_json = marshal_value(&zoom, "uint32_t", "uint32_t", false, false, false, false, false, "zoom");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_image_set_src
void lv_image_set_src(lv_obj_t* obj, void* src) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_image_set_src' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_image_set_src (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "image_set_src");
    cJSON *value_json = marshal_value(&src, "void*", "void", true, false, false, false, false, "src");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_image_src_get_type
lv_image_src_t lv_image_src_get_type(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_image_src_get_type' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_image_src_t */
    return 0;
}

// Wrapper for: lv_imagebutton_create
lv_obj_t* lv_imagebutton_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_imagebutton_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_imagebutton_get_src_left
void* lv_imagebutton_get_src_left(lv_obj_t* imagebutton, lv_imagebutton_state_t state) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_imagebutton_get_src_left' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_imagebutton_get_src_middle
void* lv_imagebutton_get_src_middle(lv_obj_t* imagebutton, lv_imagebutton_state_t state) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_imagebutton_get_src_middle' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_imagebutton_get_src_right
void* lv_imagebutton_get_src_right(lv_obj_t* imagebutton, lv_imagebutton_state_t state) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_imagebutton_get_src_right' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_imagebutton_set_src
void lv_imagebutton_set_src(lv_obj_t* imagebutton, lv_imagebutton_state_t state, void* src_left, void* src_mid, void* src_right) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(imagebutton);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_imagebutton_set_src' called on unknown or unregistered opaque pointer %p.\n", (void*)imagebutton);
        // Check if it's maybe NULL
        if (imagebutton == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_imagebutton_set_src (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "imagebutton_set_src");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&state, "lv_imagebutton_state_t", "lv_imagebutton_state_t", false, true, false, false, false, "state");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&src_left, "void*", "void", true, false, false, false, false, "src_left");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&src_mid, "void*", "void", true, false, false, false, false, "src_mid");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_3 = marshal_value(&src_right, "void*", "void", true, false, false, false, false, "src_right");
        if (val_3) cJSON_AddItemToArray(values_array, val_3); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_imagebutton_set_state
void lv_imagebutton_set_state(lv_obj_t* imagebutton, lv_imagebutton_state_t state) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(imagebutton);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_imagebutton_set_state' called on unknown or unregistered opaque pointer %p.\n", (void*)imagebutton);
        // Check if it's maybe NULL
        if (imagebutton == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_imagebutton_set_state (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "imagebutton_set_state");
    cJSON *value_json = marshal_value(&state, "lv_imagebutton_state_t", "lv_imagebutton_state_t", false, true, false, false, false, "state");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_imgfont_destroy
void lv_imgfont_destroy(lv_font_t* font) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_imgfont_destroy' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_iter_destroy
void lv_iter_destroy(lv_iter_t* iter) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_iter_destroy' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_iter_get_context
void* lv_iter_get_context(lv_iter_t* iter) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_iter_get_context' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_iter_make_peekable
void lv_iter_make_peekable(lv_iter_t* iter, uint32_t capacity) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_iter_make_peekable' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_iter_next
lv_result_t lv_iter_next(lv_iter_t* iter, void* elem) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_iter_next' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_iter_peek
lv_result_t lv_iter_peek(lv_iter_t* iter, void* elem) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_iter_peek' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_iter_peek_advance
lv_result_t lv_iter_peek_advance(lv_iter_t* iter) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_iter_peek_advance' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_iter_peek_reset
lv_result_t lv_iter_peek_reset(lv_iter_t* iter) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_iter_peek_reset' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_keyboard_create
lv_obj_t* lv_keyboard_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_keyboard_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_keyboard_def_event_cb
void lv_keyboard_def_event_cb(lv_event_t* e) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_keyboard_def_event_cb' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_keyboard_get_button_text
char* lv_keyboard_get_button_text(lv_obj_t* obj, uint32_t btn_id) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_keyboard_get_button_text' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_keyboard_get_map_array
char** lv_keyboard_get_map_array(lv_obj_t* kb) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_keyboard_get_map_array' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char** */
    return NULL;
}

// Wrapper for: lv_keyboard_get_mode
lv_keyboard_mode_t lv_keyboard_get_mode(lv_obj_t* kb) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_keyboard_get_mode' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_keyboard_mode_t */
    return 0;
}

// Wrapper for: lv_keyboard_get_popovers
bool lv_keyboard_get_popovers(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_keyboard_get_popovers' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_keyboard_get_selected_button
uint32_t lv_keyboard_get_selected_button(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_keyboard_get_selected_button' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_keyboard_get_textarea
lv_obj_t* lv_keyboard_get_textarea(lv_obj_t* kb) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_keyboard_get_textarea' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_keyboard_set_map
void lv_keyboard_set_map(lv_obj_t* kb, lv_keyboard_mode_t mode, char* map[], const lv_buttonmatrix_ctrl_t ctrl_map[]) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(kb);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_keyboard_set_map' called on unknown or unregistered opaque pointer %p.\n", (void*)kb);
        // Check if it's maybe NULL
        if (kb == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_keyboard_set_map (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "keyboard_set_map");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&mode, "lv_keyboard_mode_t", "lv_keyboard_mode_t", false, true, false, false, false, "mode");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&map, "char*[]", "char", false, false, false, false, false, "map");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&ctrl_map, "const lv_buttonmatrix_ctrl_t[]", "", false, true, false, false, false, "ctrl_map");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_keyboard_set_mode
void lv_keyboard_set_mode(lv_obj_t* kb, lv_keyboard_mode_t mode) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(kb);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_keyboard_set_mode' called on unknown or unregistered opaque pointer %p.\n", (void*)kb);
        // Check if it's maybe NULL
        if (kb == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_keyboard_set_mode (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "keyboard_set_mode");
    cJSON *value_json = marshal_value(&mode, "lv_keyboard_mode_t", "lv_keyboard_mode_t", false, true, false, false, false, "mode");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_keyboard_set_popovers
void lv_keyboard_set_popovers(lv_obj_t* kb, bool en) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(kb);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_keyboard_set_popovers' called on unknown or unregistered opaque pointer %p.\n", (void*)kb);
        // Check if it's maybe NULL
        if (kb == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_keyboard_set_popovers (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "keyboard_set_popovers");
    cJSON *value_json = marshal_value(&en, "bool", "bool", false, false, false, false, false, "en");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_keyboard_set_textarea
void lv_keyboard_set_textarea(lv_obj_t* kb, lv_obj_t* ta) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(kb);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_keyboard_set_textarea' called on unknown or unregistered opaque pointer %p.\n", (void*)kb);
        // Check if it's maybe NULL
        if (kb == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_keyboard_set_textarea (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "keyboard_set_textarea");
    cJSON *value_json = marshal_value(&ta, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "ta");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_label_bind_text
lv_observer_t* lv_label_bind_text(lv_obj_t* obj, lv_subject_t* subject, char* fmt) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_label_bind_text' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_observer_t* */
    return NULL;
}

// Wrapper for: lv_label_create
lv_obj_t* lv_label_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_label_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_label_cut_text
void lv_label_cut_text(lv_obj_t* obj, uint32_t pos, uint32_t cnt) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_label_cut_text' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_label_get_letter_on
uint32_t lv_label_get_letter_on(lv_obj_t* obj, struct lv_point_t* pos_in, bool bidi) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_label_get_letter_on' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_label_get_letter_pos
void lv_label_get_letter_pos(lv_obj_t* obj, uint32_t char_id, struct lv_point_t* pos) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_label_get_letter_pos' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_label_get_long_mode
lv_label_long_mode_t lv_label_get_long_mode(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_label_get_long_mode' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_label_long_mode_t */
    return 0;
}

// Wrapper for: lv_label_get_recolor
bool lv_label_get_recolor(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_label_get_recolor' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_label_get_text
char* lv_label_get_text(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_label_get_text' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_label_get_text_selection_end
uint32_t lv_label_get_text_selection_end(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_label_get_text_selection_end' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_label_get_text_selection_start
uint32_t lv_label_get_text_selection_start(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_label_get_text_selection_start' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_label_ins_text
void lv_label_ins_text(lv_obj_t* obj, uint32_t pos, char* txt) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_label_ins_text' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_label_is_char_under_pos
bool lv_label_is_char_under_pos(lv_obj_t* obj, struct lv_point_t* pos) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_label_is_char_under_pos' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_label_set_long_mode
void lv_label_set_long_mode(lv_obj_t* obj, lv_label_long_mode_t long_mode) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_label_set_long_mode' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_label_set_long_mode (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "label_set_long_mode");
    cJSON *value_json = marshal_value(&long_mode, "lv_label_long_mode_t", "lv_label_long_mode_t", false, true, false, false, false, "long_mode");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_label_set_recolor
void lv_label_set_recolor(lv_obj_t* obj, bool en) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_label_set_recolor' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_label_set_recolor (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "label_set_recolor");
    cJSON *value_json = marshal_value(&en, "bool", "bool", false, false, false, false, false, "en");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_label_set_text
void lv_label_set_text(lv_obj_t* obj, char* text) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_label_set_text' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_label_set_text (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "label_set_text");
    cJSON *value_json = marshal_value(&text, "char*", "char", true, false, false, false, false, "text");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_label_set_text_selection_end
void lv_label_set_text_selection_end(lv_obj_t* obj, uint32_t index) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_label_set_text_selection_end' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_label_set_text_selection_end (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "label_set_text_selection_end");
    cJSON *value_json = marshal_value(&index, "uint32_t", "uint32_t", false, false, false, false, false, "index");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_label_set_text_selection_start
void lv_label_set_text_selection_start(lv_obj_t* obj, uint32_t index) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_label_set_text_selection_start' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_label_set_text_selection_start (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "label_set_text_selection_start");
    cJSON *value_json = marshal_value(&index, "uint32_t", "uint32_t", false, false, false, false, false, "index");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_label_set_text_static
void lv_label_set_text_static(lv_obj_t* obj, char* text) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_label_set_text_static' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_label_set_text_static (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "label_set_text_static");
    cJSON *value_json = marshal_value(&text, "char*", "char", true, false, false, false, false, "text");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_layer_bottom
lv_obj_t* lv_layer_bottom(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_layer_bottom' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_layer_init
void lv_layer_init(lv_layer_t* layer) {
    /* Wrapper Type: init */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in init"); assert(false); /* Cannot return if void */ return; }
    const char* type_name = "lv_layer_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "initializer_func", "lv_layer_init");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *init_args_array = cJSON_CreateArray();
    if (!init_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "init_args", init_args_array);
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)layer, type_name, obj_id, new_obj_json);
}

// Wrapper for: lv_layer_reset
void lv_layer_reset(lv_layer_t* layer) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_layer_reset' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_layer_sys
lv_obj_t* lv_layer_sys(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_layer_sys' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_layer_top
lv_obj_t* lv_layer_top(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_layer_top' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_led_create
lv_obj_t* lv_led_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_led_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_led_get_brightness
uint8_t lv_led_get_brightness(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_led_get_brightness' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint8_t */
    return 0;
}

// Wrapper for: lv_led_off
void lv_led_off(lv_obj_t* led) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_led_off' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_led_on
void lv_led_on(lv_obj_t* led) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_led_on' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_led_set_brightness
void lv_led_set_brightness(lv_obj_t* led, uint8_t bright) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(led);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_led_set_brightness' called on unknown or unregistered opaque pointer %p.\n", (void*)led);
        // Check if it's maybe NULL
        if (led == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_led_set_brightness (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "led_set_brightness");
    cJSON *value_json = marshal_value(&bright, "uint8_t", "uint8_t", false, false, false, false, false, "bright");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_led_set_color
void lv_led_set_color(lv_obj_t* led, struct lv_color_t color) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(led);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_led_set_color' called on unknown or unregistered opaque pointer %p.\n", (void*)led);
        // Check if it's maybe NULL
        if (led == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_led_set_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "led_set_color");
    cJSON *value_json = marshal_value(&color, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "color");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_led_toggle
void lv_led_toggle(lv_obj_t* led) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_led_toggle' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_libjpeg_turbo_deinit
void lv_libjpeg_turbo_deinit(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_libjpeg_turbo_deinit' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_libjpeg_turbo_init
void lv_libjpeg_turbo_init(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_libjpeg_turbo_init' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_libpng_deinit
void lv_libpng_deinit(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_libpng_deinit' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_libpng_init
void lv_libpng_init(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_libpng_init' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_list_add_button
lv_obj_t* lv_list_add_button(lv_obj_t* list, void* icon, char* txt) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_list_add_button");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&list, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "list");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&icon, "void*", "void", true, false, false, false, false, "icon");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&txt, "char*", "char", true, false, false, false, false, "txt");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_list_add_text
lv_obj_t* lv_list_add_text(lv_obj_t* list, char* txt) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_list_add_text");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&list, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "list");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&txt, "char*", "char", true, false, false, false, false, "txt");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_list_create
lv_obj_t* lv_list_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_list_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_list_get_button_text
char* lv_list_get_button_text(lv_obj_t* list, lv_obj_t* btn) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_list_get_button_text' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_list_set_button_text
void lv_list_set_button_text(lv_obj_t* list, lv_obj_t* btn, char* txt) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(list);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_list_set_button_text' called on unknown or unregistered opaque pointer %p.\n", (void*)list);
        // Check if it's maybe NULL
        if (list == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_list_set_button_text (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "list_set_button_text");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&btn, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "btn");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&txt, "char*", "char", true, false, false, false, false, "txt");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_ll_chg_list
void lv_ll_chg_list(lv_ll_t* ll_ori_p, lv_ll_t* ll_new_p, void* node, bool head) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_ll_chg_list' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_ll_clear
void lv_ll_clear(lv_ll_t* ll_p) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_ll_clear' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_ll_get_head
void* lv_ll_get_head(lv_ll_t* ll_p) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_ll_get_head' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_ll_get_len
uint32_t lv_ll_get_len(lv_ll_t* ll_p) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_ll_get_len' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_ll_get_next
void* lv_ll_get_next(lv_ll_t* ll_p, void* n_act) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_ll_get_next' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_ll_get_prev
void* lv_ll_get_prev(lv_ll_t* ll_p, void* n_act) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_ll_get_prev' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_ll_get_tail
void* lv_ll_get_tail(lv_ll_t* ll_p) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_ll_get_tail' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_ll_init
void lv_ll_init(lv_ll_t* ll_p, uint32_t node_size) {
    /* Wrapper Type: init */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in init"); assert(false); /* Cannot return if void */ return; }
    const char* type_name = "lv_ll_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "initializer_func", "lv_ll_init");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *init_args_array = cJSON_CreateArray();
    if (!init_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "init_args", init_args_array);
    cJSON* marshaled_arg = marshal_value(&node_size, "uint32_t", "uint32_t", false, false, false, false, false, "node_size");
    if (marshaled_arg) {
        cJSON_AddItemToArray(init_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(init_args_array, cJSON_CreateNull());
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)ll_p, type_name, obj_id, new_obj_json);
}

// Wrapper for: lv_ll_ins_head
void* lv_ll_ins_head(lv_ll_t* ll_p) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_ll_ins_head' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_ll_ins_prev
void* lv_ll_ins_prev(lv_ll_t* ll_p, void* n_act) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_ll_ins_prev' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_ll_ins_tail
void* lv_ll_ins_tail(lv_ll_t* ll_p) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_ll_ins_tail' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_ll_is_empty
bool lv_ll_is_empty(lv_ll_t* ll_p) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_ll_is_empty' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_ll_move_before
void lv_ll_move_before(lv_ll_t* ll_p, void* n_act, void* n_after) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_ll_move_before' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_ll_remove
void lv_ll_remove(lv_ll_t* ll_p, void* node_p) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_ll_remove' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_lodepng_deinit
void lv_lodepng_deinit(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_lodepng_deinit' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_lodepng_init
void lv_lodepng_init(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_lodepng_init' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_map
int32_t lv_map(int32_t x, int32_t min_in, int32_t max_in, int32_t min_out, int32_t max_out) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_map' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_memcmp
int lv_memcmp(void* p1, void* p2, size_t len) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_memcmp' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int */
    return 0;
}

// Wrapper for: lv_memmove
void* lv_memmove(void* dst, void* src, size_t len) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_memmove' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_memzero
void lv_memzero(void* dst, size_t len) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_memzero' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_menu_back_button_is_root
bool lv_menu_back_button_is_root(lv_obj_t* menu, lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_menu_back_button_is_root' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_menu_clear_history
void lv_menu_clear_history(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_menu_clear_history' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_menu_cont_create
lv_obj_t* lv_menu_cont_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_menu_cont_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_menu_create
lv_obj_t* lv_menu_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_menu_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_menu_get_cur_main_page
lv_obj_t* lv_menu_get_cur_main_page(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_menu_get_cur_main_page' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_menu_get_cur_sidebar_page
lv_obj_t* lv_menu_get_cur_sidebar_page(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_menu_get_cur_sidebar_page' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_menu_get_main_header
lv_obj_t* lv_menu_get_main_header(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_menu_get_main_header' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_menu_get_main_header_back_button
lv_obj_t* lv_menu_get_main_header_back_button(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_menu_get_main_header_back_button' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_menu_get_sidebar_header
lv_obj_t* lv_menu_get_sidebar_header(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_menu_get_sidebar_header' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_menu_get_sidebar_header_back_button
lv_obj_t* lv_menu_get_sidebar_header_back_button(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_menu_get_sidebar_header_back_button' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_menu_page_create
lv_obj_t* lv_menu_page_create(lv_obj_t* menu, const char* title) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_menu_page_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&menu, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "menu");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&title, "const char*", "char", true, false, false, false, false, "title");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_menu_section_create
lv_obj_t* lv_menu_section_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_menu_section_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_menu_separator_create
lv_obj_t* lv_menu_separator_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_menu_separator_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_menu_set_load_page_event
void lv_menu_set_load_page_event(lv_obj_t* menu, lv_obj_t* obj, lv_obj_t* page) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(menu);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_menu_set_load_page_event' called on unknown or unregistered opaque pointer %p.\n", (void*)menu);
        // Check if it's maybe NULL
        if (menu == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_menu_set_load_page_event (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "menu_set_load_page_event");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&obj, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "obj");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&page, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "page");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_menu_set_mode_header
void lv_menu_set_mode_header(lv_obj_t* obj, lv_menu_mode_header_t mode) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_menu_set_mode_header' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_menu_set_mode_header (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "menu_set_mode_header");
    cJSON *value_json = marshal_value(&mode, "lv_menu_mode_header_t", "lv_menu_mode_header_t", false, true, false, false, false, "mode");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_menu_set_mode_root_back_button
void lv_menu_set_mode_root_back_button(lv_obj_t* obj, lv_menu_mode_root_back_button_t mode) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_menu_set_mode_root_back_button' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_menu_set_mode_root_back_button (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "menu_set_mode_root_back_button");
    cJSON *value_json = marshal_value(&mode, "lv_menu_mode_root_back_button_t", "lv_menu_mode_root_back_button_t", false, true, false, false, false, "mode");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_menu_set_page
void lv_menu_set_page(lv_obj_t* obj, lv_obj_t* page) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_menu_set_page' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_menu_set_page (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "menu_set_page");
    cJSON *value_json = marshal_value(&page, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "page");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_menu_set_page_title
void lv_menu_set_page_title(lv_obj_t* page, const char* title) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(page);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_menu_set_page_title' called on unknown or unregistered opaque pointer %p.\n", (void*)page);
        // Check if it's maybe NULL
        if (page == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_menu_set_page_title (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "menu_set_page_title");
    cJSON *value_json = marshal_value(&title, "const char*", "char", true, false, false, false, false, "title");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_menu_set_page_title_static
void lv_menu_set_page_title_static(lv_obj_t* page, const char* title) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(page);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_menu_set_page_title_static' called on unknown or unregistered opaque pointer %p.\n", (void*)page);
        // Check if it's maybe NULL
        if (page == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_menu_set_page_title_static (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "menu_set_page_title_static");
    cJSON *value_json = marshal_value(&title, "const char*", "char", true, false, false, false, false, "title");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_menu_set_sidebar_page
void lv_menu_set_sidebar_page(lv_obj_t* obj, lv_obj_t* page) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_menu_set_sidebar_page' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_menu_set_sidebar_page (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "menu_set_sidebar_page");
    cJSON *value_json = marshal_value(&page, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "page");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_msgbox_add_close_button
lv_obj_t* lv_msgbox_add_close_button(lv_obj_t* obj) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_msgbox_add_close_button");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&obj, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "obj");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_msgbox_add_footer_button
lv_obj_t* lv_msgbox_add_footer_button(lv_obj_t* obj, char* text) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_msgbox_add_footer_button");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&obj, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "obj");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&text, "char*", "char", true, false, false, false, false, "text");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_msgbox_add_header_button
lv_obj_t* lv_msgbox_add_header_button(lv_obj_t* obj, void* icon) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_msgbox_add_header_button");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&obj, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "obj");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&icon, "void*", "void", true, false, false, false, false, "icon");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_msgbox_add_text
lv_obj_t* lv_msgbox_add_text(lv_obj_t* obj, char* text) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_msgbox_add_text");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&obj, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "obj");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&text, "char*", "char", true, false, false, false, false, "text");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_msgbox_add_title
lv_obj_t* lv_msgbox_add_title(lv_obj_t* obj, char* title) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_msgbox_add_title");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&obj, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "obj");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&title, "char*", "char", true, false, false, false, false, "title");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_msgbox_close
void lv_msgbox_close(lv_obj_t* mbox) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_msgbox_close' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_msgbox_close_async
void lv_msgbox_close_async(lv_obj_t* mbox) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_msgbox_close_async' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_msgbox_create
lv_obj_t* lv_msgbox_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_msgbox_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_msgbox_get_content
lv_obj_t* lv_msgbox_get_content(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_msgbox_get_content' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_msgbox_get_footer
lv_obj_t* lv_msgbox_get_footer(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_msgbox_get_footer' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_msgbox_get_header
lv_obj_t* lv_msgbox_get_header(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_msgbox_get_header' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_msgbox_get_title
lv_obj_t* lv_msgbox_get_title(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_msgbox_get_title' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_obj_add_flag
void lv_obj_add_flag(lv_obj_t* obj, lv_obj_flag_t f) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_add_flag' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_add_flag (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "lv_obj_add_flag");
    cJSON *value_json = marshal_value(&f, "lv_obj_flag_t", "lv_obj_flag_t", false, true, false, false, false, "f");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_add_state
void lv_obj_add_state(lv_obj_t* obj, lv_state_t state) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_add_state' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_add_state (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "lv_obj_add_state");
    cJSON *value_json = marshal_value(&state, "lv_state_t", "lv_state_t", false, false, false, false, false, "state");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_add_style
void lv_obj_add_style(lv_obj_t* obj, lv_style_t* style, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_add_style' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_add_style (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "lv_obj_add_style");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&style, "lv_style_t*", "lv_style_t", true, false, true, false, true, "style");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_align
void lv_obj_align(lv_obj_t* obj, lv_align_t align, int32_t x_ofs, int32_t y_ofs) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_align' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_align_to
void lv_obj_align_to(lv_obj_t* obj, lv_obj_t* base, lv_align_t align, int32_t x_ofs, int32_t y_ofs) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_align_to' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_allocate_spec_attr
void lv_obj_allocate_spec_attr(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_allocate_spec_attr' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_area_is_visible
bool lv_obj_area_is_visible(lv_obj_t* obj, struct lv_area_t* area) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_area_is_visible' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_obj_assign_id
void lv_obj_assign_id(lv_obj_class_t* class_p, lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_assign_id' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_bind_checked
lv_observer_t* lv_obj_bind_checked(lv_obj_t* obj, lv_subject_t* subject) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_bind_checked' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_observer_t* */
    return NULL;
}

// Wrapper for: lv_obj_bind_flag_if_eq
lv_observer_t* lv_obj_bind_flag_if_eq(lv_obj_t* obj, lv_subject_t* subject, lv_obj_flag_t flag, int32_t ref_value) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_bind_flag_if_eq' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_observer_t* */
    return NULL;
}

// Wrapper for: lv_obj_bind_flag_if_ge
lv_observer_t* lv_obj_bind_flag_if_ge(lv_obj_t* obj, lv_subject_t* subject, lv_obj_flag_t flag, int32_t ref_value) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_bind_flag_if_ge' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_observer_t* */
    return NULL;
}

// Wrapper for: lv_obj_bind_flag_if_gt
lv_observer_t* lv_obj_bind_flag_if_gt(lv_obj_t* obj, lv_subject_t* subject, lv_obj_flag_t flag, int32_t ref_value) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_bind_flag_if_gt' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_observer_t* */
    return NULL;
}

// Wrapper for: lv_obj_bind_flag_if_le
lv_observer_t* lv_obj_bind_flag_if_le(lv_obj_t* obj, lv_subject_t* subject, lv_obj_flag_t flag, int32_t ref_value) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_bind_flag_if_le' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_observer_t* */
    return NULL;
}

// Wrapper for: lv_obj_bind_flag_if_lt
lv_observer_t* lv_obj_bind_flag_if_lt(lv_obj_t* obj, lv_subject_t* subject, lv_obj_flag_t flag, int32_t ref_value) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_bind_flag_if_lt' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_observer_t* */
    return NULL;
}

// Wrapper for: lv_obj_bind_flag_if_not_eq
lv_observer_t* lv_obj_bind_flag_if_not_eq(lv_obj_t* obj, lv_subject_t* subject, lv_obj_flag_t flag, int32_t ref_value) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_bind_flag_if_not_eq' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_observer_t* */
    return NULL;
}

// Wrapper for: lv_obj_bind_state_if_eq
lv_observer_t* lv_obj_bind_state_if_eq(lv_obj_t* obj, lv_subject_t* subject, lv_state_t state, int32_t ref_value) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_bind_state_if_eq' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_observer_t* */
    return NULL;
}

// Wrapper for: lv_obj_bind_state_if_ge
lv_observer_t* lv_obj_bind_state_if_ge(lv_obj_t* obj, lv_subject_t* subject, lv_state_t state, int32_t ref_value) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_bind_state_if_ge' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_observer_t* */
    return NULL;
}

// Wrapper for: lv_obj_bind_state_if_gt
lv_observer_t* lv_obj_bind_state_if_gt(lv_obj_t* obj, lv_subject_t* subject, lv_state_t state, int32_t ref_value) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_bind_state_if_gt' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_observer_t* */
    return NULL;
}

// Wrapper for: lv_obj_bind_state_if_le
lv_observer_t* lv_obj_bind_state_if_le(lv_obj_t* obj, lv_subject_t* subject, lv_state_t state, int32_t ref_value) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_bind_state_if_le' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_observer_t* */
    return NULL;
}

// Wrapper for: lv_obj_bind_state_if_lt
lv_observer_t* lv_obj_bind_state_if_lt(lv_obj_t* obj, lv_subject_t* subject, lv_state_t state, int32_t ref_value) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_bind_state_if_lt' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_observer_t* */
    return NULL;
}

// Wrapper for: lv_obj_bind_state_if_not_eq
lv_observer_t* lv_obj_bind_state_if_not_eq(lv_obj_t* obj, lv_subject_t* subject, lv_state_t state, int32_t ref_value) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_bind_state_if_not_eq' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_observer_t* */
    return NULL;
}

// Wrapper for: lv_obj_calculate_ext_draw_size
int32_t lv_obj_calculate_ext_draw_size(lv_obj_t* obj, lv_part_t part) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_calculate_ext_draw_size' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_calculate_style_text_align
lv_text_align_t lv_obj_calculate_style_text_align(lv_obj_t* obj, lv_part_t part, char* txt) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_calculate_style_text_align' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_text_align_t */
    return 0;
}

// Wrapper for: lv_obj_center
void lv_obj_center(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_center' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_check_type
bool lv_obj_check_type(lv_obj_t* obj, lv_obj_class_t* class_p) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_check_type' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_obj_clean
void lv_obj_clean(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_clean' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_create
lv_obj_t* lv_obj_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_obj_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_obj_delete
void lv_obj_delete(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_delete' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_delete_anim_completed_cb
void lv_obj_delete_anim_completed_cb(lv_anim_t* a) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_delete_anim_completed_cb' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_delete_async
void lv_obj_delete_async(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_delete_async' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_delete_delayed
void lv_obj_delete_delayed(lv_obj_t* obj, uint32_t delay_ms) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_delete_delayed' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_dump_tree
void lv_obj_dump_tree(lv_obj_t* start_obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_dump_tree' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_enable_style_refresh
void lv_obj_enable_style_refresh(bool en) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_enable_style_refresh' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_event_base
lv_result_t lv_obj_event_base(lv_obj_class_t* class_p, lv_event_t* e) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_event_base' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_obj_fade_in
void lv_obj_fade_in(lv_obj_t* obj, uint32_t time, uint32_t delay) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_fade_in' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_fade_out
void lv_obj_fade_out(lv_obj_t* obj, uint32_t time, uint32_t delay) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_fade_out' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_find_by_id
lv_obj_t* lv_obj_find_by_id(lv_obj_t* obj, void* id) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_find_by_id' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_obj_free_id
void lv_obj_free_id(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_free_id' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_get_child
lv_obj_t* lv_obj_get_child(lv_obj_t* obj, int32_t idx) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_child' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_obj_get_child_by_type
lv_obj_t* lv_obj_get_child_by_type(lv_obj_t* obj, int32_t idx, lv_obj_class_t* class_p) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_child_by_type' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_obj_get_child_count
uint32_t lv_obj_get_child_count(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_child_count' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_obj_get_child_count_by_type
uint32_t lv_obj_get_child_count_by_type(lv_obj_t* obj, lv_obj_class_t* class_p) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_child_count_by_type' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_obj_get_class
lv_obj_class_t* lv_obj_get_class(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_class' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_class_t* */
    return NULL;
}

// Wrapper for: lv_obj_get_click_area
void lv_obj_get_click_area(lv_obj_t* obj, struct lv_area_t* area) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_click_area' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_get_content_coords
void lv_obj_get_content_coords(lv_obj_t* obj, struct lv_area_t* area) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_content_coords' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_get_content_height
int32_t lv_obj_get_content_height(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_content_height' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_get_content_width
int32_t lv_obj_get_content_width(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_content_width' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_get_coords
void lv_obj_get_coords(lv_obj_t* obj, struct lv_area_t* coords) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_coords' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_get_event_count
uint32_t lv_obj_get_event_count(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_event_count' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_obj_get_event_dsc
lv_event_dsc_t* lv_obj_get_event_dsc(lv_obj_t* obj, uint32_t index) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_event_dsc' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_event_dsc_t* */
    return NULL;
}

// Wrapper for: lv_obj_get_group
lv_group_t* lv_obj_get_group(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_group' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_group_t* */
    return NULL;
}

// Wrapper for: lv_obj_get_height
int32_t lv_obj_get_height(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_height' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_get_id
void* lv_obj_get_id(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_id' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_obj_get_index
int32_t lv_obj_get_index(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_index' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_get_index_by_type
int32_t lv_obj_get_index_by_type(lv_obj_t* obj, lv_obj_class_t* class_p) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_index_by_type' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_get_local_style_prop
lv_style_res_t lv_obj_get_local_style_prop(lv_obj_t* obj, lv_style_prop_t prop, union lv_style_value_t* value, lv_style_selector_t selector) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_local_style_prop' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_style_res_t */
    return 0;
}

// Wrapper for: lv_obj_get_parent
lv_obj_t* lv_obj_get_parent(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_parent' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_obj_get_screen
lv_obj_t* lv_obj_get_screen(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_screen' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_obj_get_scroll_bottom
int32_t lv_obj_get_scroll_bottom(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_scroll_bottom' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_get_scroll_dir
lv_dir_t lv_obj_get_scroll_dir(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_scroll_dir' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_dir_t */
    return 0;
}

// Wrapper for: lv_obj_get_scroll_end
void lv_obj_get_scroll_end(lv_obj_t* obj, struct lv_point_t* end) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_scroll_end' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_get_scroll_left
int32_t lv_obj_get_scroll_left(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_scroll_left' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_get_scroll_right
int32_t lv_obj_get_scroll_right(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_scroll_right' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_get_scroll_snap_x
lv_scroll_snap_t lv_obj_get_scroll_snap_x(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_scroll_snap_x' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_scroll_snap_t */
    return 0;
}

// Wrapper for: lv_obj_get_scroll_snap_y
lv_scroll_snap_t lv_obj_get_scroll_snap_y(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_scroll_snap_y' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_scroll_snap_t */
    return 0;
}

// Wrapper for: lv_obj_get_scroll_top
int32_t lv_obj_get_scroll_top(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_scroll_top' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_get_scroll_x
int32_t lv_obj_get_scroll_x(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_scroll_x' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_get_scroll_y
int32_t lv_obj_get_scroll_y(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_scroll_y' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_get_scrollbar_area
void lv_obj_get_scrollbar_area(lv_obj_t* obj, struct lv_area_t* hor, struct lv_area_t* ver) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_scrollbar_area' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_get_scrollbar_mode
lv_scrollbar_mode_t lv_obj_get_scrollbar_mode(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_scrollbar_mode' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_scrollbar_mode_t */
    return 0;
}

// Wrapper for: lv_obj_get_self_height
int32_t lv_obj_get_self_height(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_self_height' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_get_self_width
int32_t lv_obj_get_self_width(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_self_width' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_get_sibling
lv_obj_t* lv_obj_get_sibling(lv_obj_t* obj, int32_t idx) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_sibling' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_obj_get_sibling_by_type
lv_obj_t* lv_obj_get_sibling_by_type(lv_obj_t* obj, int32_t idx, lv_obj_class_t* class_p) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_sibling_by_type' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_obj_get_state
lv_state_t lv_obj_get_state(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_state' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_state_t */
    return 0;
}

// Wrapper for: lv_obj_get_transform
lv_matrix_t* lv_obj_get_transform(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_transform' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_matrix_t* */
    return NULL;
}

// Wrapper for: lv_obj_get_transformed_area
void lv_obj_get_transformed_area(lv_obj_t* obj, struct lv_area_t* area, lv_obj_point_transform_flag_t flags) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_transformed_area' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_get_user_data
void* lv_obj_get_user_data(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_user_data' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_obj_get_width
int32_t lv_obj_get_width(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_width' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_get_x
int32_t lv_obj_get_x(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_x' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_get_x2
int32_t lv_obj_get_x2(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_x2' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_get_x_aligned
int32_t lv_obj_get_x_aligned(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_x_aligned' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_get_y
int32_t lv_obj_get_y(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_y' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_get_y2
int32_t lv_obj_get_y2(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_y2' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_get_y_aligned
int32_t lv_obj_get_y_aligned(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_get_y_aligned' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_obj_has_class
bool lv_obj_has_class(lv_obj_t* obj, lv_obj_class_t* class_p) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_has_class' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_obj_has_flag
bool lv_obj_has_flag(lv_obj_t* obj, lv_obj_flag_t f) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_has_flag' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_obj_has_flag_any
bool lv_obj_has_flag_any(lv_obj_t* obj, lv_obj_flag_t f) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_has_flag_any' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_obj_has_state
bool lv_obj_has_state(lv_obj_t* obj, lv_state_t state) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_has_state' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_obj_has_style_prop
bool lv_obj_has_style_prop(lv_obj_t* obj, lv_style_selector_t selector, lv_style_prop_t prop) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_has_style_prop' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_obj_hit_test
bool lv_obj_hit_test(lv_obj_t* obj, struct lv_point_t* point) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_hit_test' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_obj_id_compare
int lv_obj_id_compare(void* id1, void* id2) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_id_compare' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int */
    return 0;
}

// Wrapper for: lv_obj_invalidate
void lv_obj_invalidate(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_invalidate' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_is_editable
bool lv_obj_is_editable(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_is_editable' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_obj_is_group_def
bool lv_obj_is_group_def(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_is_group_def' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_obj_is_layout_positioned
bool lv_obj_is_layout_positioned(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_is_layout_positioned' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_obj_is_scrolling
bool lv_obj_is_scrolling(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_is_scrolling' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_obj_is_valid
bool lv_obj_is_valid(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_is_valid' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_obj_is_visible
bool lv_obj_is_visible(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_is_visible' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_obj_mark_layout_as_dirty
void lv_obj_mark_layout_as_dirty(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_mark_layout_as_dirty' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_move_background
void lv_obj_move_background(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_move_background' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_move_children_by
void lv_obj_move_children_by(lv_obj_t* obj, int32_t x_diff, int32_t y_diff, bool ignore_floating) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_move_children_by' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_move_foreground
void lv_obj_move_foreground(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_move_foreground' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_move_to
void lv_obj_move_to(lv_obj_t* obj, int32_t x, int32_t y) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_move_to' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_move_to_index
void lv_obj_move_to_index(lv_obj_t* obj, int32_t index) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_move_to_index' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_null_on_delete
void lv_obj_null_on_delete(lv_obj_t** obj_ptr) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_null_on_delete' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_readjust_scroll
void lv_obj_readjust_scroll(lv_obj_t* obj, lv_anim_enable_t anim_en) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_readjust_scroll' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_refr_pos
void lv_obj_refr_pos(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_refr_pos' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_refr_size
bool lv_obj_refr_size(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_refr_size' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_obj_refresh_ext_draw_size
void lv_obj_refresh_ext_draw_size(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_refresh_ext_draw_size' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_refresh_self_size
bool lv_obj_refresh_self_size(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_refresh_self_size' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_obj_refresh_style
void lv_obj_refresh_style(lv_obj_t* obj, lv_part_t part, lv_style_prop_t prop) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_refresh_style' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_remove_flag
void lv_obj_remove_flag(lv_obj_t* obj, lv_obj_flag_t f) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_remove_flag' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_remove_flag (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "lv_obj_remove_flag");
    cJSON *value_json = marshal_value(&f, "lv_obj_flag_t", "lv_obj_flag_t", false, true, false, false, false, "f");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_remove_from_subject
void lv_obj_remove_from_subject(lv_obj_t* obj, lv_subject_t* subject) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_remove_from_subject' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_remove_from_subject (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "lv_obj_remove_from_subject");
    cJSON *value_json = marshal_value(&subject, "lv_subject_t*", "lv_subject_t", true, false, true, false, true, "subject");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_remove_local_style_prop
bool lv_obj_remove_local_style_prop(lv_obj_t* obj, lv_style_prop_t prop, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_remove_local_style_prop' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return false;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_remove_local_style_prop (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return false;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "lv_obj_remove_local_style_prop");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&prop, "lv_style_prop_t", "lv_style_prop_t", false, false, false, false, false, "prop");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
    /* Warning: Setter function 'lv_obj_remove_local_style_prop' has non-void return type 'bool'. Returning default. */
    return false;
}

// Wrapper for: lv_obj_remove_state
void lv_obj_remove_state(lv_obj_t* obj, lv_state_t state) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_remove_state' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_remove_state (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "lv_obj_remove_state");
    cJSON *value_json = marshal_value(&state, "lv_state_t", "lv_state_t", false, false, false, false, false, "state");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_remove_style
void lv_obj_remove_style(lv_obj_t* obj, lv_style_t* style, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_remove_style' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_remove_style (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "lv_obj_remove_style");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&style, "lv_style_t*", "lv_style_t", true, false, true, false, true, "style");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_remove_style_all
void lv_obj_remove_style_all(lv_obj_t* obj) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_remove_style_all' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_remove_style_all (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "lv_obj_remove_style_all");
    cJSON *value_json = cJSON_CreateTrue();
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_replace_style
bool lv_obj_replace_style(lv_obj_t* obj, lv_style_t* old_style, lv_style_t* new_style, lv_style_selector_t selector) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_replace_style' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_obj_report_style_change
void lv_obj_report_style_change(lv_style_t* style) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_report_style_change' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_reset_transform
void lv_obj_reset_transform(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_reset_transform' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_scroll_by
void lv_obj_scroll_by(lv_obj_t* obj, int32_t dx, int32_t dy, lv_anim_enable_t anim_en) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_scroll_by' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_scroll_by_bounded
void lv_obj_scroll_by_bounded(lv_obj_t* obj, int32_t dx, int32_t dy, lv_anim_enable_t anim_en) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_scroll_by_bounded' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_scroll_to
void lv_obj_scroll_to(lv_obj_t* obj, int32_t x, int32_t y, lv_anim_enable_t anim_en) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_scroll_to' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_scroll_to_view
void lv_obj_scroll_to_view(lv_obj_t* obj, lv_anim_enable_t anim_en) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_scroll_to_view' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_scroll_to_view_recursive
void lv_obj_scroll_to_view_recursive(lv_obj_t* obj, lv_anim_enable_t anim_en) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_scroll_to_view_recursive' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_scroll_to_x
void lv_obj_scroll_to_x(lv_obj_t* obj, int32_t x, lv_anim_enable_t anim_en) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_scroll_to_x' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_scroll_to_y
void lv_obj_scroll_to_y(lv_obj_t* obj, int32_t y, lv_anim_enable_t anim_en) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_scroll_to_y' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_scrollbar_invalidate
void lv_obj_scrollbar_invalidate(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_scrollbar_invalidate' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_send_event
lv_result_t lv_obj_send_event(lv_obj_t* obj, lv_event_code_t event_code, void* param) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_send_event' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_result_t */
    return 0;
}

// Wrapper for: lv_obj_set_align
void lv_obj_set_align(lv_obj_t* obj, lv_align_t align) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_align' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_align (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "align");
    cJSON *value_json = marshal_value(&align, "lv_align_t", "lv_align_t", false, true, false, false, false, "align");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_content_height
void lv_obj_set_content_height(lv_obj_t* obj, int32_t h) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_content_height' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_content_height (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "content_height");
    cJSON *value_json = marshal_value(&h, "int32_t", "int32_t", false, false, false, false, false, "h");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_content_width
void lv_obj_set_content_width(lv_obj_t* obj, int32_t w) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_content_width' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_content_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "content_width");
    cJSON *value_json = marshal_value(&w, "int32_t", "int32_t", false, false, false, false, false, "w");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_ext_click_area
void lv_obj_set_ext_click_area(lv_obj_t* obj, int32_t size) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_ext_click_area' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_ext_click_area (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "ext_click_area");
    cJSON *value_json = marshal_value(&size, "int32_t", "int32_t", false, false, false, false, false, "size");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_flag
void lv_obj_set_flag(lv_obj_t* obj, lv_obj_flag_t f, bool v) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_flag' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_flag (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "flag");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&f, "lv_obj_flag_t", "lv_obj_flag_t", false, true, false, false, false, "f");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&v, "bool", "bool", false, false, false, false, false, "v");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_flex_align
void lv_obj_set_flex_align(lv_obj_t* obj, lv_flex_align_t main_place, lv_flex_align_t cross_place, lv_flex_align_t track_cross_place) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_flex_align' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_flex_align (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "flex_align");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&main_place, "lv_flex_align_t", "lv_flex_align_t", false, true, false, false, false, "main_place");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&cross_place, "lv_flex_align_t", "lv_flex_align_t", false, true, false, false, false, "cross_place");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&track_cross_place, "lv_flex_align_t", "lv_flex_align_t", false, true, false, false, false, "track_cross_place");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_flex_flow
void lv_obj_set_flex_flow(lv_obj_t* obj, lv_flex_flow_t flow) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_flex_flow' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_flex_flow (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "flex_flow");
    cJSON *value_json = marshal_value(&flow, "lv_flex_flow_t", "lv_flex_flow_t", false, true, false, false, false, "flow");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_flex_grow
void lv_obj_set_flex_grow(lv_obj_t* obj, uint8_t grow) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_flex_grow' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_flex_grow (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "flex_grow");
    cJSON *value_json = marshal_value(&grow, "uint8_t", "uint8_t", false, false, false, false, false, "grow");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_grid_align
void lv_obj_set_grid_align(lv_obj_t* obj, lv_grid_align_t column_align, lv_grid_align_t row_align) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_grid_align' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_grid_align (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "grid_align");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&column_align, "lv_grid_align_t", "lv_grid_align_t", false, true, false, false, false, "column_align");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&row_align, "lv_grid_align_t", "lv_grid_align_t", false, true, false, false, false, "row_align");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_grid_cell
void lv_obj_set_grid_cell(lv_obj_t* obj, lv_grid_align_t column_align, int32_t col_pos, int32_t col_span, lv_grid_align_t row_align, int32_t row_pos, int32_t row_span) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_grid_cell' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_grid_cell (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "grid_cell");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&column_align, "lv_grid_align_t", "lv_grid_align_t", false, true, false, false, false, "column_align");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&col_pos, "int32_t", "int32_t", false, false, false, false, false, "col_pos");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&col_span, "int32_t", "int32_t", false, false, false, false, false, "col_span");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_3 = marshal_value(&row_align, "lv_grid_align_t", "lv_grid_align_t", false, true, false, false, false, "row_align");
        if (val_3) cJSON_AddItemToArray(values_array, val_3); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_4 = marshal_value(&row_pos, "int32_t", "int32_t", false, false, false, false, false, "row_pos");
        if (val_4) cJSON_AddItemToArray(values_array, val_4); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_5 = marshal_value(&row_span, "int32_t", "int32_t", false, false, false, false, false, "row_span");
        if (val_5) cJSON_AddItemToArray(values_array, val_5); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_grid_dsc_array
void lv_obj_set_grid_dsc_array(lv_obj_t* obj, const int32_t col_dsc[], const int32_t row_dsc[]) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_grid_dsc_array' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_grid_dsc_array (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "grid_dsc_array");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&col_dsc, "const int32_t[]", "", false, false, false, false, false, "col_dsc");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&row_dsc, "const int32_t[]", "", false, false, false, false, false, "row_dsc");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_height
void lv_obj_set_height(lv_obj_t* obj, int32_t h) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_height' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_height (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "height");
    cJSON *value_json = marshal_value(&h, "int32_t", "int32_t", false, false, false, false, false, "h");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_id
void lv_obj_set_id(lv_obj_t* obj, void* id) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_id' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_id (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "id");
    cJSON *value_json = marshal_value(&id, "void*", "void", true, false, false, false, false, "id");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_layout
void lv_obj_set_layout(lv_obj_t* obj, uint32_t layout) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_layout' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_layout (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "layout");
    cJSON *value_json = marshal_value(&layout, "uint32_t", "uint32_t", false, false, false, false, false, "layout");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_local_style_prop
void lv_obj_set_local_style_prop(lv_obj_t* obj, lv_style_prop_t prop, union lv_style_value_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_local_style_prop' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_local_style_prop (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "local_style_prop");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&prop, "lv_style_prop_t", "lv_style_prop_t", false, false, false, false, false, "prop");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&value, "union lv_style_value_t", "lv_style_value_t", false, false, false, true, false, "value");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_parent
void lv_obj_set_parent(lv_obj_t* obj, lv_obj_t* parent) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_parent' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_parent (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "parent");
    cJSON *value_json = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_pos
void lv_obj_set_pos(lv_obj_t* obj, int32_t x, int32_t y) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_pos' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_pos (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "pos");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&x, "int32_t", "int32_t", false, false, false, false, false, "x");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&y, "int32_t", "int32_t", false, false, false, false, false, "y");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_scroll_dir
void lv_obj_set_scroll_dir(lv_obj_t* obj, lv_dir_t dir) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_scroll_dir' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_scroll_dir (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scroll_dir");
    cJSON *value_json = marshal_value(&dir, "lv_dir_t", "lv_dir_t", false, true, false, false, false, "dir");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_scroll_snap_x
void lv_obj_set_scroll_snap_x(lv_obj_t* obj, lv_scroll_snap_t align) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_scroll_snap_x' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_scroll_snap_x (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scroll_snap_x");
    cJSON *value_json = marshal_value(&align, "lv_scroll_snap_t", "lv_scroll_snap_t", false, true, false, false, false, "align");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_scroll_snap_y
void lv_obj_set_scroll_snap_y(lv_obj_t* obj, lv_scroll_snap_t align) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_scroll_snap_y' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_scroll_snap_y (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scroll_snap_y");
    cJSON *value_json = marshal_value(&align, "lv_scroll_snap_t", "lv_scroll_snap_t", false, true, false, false, false, "align");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_scrollbar_mode
void lv_obj_set_scrollbar_mode(lv_obj_t* obj, lv_scrollbar_mode_t mode) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_scrollbar_mode' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_scrollbar_mode (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scrollbar_mode");
    cJSON *value_json = marshal_value(&mode, "lv_scrollbar_mode_t", "lv_scrollbar_mode_t", false, true, false, false, false, "mode");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_size
void lv_obj_set_size(lv_obj_t* obj, int32_t w, int32_t h) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_size' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_size (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "size");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&w, "int32_t", "int32_t", false, false, false, false, false, "w");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&h, "int32_t", "int32_t", false, false, false, false, false, "h");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_state
void lv_obj_set_state(lv_obj_t* obj, lv_state_t state, bool v) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_state' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_state (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "state");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&state, "lv_state_t", "lv_state_t", false, false, false, false, false, "state");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&v, "bool", "bool", false, false, false, false, false, "v");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_align
void lv_obj_set_style_align(lv_obj_t* obj, lv_align_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_align' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_align (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_align");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_align_t", "lv_align_t", false, true, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_anim
void lv_obj_set_style_anim(lv_obj_t* obj, lv_anim_t* value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_anim' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_anim (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_anim");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_anim_t*", "lv_anim_t", true, false, false, false, true, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_anim_duration
void lv_obj_set_style_anim_duration(lv_obj_t* obj, uint32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_anim_duration' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_anim_duration (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_anim_duration");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "uint32_t", "uint32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_arc_color
void lv_obj_set_style_arc_color(lv_obj_t* obj, struct lv_color_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_arc_color' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_arc_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_arc_color");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_arc_image_src
void lv_obj_set_style_arc_image_src(lv_obj_t* obj, void* value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_arc_image_src' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_arc_image_src (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_arc_image_src");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "void*", "void", true, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_arc_opa
void lv_obj_set_style_arc_opa(lv_obj_t* obj, lv_opa_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_arc_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_arc_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_arc_opa");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_arc_rounded
void lv_obj_set_style_arc_rounded(lv_obj_t* obj, bool value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_arc_rounded' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_arc_rounded (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_arc_rounded");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "bool", "bool", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_arc_width
void lv_obj_set_style_arc_width(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_arc_width' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_arc_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_arc_width");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_base_dir
void lv_obj_set_style_base_dir(lv_obj_t* obj, lv_base_dir_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_base_dir' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_base_dir (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_base_dir");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_base_dir_t", "lv_base_dir_t", false, true, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_bg_color
void lv_obj_set_style_bg_color(lv_obj_t* obj, struct lv_color_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_bg_color' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_bg_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_bg_color");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_bg_grad
void lv_obj_set_style_bg_grad(lv_obj_t* obj, struct lv_grad_dsc_t* value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_bg_grad' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_bg_grad (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_bg_grad");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "struct lv_grad_dsc_t*", "lv_grad_dsc_t", true, false, true, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_bg_grad_color
void lv_obj_set_style_bg_grad_color(lv_obj_t* obj, struct lv_color_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_bg_grad_color' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_bg_grad_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_bg_grad_color");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_bg_grad_dir
void lv_obj_set_style_bg_grad_dir(lv_obj_t* obj, lv_grad_dir_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_bg_grad_dir' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_bg_grad_dir (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_bg_grad_dir");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_grad_dir_t", "lv_grad_dir_t", false, true, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_bg_grad_opa
void lv_obj_set_style_bg_grad_opa(lv_obj_t* obj, lv_opa_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_bg_grad_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_bg_grad_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_bg_grad_opa");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_bg_grad_stop
void lv_obj_set_style_bg_grad_stop(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_bg_grad_stop' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_bg_grad_stop (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_bg_grad_stop");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_bg_image_opa
void lv_obj_set_style_bg_image_opa(lv_obj_t* obj, lv_opa_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_bg_image_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_bg_image_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_bg_image_opa");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_bg_image_recolor
void lv_obj_set_style_bg_image_recolor(lv_obj_t* obj, struct lv_color_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_bg_image_recolor' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_bg_image_recolor (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_bg_image_recolor");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_bg_image_recolor_opa
void lv_obj_set_style_bg_image_recolor_opa(lv_obj_t* obj, lv_opa_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_bg_image_recolor_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_bg_image_recolor_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_bg_image_recolor_opa");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_bg_image_src
void lv_obj_set_style_bg_image_src(lv_obj_t* obj, void* value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_bg_image_src' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_bg_image_src (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_bg_image_src");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "void*", "void", true, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_bg_image_tiled
void lv_obj_set_style_bg_image_tiled(lv_obj_t* obj, bool value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_bg_image_tiled' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_bg_image_tiled (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_bg_image_tiled");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "bool", "bool", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_bg_main_opa
void lv_obj_set_style_bg_main_opa(lv_obj_t* obj, lv_opa_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_bg_main_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_bg_main_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_bg_main_opa");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_bg_main_stop
void lv_obj_set_style_bg_main_stop(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_bg_main_stop' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_bg_main_stop (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_bg_main_stop");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_bg_opa
void lv_obj_set_style_bg_opa(lv_obj_t* obj, lv_opa_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_bg_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_bg_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_bg_opa");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_bitmap_mask_src
void lv_obj_set_style_bitmap_mask_src(lv_obj_t* obj, void* value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_bitmap_mask_src' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_bitmap_mask_src (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_bitmap_mask_src");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "void*", "void", true, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_blend_mode
void lv_obj_set_style_blend_mode(lv_obj_t* obj, lv_blend_mode_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_blend_mode' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_blend_mode (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_blend_mode");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_blend_mode_t", "lv_blend_mode_t", false, true, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_border_color
void lv_obj_set_style_border_color(lv_obj_t* obj, struct lv_color_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_border_color' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_border_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_border_color");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_border_opa
void lv_obj_set_style_border_opa(lv_obj_t* obj, lv_opa_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_border_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_border_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_border_opa");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_border_post
void lv_obj_set_style_border_post(lv_obj_t* obj, bool value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_border_post' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_border_post (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_border_post");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "bool", "bool", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_border_side
void lv_obj_set_style_border_side(lv_obj_t* obj, lv_border_side_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_border_side' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_border_side (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_border_side");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_border_side_t", "lv_border_side_t", false, true, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_border_width
void lv_obj_set_style_border_width(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_border_width' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_border_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_border_width");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_clip_corner
void lv_obj_set_style_clip_corner(lv_obj_t* obj, bool value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_clip_corner' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_clip_corner (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_clip_corner");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "bool", "bool", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_color_filter_dsc
void lv_obj_set_style_color_filter_dsc(lv_obj_t* obj, lv_color_filter_dsc_t* value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_color_filter_dsc' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_color_filter_dsc (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_color_filter_dsc");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_color_filter_dsc_t*", "lv_color_filter_dsc_t", true, false, false, false, true, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_color_filter_opa
void lv_obj_set_style_color_filter_opa(lv_obj_t* obj, lv_opa_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_color_filter_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_color_filter_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_color_filter_opa");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_flex_cross_place
void lv_obj_set_style_flex_cross_place(lv_obj_t* obj, lv_flex_align_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_flex_cross_place' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_flex_cross_place (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_flex_cross_place");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_flex_align_t", "lv_flex_align_t", false, true, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_flex_flow
void lv_obj_set_style_flex_flow(lv_obj_t* obj, lv_flex_flow_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_flex_flow' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_flex_flow (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_flex_flow");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_flex_flow_t", "lv_flex_flow_t", false, true, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_flex_grow
void lv_obj_set_style_flex_grow(lv_obj_t* obj, uint8_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_flex_grow' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_flex_grow (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_flex_grow");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "uint8_t", "uint8_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_flex_main_place
void lv_obj_set_style_flex_main_place(lv_obj_t* obj, lv_flex_align_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_flex_main_place' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_flex_main_place (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_flex_main_place");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_flex_align_t", "lv_flex_align_t", false, true, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_flex_track_place
void lv_obj_set_style_flex_track_place(lv_obj_t* obj, lv_flex_align_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_flex_track_place' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_flex_track_place (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_flex_track_place");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_flex_align_t", "lv_flex_align_t", false, true, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_grid_cell_column_pos
void lv_obj_set_style_grid_cell_column_pos(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_grid_cell_column_pos' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_grid_cell_column_pos (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_grid_cell_column_pos");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_grid_cell_column_span
void lv_obj_set_style_grid_cell_column_span(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_grid_cell_column_span' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_grid_cell_column_span (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_grid_cell_column_span");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_grid_cell_row_pos
void lv_obj_set_style_grid_cell_row_pos(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_grid_cell_row_pos' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_grid_cell_row_pos (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_grid_cell_row_pos");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_grid_cell_row_span
void lv_obj_set_style_grid_cell_row_span(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_grid_cell_row_span' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_grid_cell_row_span (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_grid_cell_row_span");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_grid_cell_x_align
void lv_obj_set_style_grid_cell_x_align(lv_obj_t* obj, lv_grid_align_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_grid_cell_x_align' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_grid_cell_x_align (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_grid_cell_x_align");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_grid_align_t", "lv_grid_align_t", false, true, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_grid_cell_y_align
void lv_obj_set_style_grid_cell_y_align(lv_obj_t* obj, lv_grid_align_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_grid_cell_y_align' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_grid_cell_y_align (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_grid_cell_y_align");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_grid_align_t", "lv_grid_align_t", false, true, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_grid_column_align
void lv_obj_set_style_grid_column_align(lv_obj_t* obj, lv_grid_align_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_grid_column_align' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_grid_column_align (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_grid_column_align");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_grid_align_t", "lv_grid_align_t", false, true, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_grid_column_dsc_array
void lv_obj_set_style_grid_column_dsc_array(lv_obj_t* obj, int32_t* value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_grid_column_dsc_array' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_grid_column_dsc_array (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_grid_column_dsc_array");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t*", "int32_t", true, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_grid_row_align
void lv_obj_set_style_grid_row_align(lv_obj_t* obj, lv_grid_align_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_grid_row_align' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_grid_row_align (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_grid_row_align");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_grid_align_t", "lv_grid_align_t", false, true, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_grid_row_dsc_array
void lv_obj_set_style_grid_row_dsc_array(lv_obj_t* obj, int32_t* value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_grid_row_dsc_array' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_grid_row_dsc_array (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_grid_row_dsc_array");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t*", "int32_t", true, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_height
void lv_obj_set_style_height(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_height' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_height (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_height");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_image_opa
void lv_obj_set_style_image_opa(lv_obj_t* obj, lv_opa_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_image_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_image_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_image_opa");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_image_recolor
void lv_obj_set_style_image_recolor(lv_obj_t* obj, struct lv_color_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_image_recolor' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_image_recolor (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_image_recolor");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_image_recolor_opa
void lv_obj_set_style_image_recolor_opa(lv_obj_t* obj, lv_opa_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_image_recolor_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_image_recolor_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_image_recolor_opa");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_layout
void lv_obj_set_style_layout(lv_obj_t* obj, uint16_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_layout' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_layout (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_layout");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "uint16_t", "uint16_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_length
void lv_obj_set_style_length(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_length' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_length (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_length");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_line_color
void lv_obj_set_style_line_color(lv_obj_t* obj, struct lv_color_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_line_color' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_line_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_line_color");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_line_dash_gap
void lv_obj_set_style_line_dash_gap(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_line_dash_gap' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_line_dash_gap (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_line_dash_gap");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_line_dash_width
void lv_obj_set_style_line_dash_width(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_line_dash_width' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_line_dash_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_line_dash_width");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_line_opa
void lv_obj_set_style_line_opa(lv_obj_t* obj, lv_opa_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_line_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_line_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_line_opa");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_line_rounded
void lv_obj_set_style_line_rounded(lv_obj_t* obj, bool value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_line_rounded' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_line_rounded (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_line_rounded");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "bool", "bool", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_line_width
void lv_obj_set_style_line_width(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_line_width' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_line_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_line_width");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_margin_all
void lv_obj_set_style_margin_all(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_margin_all' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_margin_all (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_margin_all");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_margin_bottom
void lv_obj_set_style_margin_bottom(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_margin_bottom' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_margin_bottom (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_margin_bottom");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_margin_hor
void lv_obj_set_style_margin_hor(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_margin_hor' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_margin_hor (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_margin_hor");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_margin_left
void lv_obj_set_style_margin_left(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_margin_left' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_margin_left (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_margin_left");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_margin_right
void lv_obj_set_style_margin_right(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_margin_right' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_margin_right (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_margin_right");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_margin_top
void lv_obj_set_style_margin_top(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_margin_top' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_margin_top (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_margin_top");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_margin_ver
void lv_obj_set_style_margin_ver(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_margin_ver' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_margin_ver (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_margin_ver");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_max_height
void lv_obj_set_style_max_height(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_max_height' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_max_height (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_max_height");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_max_width
void lv_obj_set_style_max_width(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_max_width' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_max_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_max_width");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_min_height
void lv_obj_set_style_min_height(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_min_height' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_min_height (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_min_height");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_min_width
void lv_obj_set_style_min_width(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_min_width' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_min_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_min_width");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_opa
void lv_obj_set_style_opa(lv_obj_t* obj, lv_opa_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_opa");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_opa_layered
void lv_obj_set_style_opa_layered(lv_obj_t* obj, lv_opa_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_opa_layered' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_opa_layered (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_opa_layered");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_outline_color
void lv_obj_set_style_outline_color(lv_obj_t* obj, struct lv_color_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_outline_color' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_outline_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_outline_color");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_outline_opa
void lv_obj_set_style_outline_opa(lv_obj_t* obj, lv_opa_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_outline_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_outline_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_outline_opa");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_outline_pad
void lv_obj_set_style_outline_pad(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_outline_pad' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_outline_pad (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_outline_pad");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_outline_width
void lv_obj_set_style_outline_width(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_outline_width' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_outline_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_outline_width");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_pad_all
void lv_obj_set_style_pad_all(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_pad_all' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_pad_all (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_pad_all");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_pad_bottom
void lv_obj_set_style_pad_bottom(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_pad_bottom' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_pad_bottom (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_pad_bottom");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_pad_column
void lv_obj_set_style_pad_column(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_pad_column' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_pad_column (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_pad_column");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_pad_gap
void lv_obj_set_style_pad_gap(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_pad_gap' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_pad_gap (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_pad_gap");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_pad_hor
void lv_obj_set_style_pad_hor(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_pad_hor' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_pad_hor (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_pad_hor");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_pad_left
void lv_obj_set_style_pad_left(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_pad_left' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_pad_left (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_pad_left");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_pad_radial
void lv_obj_set_style_pad_radial(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_pad_radial' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_pad_radial (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_pad_radial");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_pad_right
void lv_obj_set_style_pad_right(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_pad_right' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_pad_right (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_pad_right");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_pad_row
void lv_obj_set_style_pad_row(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_pad_row' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_pad_row (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_pad_row");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_pad_top
void lv_obj_set_style_pad_top(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_pad_top' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_pad_top (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_pad_top");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_pad_ver
void lv_obj_set_style_pad_ver(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_pad_ver' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_pad_ver (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_pad_ver");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_radial_offset
void lv_obj_set_style_radial_offset(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_radial_offset' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_radial_offset (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_radial_offset");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_radius
void lv_obj_set_style_radius(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_radius' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_radius (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_radius");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_recolor
void lv_obj_set_style_recolor(lv_obj_t* obj, struct lv_color_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_recolor' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_recolor (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_recolor");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_recolor_opa
void lv_obj_set_style_recolor_opa(lv_obj_t* obj, lv_opa_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_recolor_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_recolor_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_recolor_opa");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_rotary_sensitivity
void lv_obj_set_style_rotary_sensitivity(lv_obj_t* obj, uint32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_rotary_sensitivity' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_rotary_sensitivity (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_rotary_sensitivity");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "uint32_t", "uint32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_shadow_color
void lv_obj_set_style_shadow_color(lv_obj_t* obj, struct lv_color_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_shadow_color' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_shadow_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_shadow_color");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_shadow_offset_x
void lv_obj_set_style_shadow_offset_x(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_shadow_offset_x' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_shadow_offset_x (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_shadow_offset_x");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_shadow_offset_y
void lv_obj_set_style_shadow_offset_y(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_shadow_offset_y' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_shadow_offset_y (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_shadow_offset_y");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_shadow_opa
void lv_obj_set_style_shadow_opa(lv_obj_t* obj, lv_opa_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_shadow_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_shadow_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_shadow_opa");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_shadow_spread
void lv_obj_set_style_shadow_spread(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_shadow_spread' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_shadow_spread (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_shadow_spread");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_shadow_width
void lv_obj_set_style_shadow_width(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_shadow_width' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_shadow_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_shadow_width");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_size
void lv_obj_set_style_size(lv_obj_t* obj, int32_t width, int32_t height, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_size' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_size (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_size");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&width, "int32_t", "int32_t", false, false, false, false, false, "width");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&height, "int32_t", "int32_t", false, false, false, false, false, "height");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_text_align
void lv_obj_set_style_text_align(lv_obj_t* obj, lv_text_align_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_text_align' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_text_align (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_text_align");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_text_align_t", "lv_text_align_t", false, true, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_text_color
void lv_obj_set_style_text_color(lv_obj_t* obj, struct lv_color_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_text_color' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_text_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_text_color");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_text_decor
void lv_obj_set_style_text_decor(lv_obj_t* obj, lv_text_decor_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_text_decor' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_text_decor (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_text_decor");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_text_decor_t", "lv_text_decor_t", false, true, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_text_font
void lv_obj_set_style_text_font(lv_obj_t* obj, lv_font_t* value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_text_font' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_text_font (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_text_font");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_font_t*", "lv_font_t", true, false, false, false, true, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_text_letter_space
void lv_obj_set_style_text_letter_space(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_text_letter_space' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_text_letter_space (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_text_letter_space");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_text_line_space
void lv_obj_set_style_text_line_space(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_text_line_space' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_text_line_space (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_text_line_space");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_text_opa
void lv_obj_set_style_text_opa(lv_obj_t* obj, lv_opa_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_text_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_text_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_text_opa");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_text_outline_stroke_color
void lv_obj_set_style_text_outline_stroke_color(lv_obj_t* obj, struct lv_color_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_text_outline_stroke_color' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_text_outline_stroke_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_text_outline_stroke_color");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_text_outline_stroke_opa
void lv_obj_set_style_text_outline_stroke_opa(lv_obj_t* obj, lv_opa_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_text_outline_stroke_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_text_outline_stroke_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_text_outline_stroke_opa");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_text_outline_stroke_width
void lv_obj_set_style_text_outline_stroke_width(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_text_outline_stroke_width' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_text_outline_stroke_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_text_outline_stroke_width");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_transform_height
void lv_obj_set_style_transform_height(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_transform_height' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_transform_height (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_transform_height");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_transform_pivot_x
void lv_obj_set_style_transform_pivot_x(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_transform_pivot_x' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_transform_pivot_x (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_transform_pivot_x");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_transform_pivot_y
void lv_obj_set_style_transform_pivot_y(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_transform_pivot_y' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_transform_pivot_y (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_transform_pivot_y");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_transform_rotation
void lv_obj_set_style_transform_rotation(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_transform_rotation' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_transform_rotation (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_transform_rotation");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_transform_scale
void lv_obj_set_style_transform_scale(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_transform_scale' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_transform_scale (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_transform_scale");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_transform_scale_x
void lv_obj_set_style_transform_scale_x(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_transform_scale_x' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_transform_scale_x (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_transform_scale_x");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_transform_scale_y
void lv_obj_set_style_transform_scale_y(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_transform_scale_y' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_transform_scale_y (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_transform_scale_y");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_transform_skew_x
void lv_obj_set_style_transform_skew_x(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_transform_skew_x' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_transform_skew_x (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_transform_skew_x");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_transform_skew_y
void lv_obj_set_style_transform_skew_y(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_transform_skew_y' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_transform_skew_y (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_transform_skew_y");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_transform_width
void lv_obj_set_style_transform_width(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_transform_width' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_transform_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_transform_width");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_transition
void lv_obj_set_style_transition(lv_obj_t* obj, lv_style_transition_dsc_t* value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_transition' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_transition (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_transition");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "lv_style_transition_dsc_t*", "lv_style_transition_dsc_t", true, false, true, false, true, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_translate_radial
void lv_obj_set_style_translate_radial(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_translate_radial' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_translate_radial (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_translate_radial");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_translate_x
void lv_obj_set_style_translate_x(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_translate_x' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_translate_x (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_translate_x");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_translate_y
void lv_obj_set_style_translate_y(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_translate_y' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_translate_y (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_translate_y");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_width
void lv_obj_set_style_width(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_width' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_width");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_x
void lv_obj_set_style_x(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_x' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_x (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_x");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_style_y
void lv_obj_set_style_y(lv_obj_t* obj, int32_t value, lv_style_selector_t selector) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_style_y' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_style_y (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_y");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&selector, "lv_style_selector_t", "lv_style_selector_t", false, false, false, false, false, "selector");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_transform
void lv_obj_set_transform(lv_obj_t* obj, lv_matrix_t* matrix) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_transform' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_transform (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "transform");
    cJSON *value_json = marshal_value(&matrix, "lv_matrix_t*", "lv_matrix_t", true, false, false, false, true, "matrix");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_user_data
void lv_obj_set_user_data(lv_obj_t* obj, void* user_data) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_user_data' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_user_data (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "user_data");
    cJSON *value_json = marshal_value(&user_data, "void*", "void", true, false, false, false, false, "user_data");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_width
void lv_obj_set_width(lv_obj_t* obj, int32_t w) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_width' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "width");
    cJSON *value_json = marshal_value(&w, "int32_t", "int32_t", false, false, false, false, false, "w");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_x
void lv_obj_set_x(lv_obj_t* obj, int32_t x) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_x' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_x (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "x");
    cJSON *value_json = marshal_value(&x, "int32_t", "int32_t", false, false, false, false, false, "x");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_set_y
void lv_obj_set_y(lv_obj_t* obj, int32_t y) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_set_y' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_set_y (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "y");
    cJSON *value_json = marshal_value(&y, "int32_t", "int32_t", false, false, false, false, false, "y");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_stop_scroll_anim
void lv_obj_stop_scroll_anim(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_stop_scroll_anim' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_stringify_id
char* lv_obj_stringify_id(lv_obj_t* obj, char* buf, uint32_t len) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_stringify_id' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_obj_style_apply_color_filter
union lv_style_value_t lv_obj_style_apply_color_filter(lv_obj_t* obj, lv_part_t part, union lv_style_value_t v) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_style_apply_color_filter' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type union lv_style_value_t */
    return 0;
}

// Wrapper for: lv_obj_style_apply_recolor
struct lv_color32_t lv_obj_style_apply_recolor(lv_obj_t* obj, lv_part_t part, struct lv_color32_t color) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_style_apply_recolor' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color32_t */
    return 0;
}

// Wrapper for: lv_obj_style_get_selector_part
lv_part_t lv_obj_style_get_selector_part(lv_style_selector_t selector) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_style_get_selector_part' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_part_t */
    return 0;
}

// Wrapper for: lv_obj_style_get_selector_state
lv_state_t lv_obj_style_get_selector_state(lv_style_selector_t selector) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_style_get_selector_state' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_state_t */
    return 0;
}

// Wrapper for: lv_obj_swap
void lv_obj_swap(lv_obj_t* obj1, lv_obj_t* obj2) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_swap' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_transform_point
void lv_obj_transform_point(lv_obj_t* obj, struct lv_point_t* p, lv_obj_point_transform_flag_t flags) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_transform_point' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_transform_point_array
void lv_obj_transform_point_array(lv_obj_t* obj, lv_point_t points[], size_t count, lv_obj_point_transform_flag_t flags) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_obj_transform_point_array' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_obj_update_layout
void lv_obj_update_layout(lv_obj_t* obj) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_update_layout' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_update_layout (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "lv_obj_update_layout");
    cJSON *value_json = cJSON_CreateTrue();
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_obj_update_snap
void lv_obj_update_snap(lv_obj_t* obj, lv_anim_enable_t anim_en) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_obj_update_snap' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_obj_update_snap (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "lv_obj_update_snap");
    cJSON *value_json = marshal_value(&anim_en, "lv_anim_enable_t", "lv_anim_enable_t", false, false, false, false, false, "anim_en");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_objid_builtin_destroy
void lv_objid_builtin_destroy(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_objid_builtin_destroy' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_observer_get_target
void* lv_observer_get_target(lv_observer_t* observer) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_observer_get_target' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_observer_get_target_obj
lv_obj_t* lv_observer_get_target_obj(lv_observer_t* observer) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_observer_get_target_obj' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_observer_get_user_data
void* lv_observer_get_user_data(lv_observer_t* observer) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_observer_get_user_data' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_observer_remove
void lv_observer_remove(lv_observer_t* observer) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_observer_remove' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_palette_darken
struct lv_color_t lv_palette_darken(lv_palette_t p, uint8_t lvl) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_palette_darken' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_t */
    return 0;
}

// Wrapper for: lv_palette_lighten
struct lv_color_t lv_palette_lighten(lv_palette_t p, uint8_t lvl) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_palette_lighten' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_t */
    return 0;
}

// Wrapper for: lv_palette_main
struct lv_color_t lv_palette_main(lv_palette_t p) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_palette_main' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_t */
    return 0;
}

// Wrapper for: lv_pct
int32_t lv_pct(int32_t x) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_pct' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_pct_to_px
int32_t lv_pct_to_px(int32_t v, int32_t base) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_pct_to_px' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_point_array_transform
void lv_point_array_transform(struct lv_point_t* points, size_t count, int32_t angle, int32_t scale_x, int32_t scale_y, struct lv_point_t* pivot, bool zoom_first) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_point_array_transform' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_point_set
void lv_point_set(struct lv_point_t* p, int32_t x, int32_t y) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_point_set' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_point_swap
void lv_point_swap(struct lv_point_t* p1, struct lv_point_t* p2) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_point_swap' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_point_to_precise
struct lv_point_precise_t lv_point_to_precise(struct lv_point_t* p) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_point_to_precise' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_point_precise_t */
    return 0;
}

// Wrapper for: lv_point_transform
void lv_point_transform(struct lv_point_t* point, int32_t angle, int32_t scale_x, int32_t scale_y, struct lv_point_t* pivot, bool zoom_first) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_point_transform' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_pow
int64_t lv_pow(int64_t base, int8_t exp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_pow' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int64_t */
    return 0;
}

// Wrapper for: lv_qrcode_create
lv_obj_t* lv_qrcode_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_qrcode_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_qrcode_set_dark_color
void lv_qrcode_set_dark_color(lv_obj_t* obj, struct lv_color_t color) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_qrcode_set_dark_color' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_qrcode_set_dark_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "qrcode_set_dark_color");
    cJSON *value_json = marshal_value(&color, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "color");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_qrcode_set_light_color
void lv_qrcode_set_light_color(lv_obj_t* obj, struct lv_color_t color) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_qrcode_set_light_color' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_qrcode_set_light_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "qrcode_set_light_color");
    cJSON *value_json = marshal_value(&color, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "color");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_qrcode_set_size
void lv_qrcode_set_size(lv_obj_t* obj, int32_t size) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_qrcode_set_size' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_qrcode_set_size (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "qrcode_set_size");
    cJSON *value_json = marshal_value(&size, "int32_t", "int32_t", false, false, false, false, false, "size");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_qrcode_update
lv_result_t lv_qrcode_update(lv_obj_t* obj, void* data, uint32_t data_len) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_qrcode_update' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return 0;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_qrcode_update (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return 0;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "qrcode_update");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&data, "void*", "void", true, false, false, false, false, "data");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&data_len, "uint32_t", "uint32_t", false, false, false, false, false, "data_len");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
    /* Warning: Setter function 'lv_qrcode_update' has non-void return type 'lv_result_t'. Returning default. */
    return 0;
}

// Wrapper for: lv_rb_destroy
void lv_rb_destroy(lv_rb_t* tree) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_rb_destroy' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_rb_drop
bool lv_rb_drop(lv_rb_t* tree, void* key) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_rb_drop' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_rb_drop_node
bool lv_rb_drop_node(lv_rb_t* tree, lv_rb_node_t* node) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_rb_drop_node' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_rb_find
lv_rb_node_t* lv_rb_find(lv_rb_t* tree, void* key) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_rb_find' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_rb_node_t* */
    return NULL;
}

// Wrapper for: lv_rb_insert
lv_rb_node_t* lv_rb_insert(lv_rb_t* tree, void* key) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_rb_insert' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_rb_node_t* */
    return NULL;
}

// Wrapper for: lv_rb_maximum
lv_rb_node_t* lv_rb_maximum(lv_rb_t* node) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_rb_maximum' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_rb_node_t* */
    return NULL;
}

// Wrapper for: lv_rb_maximum_from
lv_rb_node_t* lv_rb_maximum_from(lv_rb_node_t* node) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_rb_maximum_from' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_rb_node_t* */
    return NULL;
}

// Wrapper for: lv_rb_minimum
lv_rb_node_t* lv_rb_minimum(lv_rb_t* node) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_rb_minimum' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_rb_node_t* */
    return NULL;
}

// Wrapper for: lv_rb_minimum_from
lv_rb_node_t* lv_rb_minimum_from(lv_rb_node_t* node) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_rb_minimum_from' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_rb_node_t* */
    return NULL;
}

// Wrapper for: lv_rb_remove
void* lv_rb_remove(lv_rb_t* tree, void* key) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_rb_remove' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_rb_remove_node
void* lv_rb_remove_node(lv_rb_t* tree, lv_rb_node_t* node) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(tree);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_rb_remove_node' called on unknown or unregistered opaque pointer %p.\n", (void*)tree);
        // Check if it's maybe NULL
        if (tree == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return NULL;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_rb_remove_node (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return NULL;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "rb_remove_node");
    cJSON *value_json = marshal_value(&node, "lv_rb_node_t*", "lv_rb_node_t", true, false, false, false, true, "node");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
    /* Warning: Setter function 'lv_rb_remove_node' has non-void return type 'void*'. Returning default. */
    return NULL;
}

// Wrapper for: lv_rle_decompress
uint32_t lv_rle_decompress(uint8_t* input, uint32_t input_buff_len, uint8_t* output, uint32_t output_buff_len, uint8_t blk_size) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_rle_decompress' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_roller_bind_value
lv_observer_t* lv_roller_bind_value(lv_obj_t* obj, lv_subject_t* subject) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_roller_bind_value' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_observer_t* */
    return NULL;
}

// Wrapper for: lv_roller_create
lv_obj_t* lv_roller_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_roller_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_roller_get_option_count
uint32_t lv_roller_get_option_count(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_roller_get_option_count' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_roller_get_options
char* lv_roller_get_options(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_roller_get_options' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_roller_get_selected
uint32_t lv_roller_get_selected(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_roller_get_selected' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_roller_get_selected_str
void lv_roller_get_selected_str(lv_obj_t* obj, char* buf, uint32_t buf_size) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_roller_get_selected_str' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_roller_set_options
void lv_roller_set_options(lv_obj_t* obj, char* options, lv_roller_mode_t mode) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_roller_set_options' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_roller_set_options (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "roller_set_options");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&options, "char*", "char", true, false, false, false, false, "options");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&mode, "lv_roller_mode_t", "lv_roller_mode_t", false, true, false, false, false, "mode");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_roller_set_selected
void lv_roller_set_selected(lv_obj_t* obj, uint32_t sel_opt, lv_anim_enable_t anim) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_roller_set_selected' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_roller_set_selected (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "roller_set_selected");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&sel_opt, "uint32_t", "uint32_t", false, false, false, false, false, "sel_opt");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&anim, "lv_anim_enable_t", "lv_anim_enable_t", false, false, false, false, false, "anim");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_roller_set_selected_str
bool lv_roller_set_selected_str(lv_obj_t* obj, char* sel_opt, lv_anim_enable_t anim) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_roller_set_selected_str' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return false;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_roller_set_selected_str (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return false;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "roller_set_selected_str");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&sel_opt, "char*", "char", true, false, false, false, false, "sel_opt");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&anim, "lv_anim_enable_t", "lv_anim_enable_t", false, false, false, false, false, "anim");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
    /* Warning: Setter function 'lv_roller_set_selected_str' has non-void return type 'bool'. Returning default. */
    return false;
}

// Wrapper for: lv_roller_set_visible_row_count
void lv_roller_set_visible_row_count(lv_obj_t* obj, uint32_t row_cnt) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_roller_set_visible_row_count' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_roller_set_visible_row_count (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "roller_set_visible_row_count");
    cJSON *value_json = marshal_value(&row_cnt, "uint32_t", "uint32_t", false, false, false, false, false, "row_cnt");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_scale_add_section
lv_scale_section_t* lv_scale_add_section(lv_obj_t* obj) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_scale_section_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_scale_add_section");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&obj, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "obj");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_scale_section_t*)new_obj_json;
}

// Wrapper for: lv_scale_create
lv_obj_t* lv_scale_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_scale_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_scale_get_angle_range
uint32_t lv_scale_get_angle_range(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_scale_get_angle_range' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_scale_get_label_show
bool lv_scale_get_label_show(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_scale_get_label_show' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_scale_get_major_tick_every
int32_t lv_scale_get_major_tick_every(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_scale_get_major_tick_every' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_scale_get_mode
lv_scale_mode_t lv_scale_get_mode(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_scale_get_mode' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_scale_mode_t */
    return 0;
}

// Wrapper for: lv_scale_get_range_max_value
int32_t lv_scale_get_range_max_value(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_scale_get_range_max_value' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_scale_get_range_min_value
int32_t lv_scale_get_range_min_value(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_scale_get_range_min_value' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_scale_get_rotation
int32_t lv_scale_get_rotation(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_scale_get_rotation' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_scale_get_total_tick_count
int32_t lv_scale_get_total_tick_count(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_scale_get_total_tick_count' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_scale_section_set_range
void lv_scale_section_set_range(lv_scale_section_t* section, int32_t min, int32_t max) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(section);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_scale_section_set_range' called on unknown or unregistered opaque pointer %p.\n", (void*)section);
        // Check if it's maybe NULL
        if (section == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_scale_section_set_range (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scale_section_set_range");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&min, "int32_t", "int32_t", false, false, false, false, false, "min");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&max, "int32_t", "int32_t", false, false, false, false, false, "max");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_scale_section_set_style
void lv_scale_section_set_style(lv_scale_section_t* section, lv_part_t part, lv_style_t* section_part_style) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(section);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_scale_section_set_style' called on unknown or unregistered opaque pointer %p.\n", (void*)section);
        // Check if it's maybe NULL
        if (section == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_scale_section_set_style (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scale_section_set_style");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&part, "lv_part_t", "lv_part_t", false, false, false, false, false, "part");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&section_part_style, "lv_style_t*", "lv_style_t", true, false, true, false, true, "section_part_style");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_scale_set_angle_range
void lv_scale_set_angle_range(lv_obj_t* obj, uint32_t angle_range) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_scale_set_angle_range' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_scale_set_angle_range (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scale_set_angle_range");
    cJSON *value_json = marshal_value(&angle_range, "uint32_t", "uint32_t", false, false, false, false, false, "angle_range");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_scale_set_draw_ticks_on_top
void lv_scale_set_draw_ticks_on_top(lv_obj_t* obj, bool en) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_scale_set_draw_ticks_on_top' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_scale_set_draw_ticks_on_top (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scale_set_draw_ticks_on_top");
    cJSON *value_json = marshal_value(&en, "bool", "bool", false, false, false, false, false, "en");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_scale_set_image_needle_value
void lv_scale_set_image_needle_value(lv_obj_t* obj, lv_obj_t* needle_img, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_scale_set_image_needle_value' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_scale_set_image_needle_value (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scale_set_image_needle_value");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&needle_img, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "needle_img");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_scale_set_label_show
void lv_scale_set_label_show(lv_obj_t* obj, bool show_label) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_scale_set_label_show' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_scale_set_label_show (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scale_set_label_show");
    cJSON *value_json = marshal_value(&show_label, "bool", "bool", false, false, false, false, false, "show_label");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_scale_set_line_needle_value
void lv_scale_set_line_needle_value(lv_obj_t* obj, lv_obj_t* needle_line, int32_t needle_length, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_scale_set_line_needle_value' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_scale_set_line_needle_value (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scale_set_line_needle_value");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&needle_line, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "needle_line");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&needle_length, "int32_t", "int32_t", false, false, false, false, false, "needle_length");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_scale_set_major_tick_every
void lv_scale_set_major_tick_every(lv_obj_t* obj, uint32_t major_tick_every) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_scale_set_major_tick_every' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_scale_set_major_tick_every (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scale_set_major_tick_every");
    cJSON *value_json = marshal_value(&major_tick_every, "uint32_t", "uint32_t", false, false, false, false, false, "major_tick_every");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_scale_set_mode
void lv_scale_set_mode(lv_obj_t* obj, lv_scale_mode_t mode) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_scale_set_mode' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_scale_set_mode (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scale_set_mode");
    cJSON *value_json = marshal_value(&mode, "lv_scale_mode_t", "lv_scale_mode_t", false, true, false, false, false, "mode");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_scale_set_post_draw
void lv_scale_set_post_draw(lv_obj_t* obj, bool en) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_scale_set_post_draw' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_scale_set_post_draw (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scale_set_post_draw");
    cJSON *value_json = marshal_value(&en, "bool", "bool", false, false, false, false, false, "en");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_scale_set_range
void lv_scale_set_range(lv_obj_t* obj, int32_t min, int32_t max) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_scale_set_range' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_scale_set_range (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scale_set_range");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&min, "int32_t", "int32_t", false, false, false, false, false, "min");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&max, "int32_t", "int32_t", false, false, false, false, false, "max");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_scale_set_rotation
void lv_scale_set_rotation(lv_obj_t* obj, int32_t rotation) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_scale_set_rotation' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_scale_set_rotation (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scale_set_rotation");
    cJSON *value_json = marshal_value(&rotation, "int32_t", "int32_t", false, false, false, false, false, "rotation");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_scale_set_section_range
void lv_scale_set_section_range(lv_obj_t* scale, lv_scale_section_t* section, int32_t min, int32_t max) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(scale);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_scale_set_section_range' called on unknown or unregistered opaque pointer %p.\n", (void*)scale);
        // Check if it's maybe NULL
        if (scale == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_scale_set_section_range (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scale_set_section_range");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&section, "lv_scale_section_t*", "lv_scale_section_t", true, false, false, false, true, "section");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&min, "int32_t", "int32_t", false, false, false, false, false, "min");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&max, "int32_t", "int32_t", false, false, false, false, false, "max");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_scale_set_section_style_indicator
void lv_scale_set_section_style_indicator(lv_obj_t* scale, lv_scale_section_t* section, lv_style_t* style) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(scale);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_scale_set_section_style_indicator' called on unknown or unregistered opaque pointer %p.\n", (void*)scale);
        // Check if it's maybe NULL
        if (scale == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_scale_set_section_style_indicator (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scale_set_section_style_indicator");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&section, "lv_scale_section_t*", "lv_scale_section_t", true, false, false, false, true, "section");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&style, "lv_style_t*", "lv_style_t", true, false, true, false, true, "style");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_scale_set_section_style_items
void lv_scale_set_section_style_items(lv_obj_t* scale, lv_scale_section_t* section, lv_style_t* style) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(scale);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_scale_set_section_style_items' called on unknown or unregistered opaque pointer %p.\n", (void*)scale);
        // Check if it's maybe NULL
        if (scale == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_scale_set_section_style_items (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scale_set_section_style_items");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&section, "lv_scale_section_t*", "lv_scale_section_t", true, false, false, false, true, "section");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&style, "lv_style_t*", "lv_style_t", true, false, true, false, true, "style");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_scale_set_section_style_main
void lv_scale_set_section_style_main(lv_obj_t* scale, lv_scale_section_t* section, lv_style_t* style) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(scale);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_scale_set_section_style_main' called on unknown or unregistered opaque pointer %p.\n", (void*)scale);
        // Check if it's maybe NULL
        if (scale == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_scale_set_section_style_main (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scale_set_section_style_main");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&section, "lv_scale_section_t*", "lv_scale_section_t", true, false, false, false, true, "section");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&style, "lv_style_t*", "lv_style_t", true, false, true, false, true, "style");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_scale_set_text_src
void lv_scale_set_text_src(lv_obj_t* obj, char* txt_src[]) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_scale_set_text_src' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_scale_set_text_src (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scale_set_text_src");
    cJSON *value_json = marshal_value(&txt_src, "char*[]", "char", false, false, false, false, false, "txt_src");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_scale_set_total_tick_count
void lv_scale_set_total_tick_count(lv_obj_t* obj, uint32_t total_tick_count) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_scale_set_total_tick_count' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_scale_set_total_tick_count (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "scale_set_total_tick_count");
    cJSON *value_json = marshal_value(&total_tick_count, "uint32_t", "uint32_t", false, false, false, false, false, "total_tick_count");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_screen_active
lv_obj_t* lv_screen_active(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_screen_active' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_slider_bind_value
lv_observer_t* lv_slider_bind_value(lv_obj_t* obj, lv_subject_t* subject) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_slider_bind_value' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_observer_t* */
    return NULL;
}

// Wrapper for: lv_slider_create
lv_obj_t* lv_slider_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_slider_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_slider_get_left_value
int32_t lv_slider_get_left_value(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_slider_get_left_value' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_slider_get_max_value
int32_t lv_slider_get_max_value(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_slider_get_max_value' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_slider_get_min_value
int32_t lv_slider_get_min_value(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_slider_get_min_value' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_slider_get_mode
lv_slider_mode_t lv_slider_get_mode(lv_obj_t* slider) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_slider_get_mode' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_slider_mode_t */
    return 0;
}

// Wrapper for: lv_slider_get_orientation
lv_slider_orientation_t lv_slider_get_orientation(lv_obj_t* slider) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_slider_get_orientation' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_slider_orientation_t */
    return 0;
}

// Wrapper for: lv_slider_get_value
int32_t lv_slider_get_value(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_slider_get_value' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_slider_is_dragged
bool lv_slider_is_dragged(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_slider_is_dragged' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_slider_is_symmetrical
bool lv_slider_is_symmetrical(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_slider_is_symmetrical' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_slider_set_mode
void lv_slider_set_mode(lv_obj_t* obj, lv_slider_mode_t mode) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_slider_set_mode' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_slider_set_mode (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "slider_set_mode");
    cJSON *value_json = marshal_value(&mode, "lv_slider_mode_t", "lv_slider_mode_t", false, true, false, false, false, "mode");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_slider_set_orientation
void lv_slider_set_orientation(lv_obj_t* obj, lv_slider_orientation_t orientation) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_slider_set_orientation' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_slider_set_orientation (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "slider_set_orientation");
    cJSON *value_json = marshal_value(&orientation, "lv_slider_orientation_t", "lv_slider_orientation_t", false, true, false, false, false, "orientation");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_slider_set_range
void lv_slider_set_range(lv_obj_t* obj, int32_t min, int32_t max) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_slider_set_range' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_slider_set_range (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "slider_set_range");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&min, "int32_t", "int32_t", false, false, false, false, false, "min");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&max, "int32_t", "int32_t", false, false, false, false, false, "max");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_slider_set_start_value
void lv_slider_set_start_value(lv_obj_t* obj, int32_t value, lv_anim_enable_t anim) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_slider_set_start_value' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_slider_set_start_value (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "slider_set_start_value");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&anim, "lv_anim_enable_t", "lv_anim_enable_t", false, false, false, false, false, "anim");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_slider_set_value
void lv_slider_set_value(lv_obj_t* obj, int32_t value, lv_anim_enable_t anim) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_slider_set_value' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_slider_set_value (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "slider_set_value");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&anim, "lv_anim_enable_t", "lv_anim_enable_t", false, false, false, false, false, "anim");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_span_get_style
lv_style_t* lv_span_get_style(lv_span_t* span) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_span_get_style' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_style_t* */
    return NULL;
}

// Wrapper for: lv_span_get_text
char* lv_span_get_text(lv_span_t* span) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_span_get_text' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_span_set_text
void lv_span_set_text(lv_span_t* span, char* text) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(span);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_span_set_text' called on unknown or unregistered opaque pointer %p.\n", (void*)span);
        // Check if it's maybe NULL
        if (span == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_span_set_text (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "span_set_text");
    cJSON *value_json = marshal_value(&text, "char*", "char", true, false, false, false, false, "text");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_span_set_text_static
void lv_span_set_text_static(lv_span_t* span, char* text) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(span);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_span_set_text_static' called on unknown or unregistered opaque pointer %p.\n", (void*)span);
        // Check if it's maybe NULL
        if (span == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_span_set_text_static (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "span_set_text_static");
    cJSON *value_json = marshal_value(&text, "char*", "char", true, false, false, false, false, "text");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_span_set_text_static
void lv_span_set_text_static(lv_span_t* span, char* text) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(span);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_span_set_text_static' called on unknown or unregistered opaque pointer %p.\n", (void*)span);
        // Check if it's maybe NULL
        if (span == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_span_set_text_static (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "span_set_text_static");
    cJSON *value_json = marshal_value(&text, "char*", "char", true, false, false, false, false, "text");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_span_stack_deinit
void lv_span_stack_deinit(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_span_stack_deinit' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_span_stack_init
void lv_span_stack_init(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_span_stack_init' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_spangroup_add_span
lv_span_t* lv_spangroup_add_span(lv_obj_t* obj) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_span_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_spangroup_add_span");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&obj, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "obj");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_span_t*)new_obj_json;
}

// Wrapper for: lv_spangroup_create
lv_obj_t* lv_spangroup_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_spangroup_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_spangroup_delete_span
void lv_spangroup_delete_span(lv_obj_t* obj, lv_span_t* span) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spangroup_delete_span' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_spangroup_get_align
lv_text_align_t lv_spangroup_get_align(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spangroup_get_align' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_text_align_t */
    return 0;
}

// Wrapper for: lv_spangroup_get_child
lv_span_t* lv_spangroup_get_child(lv_obj_t* obj, int32_t id) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spangroup_get_child' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_span_t* */
    return NULL;
}

// Wrapper for: lv_spangroup_get_expand_height
int32_t lv_spangroup_get_expand_height(lv_obj_t* obj, int32_t width) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spangroup_get_expand_height' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_spangroup_get_expand_width
uint32_t lv_spangroup_get_expand_width(lv_obj_t* obj, uint32_t max_width) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spangroup_get_expand_width' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_spangroup_get_indent
int32_t lv_spangroup_get_indent(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spangroup_get_indent' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_spangroup_get_max_line_height
int32_t lv_spangroup_get_max_line_height(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spangroup_get_max_line_height' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_spangroup_get_max_lines
int32_t lv_spangroup_get_max_lines(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spangroup_get_max_lines' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_spangroup_get_mode
lv_span_mode_t lv_spangroup_get_mode(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spangroup_get_mode' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_span_mode_t */
    return 0;
}

// Wrapper for: lv_spangroup_get_overflow
lv_span_overflow_t lv_spangroup_get_overflow(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spangroup_get_overflow' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_span_overflow_t */
    return 0;
}

// Wrapper for: lv_spangroup_get_span_by_point
lv_span_t* lv_spangroup_get_span_by_point(lv_obj_t* obj, struct lv_point_t* point) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spangroup_get_span_by_point' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_span_t* */
    return NULL;
}

// Wrapper for: lv_spangroup_get_span_coords
struct lv_span_coords_t lv_spangroup_get_span_coords(lv_obj_t* obj, lv_span_t* span) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spangroup_get_span_coords' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_span_coords_t */
    return 0;
}

// Wrapper for: lv_spangroup_get_span_count
uint32_t lv_spangroup_get_span_count(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spangroup_get_span_count' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_spangroup_refresh
void lv_spangroup_refresh(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spangroup_refresh' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_spangroup_set_align
void lv_spangroup_set_align(lv_obj_t* obj, lv_text_align_t align) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_spangroup_set_align' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_spangroup_set_align (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "spangroup_set_align");
    cJSON *value_json = marshal_value(&align, "lv_text_align_t", "lv_text_align_t", false, true, false, false, false, "align");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_spangroup_set_indent
void lv_spangroup_set_indent(lv_obj_t* obj, int32_t indent) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_spangroup_set_indent' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_spangroup_set_indent (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "spangroup_set_indent");
    cJSON *value_json = marshal_value(&indent, "int32_t", "int32_t", false, false, false, false, false, "indent");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_spangroup_set_max_lines
void lv_spangroup_set_max_lines(lv_obj_t* obj, int32_t lines) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_spangroup_set_max_lines' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_spangroup_set_max_lines (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "spangroup_set_max_lines");
    cJSON *value_json = marshal_value(&lines, "int32_t", "int32_t", false, false, false, false, false, "lines");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_spangroup_set_mode
void lv_spangroup_set_mode(lv_obj_t* obj, lv_span_mode_t mode) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_spangroup_set_mode' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_spangroup_set_mode (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "spangroup_set_mode");
    cJSON *value_json = marshal_value(&mode, "lv_span_mode_t", "lv_span_mode_t", false, true, false, false, false, "mode");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_spangroup_set_overflow
void lv_spangroup_set_overflow(lv_obj_t* obj, lv_span_overflow_t overflow) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_spangroup_set_overflow' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_spangroup_set_overflow (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "spangroup_set_overflow");
    cJSON *value_json = marshal_value(&overflow, "lv_span_overflow_t", "lv_span_overflow_t", false, true, false, false, false, "overflow");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_spangroup_set_span_style
void lv_spangroup_set_span_style(lv_obj_t* obj, lv_span_t* span, lv_style_t* style) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_spangroup_set_span_style' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_spangroup_set_span_style (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "spangroup_set_span_style");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&span, "lv_span_t*", "lv_span_t", true, false, false, false, true, "span");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&style, "lv_style_t*", "lv_style_t", true, false, true, false, true, "style");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_spangroup_set_span_text
void lv_spangroup_set_span_text(lv_obj_t* obj, lv_span_t* span, char* text) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_spangroup_set_span_text' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_spangroup_set_span_text (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "spangroup_set_span_text");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&span, "lv_span_t*", "lv_span_t", true, false, false, false, true, "span");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&text, "char*", "char", true, false, false, false, false, "text");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_spangroup_set_span_text_static
void lv_spangroup_set_span_text_static(lv_obj_t* obj, lv_span_t* span, char* text) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_spangroup_set_span_text_static' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_spangroup_set_span_text_static (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "spangroup_set_span_text_static");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&span, "lv_span_t*", "lv_span_t", true, false, false, false, true, "span");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&text, "char*", "char", true, false, false, false, false, "text");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_spinbox_create
lv_obj_t* lv_spinbox_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_spinbox_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_spinbox_decrement
void lv_spinbox_decrement(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spinbox_decrement' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_spinbox_get_rollover
bool lv_spinbox_get_rollover(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spinbox_get_rollover' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_spinbox_get_step
int32_t lv_spinbox_get_step(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spinbox_get_step' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_spinbox_get_value
int32_t lv_spinbox_get_value(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spinbox_get_value' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_spinbox_increment
void lv_spinbox_increment(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spinbox_increment' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_spinbox_set_cursor_pos
void lv_spinbox_set_cursor_pos(lv_obj_t* obj, uint32_t pos) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_spinbox_set_cursor_pos' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_spinbox_set_cursor_pos (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "spinbox_set_cursor_pos");
    cJSON *value_json = marshal_value(&pos, "uint32_t", "uint32_t", false, false, false, false, false, "pos");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_spinbox_set_digit_format
void lv_spinbox_set_digit_format(lv_obj_t* obj, uint32_t digit_count, uint32_t sep_pos) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_spinbox_set_digit_format' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_spinbox_set_digit_format (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "spinbox_set_digit_format");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&digit_count, "uint32_t", "uint32_t", false, false, false, false, false, "digit_count");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&sep_pos, "uint32_t", "uint32_t", false, false, false, false, false, "sep_pos");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_spinbox_set_digit_step_direction
void lv_spinbox_set_digit_step_direction(lv_obj_t* obj, lv_dir_t direction) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_spinbox_set_digit_step_direction' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_spinbox_set_digit_step_direction (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "spinbox_set_digit_step_direction");
    cJSON *value_json = marshal_value(&direction, "lv_dir_t", "lv_dir_t", false, true, false, false, false, "direction");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_spinbox_set_range
void lv_spinbox_set_range(lv_obj_t* obj, int32_t range_min, int32_t range_max) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_spinbox_set_range' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_spinbox_set_range (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "spinbox_set_range");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&range_min, "int32_t", "int32_t", false, false, false, false, false, "range_min");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&range_max, "int32_t", "int32_t", false, false, false, false, false, "range_max");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_spinbox_set_rollover
void lv_spinbox_set_rollover(lv_obj_t* obj, bool rollover) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_spinbox_set_rollover' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_spinbox_set_rollover (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "spinbox_set_rollover");
    cJSON *value_json = marshal_value(&rollover, "bool", "bool", false, false, false, false, false, "rollover");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_spinbox_set_step
void lv_spinbox_set_step(lv_obj_t* obj, uint32_t step) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_spinbox_set_step' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_spinbox_set_step (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "spinbox_set_step");
    cJSON *value_json = marshal_value(&step, "uint32_t", "uint32_t", false, false, false, false, false, "step");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_spinbox_set_value
void lv_spinbox_set_value(lv_obj_t* obj, int32_t v) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_spinbox_set_value' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_spinbox_set_value (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "spinbox_set_value");
    cJSON *value_json = marshal_value(&v, "int32_t", "int32_t", false, false, false, false, false, "v");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_spinbox_step_next
void lv_spinbox_step_next(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spinbox_step_next' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_spinbox_step_prev
void lv_spinbox_step_prev(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_spinbox_step_prev' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_spinner_create
lv_obj_t* lv_spinner_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_spinner_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_spinner_set_anim_params
void lv_spinner_set_anim_params(lv_obj_t* obj, uint32_t t, uint32_t angle) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_spinner_set_anim_params' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_spinner_set_anim_params (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "spinner_set_anim_params");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&t, "uint32_t", "uint32_t", false, false, false, false, false, "t");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&angle, "uint32_t", "uint32_t", false, false, false, false, false, "angle");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_sqr
int32_t lv_sqr(int32_t x) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_sqr' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_sqrt
void lv_sqrt(uint32_t x, struct lv_sqrt_res_t* q, uint32_t mask) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_sqrt' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_sqrt32
int32_t lv_sqrt32(uint32_t x) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_sqrt32' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_strcat
char* lv_strcat(char* dst, char* src) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_strcat' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_strchr
char* lv_strchr(char* str, int c) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_strchr' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_strcmp
int lv_strcmp(char* s1, char* s2) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_strcmp' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int */
    return 0;
}

// Wrapper for: lv_strcpy
char* lv_strcpy(char* dst, char* src) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_strcpy' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_strdup
char* lv_strdup(char* src) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_strdup' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_streq
bool lv_streq(char* s1, char* s2) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_streq' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_strlcpy
size_t lv_strlcpy(char* dst, char* src, size_t dst_size) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_strlcpy' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type size_t */
    return 0;
}

// Wrapper for: lv_strlen
size_t lv_strlen(char* str) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_strlen' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type size_t */
    return 0;
}

// Wrapper for: lv_strncat
char* lv_strncat(char* dst, char* src, size_t src_len) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_strncat' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_strncmp
int lv_strncmp(char* s1, char* s2, size_t len) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_strncmp' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int */
    return 0;
}

// Wrapper for: lv_strncpy
char* lv_strncpy(char* dst, char* src, size_t dest_size) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_strncpy' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_strndup
char* lv_strndup(char* src, size_t max_len) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_strndup' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_strnlen
size_t lv_strnlen(char* str, size_t max_len) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_strnlen' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type size_t */
    return 0;
}

// Wrapper for: lv_style_copy
void lv_style_copy(lv_style_t* dst, lv_style_t* src) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_style_copy' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_style_get_num_custom_props
lv_style_prop_t lv_style_get_num_custom_props(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_style_get_num_custom_props' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_style_prop_t */
    return 0;
}

// Wrapper for: lv_style_init
void lv_style_init(lv_style_t* style) {
    /* Wrapper Type: init */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in init"); assert(false); /* Cannot return if void */ return; }
    const char* type_name = "lv_style_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "initializer_func", "lv_style_init");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *init_args_array = cJSON_CreateArray();
    if (!init_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "init_args", init_args_array);
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)style, type_name, obj_id, new_obj_json);
}

// Wrapper for: lv_style_is_const
bool lv_style_is_const(lv_style_t* style) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_style_is_const' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_style_is_empty
bool lv_style_is_empty(lv_style_t* style) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_style_is_empty' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_style_prop_get_default
union lv_style_value_t lv_style_prop_get_default(lv_style_prop_t prop) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_style_prop_get_default' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type union lv_style_value_t */
    return 0;
}

// Wrapper for: lv_style_prop_has_flag
bool lv_style_prop_has_flag(lv_style_prop_t prop, uint8_t flag) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_style_prop_has_flag' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_style_register_prop
lv_style_prop_t lv_style_register_prop(uint8_t flag) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_style_register_prop' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_style_prop_t */
    return 0;
}

// Wrapper for: lv_style_remove_prop
bool lv_style_remove_prop(lv_style_t* style, lv_style_prop_t prop) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_remove_prop' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return false;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_remove_prop (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return false;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "style_remove_prop");
    cJSON *value_json = marshal_value(&prop, "lv_style_prop_t", "lv_style_prop_t", false, false, false, false, false, "prop");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
    /* Warning: Setter function 'lv_style_remove_prop' has non-void return type 'bool'. Returning default. */
    return false;
}

// Wrapper for: lv_style_reset
void lv_style_reset(lv_style_t* style) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_style_reset' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_style_set_align
void lv_style_set_align(lv_style_t* style, lv_align_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_align' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_align (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "align");
    cJSON *value_json = marshal_value(&value, "lv_align_t", "lv_align_t", false, true, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_anim
void lv_style_set_anim(lv_style_t* style, lv_anim_t* value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_anim' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_anim (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "anim");
    cJSON *value_json = marshal_value(&value, "lv_anim_t*", "lv_anim_t", true, false, false, false, true, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_anim_duration
void lv_style_set_anim_duration(lv_style_t* style, uint32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_anim_duration' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_anim_duration (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "anim_duration");
    cJSON *value_json = marshal_value(&value, "uint32_t", "uint32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_arc_color
void lv_style_set_arc_color(lv_style_t* style, struct lv_color_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_arc_color' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_arc_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "arc_color");
    cJSON *value_json = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_arc_image_src
void lv_style_set_arc_image_src(lv_style_t* style, void* value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_arc_image_src' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_arc_image_src (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "arc_image_src");
    cJSON *value_json = marshal_value(&value, "void*", "void", true, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_arc_opa
void lv_style_set_arc_opa(lv_style_t* style, lv_opa_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_arc_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_arc_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "arc_opa");
    cJSON *value_json = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_arc_rounded
void lv_style_set_arc_rounded(lv_style_t* style, bool value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_arc_rounded' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_arc_rounded (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "arc_rounded");
    cJSON *value_json = marshal_value(&value, "bool", "bool", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_arc_width
void lv_style_set_arc_width(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_arc_width' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_arc_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "arc_width");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_base_dir
void lv_style_set_base_dir(lv_style_t* style, lv_base_dir_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_base_dir' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_base_dir (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "base_dir");
    cJSON *value_json = marshal_value(&value, "lv_base_dir_t", "lv_base_dir_t", false, true, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_bg_color
void lv_style_set_bg_color(lv_style_t* style, struct lv_color_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_bg_color' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_bg_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bg_color");
    cJSON *value_json = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_bg_grad
void lv_style_set_bg_grad(lv_style_t* style, struct lv_grad_dsc_t* value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_bg_grad' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_bg_grad (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bg_grad");
    cJSON *value_json = marshal_value(&value, "struct lv_grad_dsc_t*", "lv_grad_dsc_t", true, false, true, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_bg_grad_color
void lv_style_set_bg_grad_color(lv_style_t* style, struct lv_color_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_bg_grad_color' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_bg_grad_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bg_grad_color");
    cJSON *value_json = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_bg_grad_dir
void lv_style_set_bg_grad_dir(lv_style_t* style, lv_grad_dir_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_bg_grad_dir' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_bg_grad_dir (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bg_grad_dir");
    cJSON *value_json = marshal_value(&value, "lv_grad_dir_t", "lv_grad_dir_t", false, true, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_bg_grad_opa
void lv_style_set_bg_grad_opa(lv_style_t* style, lv_opa_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_bg_grad_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_bg_grad_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bg_grad_opa");
    cJSON *value_json = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_bg_grad_stop
void lv_style_set_bg_grad_stop(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_bg_grad_stop' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_bg_grad_stop (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bg_grad_stop");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_bg_image_opa
void lv_style_set_bg_image_opa(lv_style_t* style, lv_opa_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_bg_image_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_bg_image_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bg_image_opa");
    cJSON *value_json = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_bg_image_recolor
void lv_style_set_bg_image_recolor(lv_style_t* style, struct lv_color_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_bg_image_recolor' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_bg_image_recolor (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bg_image_recolor");
    cJSON *value_json = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_bg_image_recolor_opa
void lv_style_set_bg_image_recolor_opa(lv_style_t* style, lv_opa_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_bg_image_recolor_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_bg_image_recolor_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bg_image_recolor_opa");
    cJSON *value_json = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_bg_image_src
void lv_style_set_bg_image_src(lv_style_t* style, void* value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_bg_image_src' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_bg_image_src (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bg_image_src");
    cJSON *value_json = marshal_value(&value, "void*", "void", true, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_bg_image_tiled
void lv_style_set_bg_image_tiled(lv_style_t* style, bool value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_bg_image_tiled' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_bg_image_tiled (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bg_image_tiled");
    cJSON *value_json = marshal_value(&value, "bool", "bool", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_bg_main_opa
void lv_style_set_bg_main_opa(lv_style_t* style, lv_opa_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_bg_main_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_bg_main_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bg_main_opa");
    cJSON *value_json = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_bg_main_stop
void lv_style_set_bg_main_stop(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_bg_main_stop' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_bg_main_stop (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bg_main_stop");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_bg_opa
void lv_style_set_bg_opa(lv_style_t* style, lv_opa_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_bg_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_bg_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bg_opa");
    cJSON *value_json = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_bitmap_mask_src
void lv_style_set_bitmap_mask_src(lv_style_t* style, void* value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_bitmap_mask_src' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_bitmap_mask_src (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "bitmap_mask_src");
    cJSON *value_json = marshal_value(&value, "void*", "void", true, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_blend_mode
void lv_style_set_blend_mode(lv_style_t* style, lv_blend_mode_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_blend_mode' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_blend_mode (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "blend_mode");
    cJSON *value_json = marshal_value(&value, "lv_blend_mode_t", "lv_blend_mode_t", false, true, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_border_color
void lv_style_set_border_color(lv_style_t* style, struct lv_color_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_border_color' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_border_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "border_color");
    cJSON *value_json = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_border_opa
void lv_style_set_border_opa(lv_style_t* style, lv_opa_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_border_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_border_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "border_opa");
    cJSON *value_json = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_border_post
void lv_style_set_border_post(lv_style_t* style, bool value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_border_post' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_border_post (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "border_post");
    cJSON *value_json = marshal_value(&value, "bool", "bool", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_border_side
void lv_style_set_border_side(lv_style_t* style, lv_border_side_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_border_side' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_border_side (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "border_side");
    cJSON *value_json = marshal_value(&value, "lv_border_side_t", "lv_border_side_t", false, true, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_border_width
void lv_style_set_border_width(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_border_width' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_border_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "border_width");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_clip_corner
void lv_style_set_clip_corner(lv_style_t* style, bool value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_clip_corner' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_clip_corner (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "clip_corner");
    cJSON *value_json = marshal_value(&value, "bool", "bool", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_color_filter_dsc
void lv_style_set_color_filter_dsc(lv_style_t* style, lv_color_filter_dsc_t* value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_color_filter_dsc' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_color_filter_dsc (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "color_filter_dsc");
    cJSON *value_json = marshal_value(&value, "lv_color_filter_dsc_t*", "lv_color_filter_dsc_t", true, false, false, false, true, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_color_filter_opa
void lv_style_set_color_filter_opa(lv_style_t* style, lv_opa_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_color_filter_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_color_filter_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "color_filter_opa");
    cJSON *value_json = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_flex_cross_place
void lv_style_set_flex_cross_place(lv_style_t* style, lv_flex_align_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_flex_cross_place' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_flex_cross_place (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "flex_cross_place");
    cJSON *value_json = marshal_value(&value, "lv_flex_align_t", "lv_flex_align_t", false, true, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_flex_flow
void lv_style_set_flex_flow(lv_style_t* style, lv_flex_flow_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_flex_flow' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_flex_flow (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "flex_flow");
    cJSON *value_json = marshal_value(&value, "lv_flex_flow_t", "lv_flex_flow_t", false, true, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_flex_grow
void lv_style_set_flex_grow(lv_style_t* style, uint8_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_flex_grow' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_flex_grow (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "flex_grow");
    cJSON *value_json = marshal_value(&value, "uint8_t", "uint8_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_flex_main_place
void lv_style_set_flex_main_place(lv_style_t* style, lv_flex_align_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_flex_main_place' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_flex_main_place (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "flex_main_place");
    cJSON *value_json = marshal_value(&value, "lv_flex_align_t", "lv_flex_align_t", false, true, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_flex_track_place
void lv_style_set_flex_track_place(lv_style_t* style, lv_flex_align_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_flex_track_place' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_flex_track_place (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "flex_track_place");
    cJSON *value_json = marshal_value(&value, "lv_flex_align_t", "lv_flex_align_t", false, true, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_grid_cell_column_pos
void lv_style_set_grid_cell_column_pos(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_grid_cell_column_pos' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_grid_cell_column_pos (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "grid_cell_column_pos");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_grid_cell_column_span
void lv_style_set_grid_cell_column_span(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_grid_cell_column_span' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_grid_cell_column_span (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "grid_cell_column_span");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_grid_cell_row_pos
void lv_style_set_grid_cell_row_pos(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_grid_cell_row_pos' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_grid_cell_row_pos (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "grid_cell_row_pos");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_grid_cell_row_span
void lv_style_set_grid_cell_row_span(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_grid_cell_row_span' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_grid_cell_row_span (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "grid_cell_row_span");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_grid_cell_x_align
void lv_style_set_grid_cell_x_align(lv_style_t* style, lv_grid_align_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_grid_cell_x_align' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_grid_cell_x_align (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "grid_cell_x_align");
    cJSON *value_json = marshal_value(&value, "lv_grid_align_t", "lv_grid_align_t", false, true, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_grid_cell_y_align
void lv_style_set_grid_cell_y_align(lv_style_t* style, lv_grid_align_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_grid_cell_y_align' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_grid_cell_y_align (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "grid_cell_y_align");
    cJSON *value_json = marshal_value(&value, "lv_grid_align_t", "lv_grid_align_t", false, true, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_grid_column_align
void lv_style_set_grid_column_align(lv_style_t* style, lv_grid_align_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_grid_column_align' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_grid_column_align (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "grid_column_align");
    cJSON *value_json = marshal_value(&value, "lv_grid_align_t", "lv_grid_align_t", false, true, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_grid_column_dsc_array
void lv_style_set_grid_column_dsc_array(lv_style_t* style, int32_t* value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_grid_column_dsc_array' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_grid_column_dsc_array (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "grid_column_dsc_array");
    cJSON *value_json = marshal_value(&value, "int32_t*", "int32_t", true, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_grid_row_align
void lv_style_set_grid_row_align(lv_style_t* style, lv_grid_align_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_grid_row_align' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_grid_row_align (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "grid_row_align");
    cJSON *value_json = marshal_value(&value, "lv_grid_align_t", "lv_grid_align_t", false, true, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_grid_row_dsc_array
void lv_style_set_grid_row_dsc_array(lv_style_t* style, int32_t* value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_grid_row_dsc_array' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_grid_row_dsc_array (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "grid_row_dsc_array");
    cJSON *value_json = marshal_value(&value, "int32_t*", "int32_t", true, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_height
void lv_style_set_height(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_height' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_height (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "height");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_image_opa
void lv_style_set_image_opa(lv_style_t* style, lv_opa_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_image_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_image_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "image_opa");
    cJSON *value_json = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_image_recolor
void lv_style_set_image_recolor(lv_style_t* style, struct lv_color_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_image_recolor' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_image_recolor (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "image_recolor");
    cJSON *value_json = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_image_recolor_opa
void lv_style_set_image_recolor_opa(lv_style_t* style, lv_opa_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_image_recolor_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_image_recolor_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "image_recolor_opa");
    cJSON *value_json = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_layout
void lv_style_set_layout(lv_style_t* style, uint16_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_layout' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_layout (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "layout");
    cJSON *value_json = marshal_value(&value, "uint16_t", "uint16_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_length
void lv_style_set_length(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_length' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_length (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "length");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_line_color
void lv_style_set_line_color(lv_style_t* style, struct lv_color_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_line_color' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_line_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "line_color");
    cJSON *value_json = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_line_dash_gap
void lv_style_set_line_dash_gap(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_line_dash_gap' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_line_dash_gap (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "line_dash_gap");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_line_dash_width
void lv_style_set_line_dash_width(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_line_dash_width' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_line_dash_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "line_dash_width");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_line_opa
void lv_style_set_line_opa(lv_style_t* style, lv_opa_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_line_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_line_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "line_opa");
    cJSON *value_json = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_line_rounded
void lv_style_set_line_rounded(lv_style_t* style, bool value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_line_rounded' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_line_rounded (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "line_rounded");
    cJSON *value_json = marshal_value(&value, "bool", "bool", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_line_width
void lv_style_set_line_width(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_line_width' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_line_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "line_width");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_margin_all
void lv_style_set_margin_all(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_margin_all' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_margin_all (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "margin_all");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_margin_bottom
void lv_style_set_margin_bottom(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_margin_bottom' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_margin_bottom (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "margin_bottom");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_margin_hor
void lv_style_set_margin_hor(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_margin_hor' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_margin_hor (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "margin_hor");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_margin_left
void lv_style_set_margin_left(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_margin_left' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_margin_left (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "margin_left");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_margin_right
void lv_style_set_margin_right(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_margin_right' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_margin_right (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "margin_right");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_margin_top
void lv_style_set_margin_top(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_margin_top' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_margin_top (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "margin_top");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_margin_ver
void lv_style_set_margin_ver(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_margin_ver' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_margin_ver (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "margin_ver");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_max_height
void lv_style_set_max_height(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_max_height' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_max_height (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "max_height");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_max_width
void lv_style_set_max_width(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_max_width' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_max_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "max_width");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_min_height
void lv_style_set_min_height(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_min_height' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_min_height (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "min_height");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_min_width
void lv_style_set_min_width(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_min_width' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_min_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "min_width");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_opa
void lv_style_set_opa(lv_style_t* style, lv_opa_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "opa");
    cJSON *value_json = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_opa_layered
void lv_style_set_opa_layered(lv_style_t* style, lv_opa_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_opa_layered' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_opa_layered (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "opa_layered");
    cJSON *value_json = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_outline_color
void lv_style_set_outline_color(lv_style_t* style, struct lv_color_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_outline_color' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_outline_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "outline_color");
    cJSON *value_json = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_outline_opa
void lv_style_set_outline_opa(lv_style_t* style, lv_opa_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_outline_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_outline_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "outline_opa");
    cJSON *value_json = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_outline_pad
void lv_style_set_outline_pad(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_outline_pad' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_outline_pad (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "outline_pad");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_outline_width
void lv_style_set_outline_width(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_outline_width' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_outline_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "outline_width");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_pad_all
void lv_style_set_pad_all(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_pad_all' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_pad_all (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "pad_all");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_pad_bottom
void lv_style_set_pad_bottom(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_pad_bottom' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_pad_bottom (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "pad_bottom");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_pad_column
void lv_style_set_pad_column(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_pad_column' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_pad_column (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "pad_column");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_pad_gap
void lv_style_set_pad_gap(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_pad_gap' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_pad_gap (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "pad_gap");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_pad_hor
void lv_style_set_pad_hor(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_pad_hor' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_pad_hor (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "pad_hor");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_pad_left
void lv_style_set_pad_left(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_pad_left' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_pad_left (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "pad_left");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_pad_radial
void lv_style_set_pad_radial(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_pad_radial' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_pad_radial (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "pad_radial");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_pad_right
void lv_style_set_pad_right(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_pad_right' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_pad_right (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "pad_right");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_pad_row
void lv_style_set_pad_row(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_pad_row' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_pad_row (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "pad_row");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_pad_top
void lv_style_set_pad_top(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_pad_top' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_pad_top (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "pad_top");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_pad_ver
void lv_style_set_pad_ver(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_pad_ver' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_pad_ver (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "pad_ver");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_prop
void lv_style_set_prop(lv_style_t* style, lv_style_prop_t prop, union lv_style_value_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_prop' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_prop (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "prop");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&prop, "lv_style_prop_t", "lv_style_prop_t", false, false, false, false, false, "prop");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&value, "union lv_style_value_t", "lv_style_value_t", false, false, false, true, false, "value");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_radial_offset
void lv_style_set_radial_offset(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_radial_offset' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_radial_offset (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "radial_offset");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_radius
void lv_style_set_radius(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_radius' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_radius (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "radius");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_recolor
void lv_style_set_recolor(lv_style_t* style, struct lv_color_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_recolor' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_recolor (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "recolor");
    cJSON *value_json = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_recolor_opa
void lv_style_set_recolor_opa(lv_style_t* style, lv_opa_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_recolor_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_recolor_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "recolor_opa");
    cJSON *value_json = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_rotary_sensitivity
void lv_style_set_rotary_sensitivity(lv_style_t* style, uint32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_rotary_sensitivity' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_rotary_sensitivity (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "rotary_sensitivity");
    cJSON *value_json = marshal_value(&value, "uint32_t", "uint32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_shadow_color
void lv_style_set_shadow_color(lv_style_t* style, struct lv_color_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_shadow_color' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_shadow_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "shadow_color");
    cJSON *value_json = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_shadow_offset_x
void lv_style_set_shadow_offset_x(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_shadow_offset_x' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_shadow_offset_x (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "shadow_offset_x");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_shadow_offset_y
void lv_style_set_shadow_offset_y(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_shadow_offset_y' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_shadow_offset_y (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "shadow_offset_y");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_shadow_opa
void lv_style_set_shadow_opa(lv_style_t* style, lv_opa_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_shadow_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_shadow_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "shadow_opa");
    cJSON *value_json = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_shadow_spread
void lv_style_set_shadow_spread(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_shadow_spread' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_shadow_spread (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "shadow_spread");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_shadow_width
void lv_style_set_shadow_width(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_shadow_width' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_shadow_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "shadow_width");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_size
void lv_style_set_size(lv_style_t* style, int32_t width, int32_t height) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_size' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_size (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "size");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&width, "int32_t", "int32_t", false, false, false, false, false, "width");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&height, "int32_t", "int32_t", false, false, false, false, false, "height");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_text_align
void lv_style_set_text_align(lv_style_t* style, lv_text_align_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_text_align' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_text_align (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "text_align");
    cJSON *value_json = marshal_value(&value, "lv_text_align_t", "lv_text_align_t", false, true, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_text_color
void lv_style_set_text_color(lv_style_t* style, struct lv_color_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_text_color' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_text_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "text_color");
    cJSON *value_json = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_text_decor
void lv_style_set_text_decor(lv_style_t* style, lv_text_decor_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_text_decor' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_text_decor (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "text_decor");
    cJSON *value_json = marshal_value(&value, "lv_text_decor_t", "lv_text_decor_t", false, true, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_text_font
void lv_style_set_text_font(lv_style_t* style, lv_font_t* value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_text_font' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_text_font (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "text_font");
    cJSON *value_json = marshal_value(&value, "lv_font_t*", "lv_font_t", true, false, false, false, true, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_text_letter_space
void lv_style_set_text_letter_space(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_text_letter_space' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_text_letter_space (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "text_letter_space");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_text_line_space
void lv_style_set_text_line_space(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_text_line_space' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_text_line_space (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "text_line_space");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_text_opa
void lv_style_set_text_opa(lv_style_t* style, lv_opa_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_text_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_text_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "text_opa");
    cJSON *value_json = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_text_outline_stroke_color
void lv_style_set_text_outline_stroke_color(lv_style_t* style, struct lv_color_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_text_outline_stroke_color' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_text_outline_stroke_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "text_outline_stroke_color");
    cJSON *value_json = marshal_value(&value, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_text_outline_stroke_opa
void lv_style_set_text_outline_stroke_opa(lv_style_t* style, lv_opa_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_text_outline_stroke_opa' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_text_outline_stroke_opa (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "text_outline_stroke_opa");
    cJSON *value_json = marshal_value(&value, "lv_opa_t", "lv_opa_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_text_outline_stroke_width
void lv_style_set_text_outline_stroke_width(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_text_outline_stroke_width' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_text_outline_stroke_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "text_outline_stroke_width");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_transform_height
void lv_style_set_transform_height(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_transform_height' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_transform_height (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "transform_height");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_transform_pivot_x
void lv_style_set_transform_pivot_x(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_transform_pivot_x' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_transform_pivot_x (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "transform_pivot_x");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_transform_pivot_y
void lv_style_set_transform_pivot_y(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_transform_pivot_y' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_transform_pivot_y (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "transform_pivot_y");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_transform_rotation
void lv_style_set_transform_rotation(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_transform_rotation' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_transform_rotation (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "transform_rotation");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_transform_scale
void lv_style_set_transform_scale(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_transform_scale' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_transform_scale (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "transform_scale");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_transform_scale_x
void lv_style_set_transform_scale_x(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_transform_scale_x' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_transform_scale_x (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "transform_scale_x");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_transform_scale_y
void lv_style_set_transform_scale_y(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_transform_scale_y' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_transform_scale_y (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "transform_scale_y");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_transform_skew_x
void lv_style_set_transform_skew_x(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_transform_skew_x' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_transform_skew_x (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "transform_skew_x");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_transform_skew_y
void lv_style_set_transform_skew_y(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_transform_skew_y' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_transform_skew_y (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "transform_skew_y");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_transform_width
void lv_style_set_transform_width(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_transform_width' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_transform_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "transform_width");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_transition
void lv_style_set_transition(lv_style_t* style, lv_style_transition_dsc_t* value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_transition' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_transition (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "transition");
    cJSON *value_json = marshal_value(&value, "lv_style_transition_dsc_t*", "lv_style_transition_dsc_t", true, false, true, false, true, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_translate_radial
void lv_style_set_translate_radial(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_translate_radial' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_translate_radial (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "translate_radial");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_translate_x
void lv_style_set_translate_x(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_translate_x' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_translate_x (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "translate_x");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_translate_y
void lv_style_set_translate_y(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_translate_y' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_translate_y (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "translate_y");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_width
void lv_style_set_width(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_width' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "width");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_x
void lv_style_set_x(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_x' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_x (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "x");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_style_set_y
void lv_style_set_y(lv_style_t* style, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(style);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_style_set_y' called on unknown or unregistered opaque pointer %p.\n", (void*)style);
        // Check if it's maybe NULL
        if (style == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_style_set_y (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "y");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_subject_copy_string
void lv_subject_copy_string(lv_subject_t* subject, char* buf) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_subject_copy_string' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_subject_deinit
void lv_subject_deinit(lv_subject_t* subject) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_subject_deinit' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_subject_get_color
struct lv_color_t lv_subject_get_color(lv_subject_t* subject) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_subject_get_color' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_t */
    return 0;
}

// Wrapper for: lv_subject_get_group_element
lv_subject_t* lv_subject_get_group_element(lv_subject_t* subject, int32_t index) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_subject_get_group_element' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_subject_t* */
    return NULL;
}

// Wrapper for: lv_subject_get_int
int32_t lv_subject_get_int(lv_subject_t* subject) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_subject_get_int' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_subject_get_pointer
void* lv_subject_get_pointer(lv_subject_t* subject) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_subject_get_pointer' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_subject_get_previous_color
struct lv_color_t lv_subject_get_previous_color(lv_subject_t* subject) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_subject_get_previous_color' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_t */
    return 0;
}

// Wrapper for: lv_subject_get_previous_int
int32_t lv_subject_get_previous_int(lv_subject_t* subject) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_subject_get_previous_int' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_subject_get_previous_pointer
void* lv_subject_get_previous_pointer(lv_subject_t* subject) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_subject_get_previous_pointer' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_subject_get_previous_string
char* lv_subject_get_previous_string(lv_subject_t* subject) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_subject_get_previous_string' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_subject_get_string
char* lv_subject_get_string(lv_subject_t* subject) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_subject_get_string' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_subject_init_color
void lv_subject_init_color(lv_subject_t* subject, struct lv_color_t color) {
    /* Wrapper Type: init */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in init"); assert(false); /* Cannot return if void */ return; }
    const char* type_name = "lv_subject_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "initializer_func", "lv_subject_init_color");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *init_args_array = cJSON_CreateArray();
    if (!init_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "init_args", init_args_array);
    cJSON* marshaled_arg = marshal_value(&color, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "color");
    if (marshaled_arg) {
        cJSON_AddItemToArray(init_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(init_args_array, cJSON_CreateNull());
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)subject, type_name, obj_id, new_obj_json);
}

// Wrapper for: lv_subject_init_group
void lv_subject_init_group(lv_subject_t* group_subject, lv_subject_t* list[], uint32_t list_len) {
    /* Wrapper Type: init */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in init"); assert(false); /* Cannot return if void */ return; }
    const char* type_name = "lv_subject_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "initializer_func", "lv_subject_init_group");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *init_args_array = cJSON_CreateArray();
    if (!init_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "init_args", init_args_array);
    cJSON* marshaled_arg = marshal_value(&list, "lv_subject_t*[]", "lv_subject_t", false, false, true, false, true, "list");
    if (marshaled_arg) {
        cJSON_AddItemToArray(init_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(init_args_array, cJSON_CreateNull());
    }
    cJSON* marshaled_arg = marshal_value(&list_len, "uint32_t", "uint32_t", false, false, false, false, false, "list_len");
    if (marshaled_arg) {
        cJSON_AddItemToArray(init_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(init_args_array, cJSON_CreateNull());
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)group_subject, type_name, obj_id, new_obj_json);
}

// Wrapper for: lv_subject_init_int
void lv_subject_init_int(lv_subject_t* subject, int32_t value) {
    /* Wrapper Type: init */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in init"); assert(false); /* Cannot return if void */ return; }
    const char* type_name = "lv_subject_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "initializer_func", "lv_subject_init_int");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *init_args_array = cJSON_CreateArray();
    if (!init_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "init_args", init_args_array);
    cJSON* marshaled_arg = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (marshaled_arg) {
        cJSON_AddItemToArray(init_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(init_args_array, cJSON_CreateNull());
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)subject, type_name, obj_id, new_obj_json);
}

// Wrapper for: lv_subject_init_pointer
void lv_subject_init_pointer(lv_subject_t* subject, void* value) {
    /* Wrapper Type: init */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in init"); assert(false); /* Cannot return if void */ return; }
    const char* type_name = "lv_subject_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "initializer_func", "lv_subject_init_pointer");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *init_args_array = cJSON_CreateArray();
    if (!init_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "init_args", init_args_array);
    cJSON* marshaled_arg = marshal_value(&value, "void*", "void", true, false, false, false, false, "value");
    if (marshaled_arg) {
        cJSON_AddItemToArray(init_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(init_args_array, cJSON_CreateNull());
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)subject, type_name, obj_id, new_obj_json);
}

// Wrapper for: lv_subject_init_string
void lv_subject_init_string(lv_subject_t* subject, char* buf, char* prev_buf, size_t size, char* value) {
    /* Wrapper Type: init */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in init"); assert(false); /* Cannot return if void */ return; }
    const char* type_name = "lv_subject_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "initializer_func", "lv_subject_init_string");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *init_args_array = cJSON_CreateArray();
    if (!init_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "init_args", init_args_array);
    cJSON* marshaled_arg = marshal_value(&buf, "char*", "char", true, false, false, false, false, "buf");
    if (marshaled_arg) {
        cJSON_AddItemToArray(init_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(init_args_array, cJSON_CreateNull());
    }
    cJSON* marshaled_arg = marshal_value(&prev_buf, "char*", "char", true, false, false, false, false, "prev_buf");
    if (marshaled_arg) {
        cJSON_AddItemToArray(init_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(init_args_array, cJSON_CreateNull());
    }
    cJSON* marshaled_arg = marshal_value(&size, "size_t", "size_t", false, false, false, false, false, "size");
    if (marshaled_arg) {
        cJSON_AddItemToArray(init_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(init_args_array, cJSON_CreateNull());
    }
    cJSON* marshaled_arg = marshal_value(&value, "char*", "char", true, false, false, false, false, "value");
    if (marshaled_arg) {
        cJSON_AddItemToArray(init_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(init_args_array, cJSON_CreateNull());
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)subject, type_name, obj_id, new_obj_json);
}

// Wrapper for: lv_subject_notify
void lv_subject_notify(lv_subject_t* subject) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_subject_notify' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_subject_set_color
void lv_subject_set_color(lv_subject_t* subject, struct lv_color_t color) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(subject);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_subject_set_color' called on unknown or unregistered opaque pointer %p.\n", (void*)subject);
        // Check if it's maybe NULL
        if (subject == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_subject_set_color (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "subject_set_color");
    cJSON *value_json = marshal_value(&color, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "color");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_subject_set_int
void lv_subject_set_int(lv_subject_t* subject, int32_t value) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(subject);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_subject_set_int' called on unknown or unregistered opaque pointer %p.\n", (void*)subject);
        // Check if it's maybe NULL
        if (subject == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_subject_set_int (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "subject_set_int");
    cJSON *value_json = marshal_value(&value, "int32_t", "int32_t", false, false, false, false, false, "value");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_subject_set_pointer
void lv_subject_set_pointer(lv_subject_t* subject, void* ptr) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(subject);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_subject_set_pointer' called on unknown or unregistered opaque pointer %p.\n", (void*)subject);
        // Check if it's maybe NULL
        if (subject == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_subject_set_pointer (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "subject_set_pointer");
    cJSON *value_json = marshal_value(&ptr, "void*", "void", true, false, false, false, false, "ptr");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_switch_create
lv_obj_t* lv_switch_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_switch_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_switch_get_orientation
lv_switch_orientation_t lv_switch_get_orientation(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_switch_get_orientation' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type lv_switch_orientation_t */
    return 0;
}

// Wrapper for: lv_switch_set_orientation
void lv_switch_set_orientation(lv_obj_t* obj, lv_switch_orientation_t orientation) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_switch_set_orientation' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_switch_set_orientation (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "switch_set_orientation");
    cJSON *value_json = marshal_value(&orientation, "lv_switch_orientation_t", "lv_switch_orientation_t", false, true, false, false, false, "orientation");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_table_clear_cell_ctrl
void lv_table_clear_cell_ctrl(lv_obj_t* obj, uint32_t row, uint32_t col, lv_table_cell_ctrl_t ctrl) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_table_clear_cell_ctrl' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_table_create
lv_obj_t* lv_table_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_table_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_table_get_cell_user_data
void* lv_table_get_cell_user_data(lv_obj_t* obj, uint16_t row, uint16_t col) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_table_get_cell_user_data' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_table_get_cell_value
char* lv_table_get_cell_value(lv_obj_t* obj, uint32_t row, uint32_t col) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_table_get_cell_value' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_table_get_column_count
uint32_t lv_table_get_column_count(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_table_get_column_count' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_table_get_column_width
int32_t lv_table_get_column_width(lv_obj_t* obj, uint32_t col) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_table_get_column_width' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_table_get_row_count
uint32_t lv_table_get_row_count(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_table_get_row_count' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_table_get_selected_cell
void lv_table_get_selected_cell(lv_obj_t* obj, uint32_t* row, uint32_t* col) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_table_get_selected_cell' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_table_has_cell_ctrl
bool lv_table_has_cell_ctrl(lv_obj_t* obj, uint32_t row, uint32_t col, lv_table_cell_ctrl_t ctrl) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_table_has_cell_ctrl' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_table_set_cell_ctrl
void lv_table_set_cell_ctrl(lv_obj_t* obj, uint32_t row, uint32_t col, lv_table_cell_ctrl_t ctrl) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_table_set_cell_ctrl' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_table_set_cell_ctrl (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "table_set_cell_ctrl");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&row, "uint32_t", "uint32_t", false, false, false, false, false, "row");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&col, "uint32_t", "uint32_t", false, false, false, false, false, "col");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&ctrl, "lv_table_cell_ctrl_t", "lv_table_cell_ctrl_t", false, true, false, false, false, "ctrl");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_table_set_cell_user_data
void lv_table_set_cell_user_data(lv_obj_t* obj, uint16_t row, uint16_t col, void* user_data) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_table_set_cell_user_data' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_table_set_cell_user_data (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "table_set_cell_user_data");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&row, "uint16_t", "uint16_t", false, false, false, false, false, "row");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&col, "uint16_t", "uint16_t", false, false, false, false, false, "col");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&user_data, "void*", "void", true, false, false, false, false, "user_data");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_table_set_cell_value
void lv_table_set_cell_value(lv_obj_t* obj, uint32_t row, uint32_t col, char* txt) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_table_set_cell_value' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_table_set_cell_value (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "table_set_cell_value");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&row, "uint32_t", "uint32_t", false, false, false, false, false, "row");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&col, "uint32_t", "uint32_t", false, false, false, false, false, "col");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&txt, "char*", "char", true, false, false, false, false, "txt");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_table_set_column_count
void lv_table_set_column_count(lv_obj_t* obj, uint32_t col_cnt) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_table_set_column_count' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_table_set_column_count (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "table_set_column_count");
    cJSON *value_json = marshal_value(&col_cnt, "uint32_t", "uint32_t", false, false, false, false, false, "col_cnt");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_table_set_column_width
void lv_table_set_column_width(lv_obj_t* obj, uint32_t col_id, int32_t w) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_table_set_column_width' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_table_set_column_width (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "table_set_column_width");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&col_id, "uint32_t", "uint32_t", false, false, false, false, false, "col_id");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&w, "int32_t", "int32_t", false, false, false, false, false, "w");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_table_set_row_count
void lv_table_set_row_count(lv_obj_t* obj, uint32_t row_cnt) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_table_set_row_count' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_table_set_row_count (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "table_set_row_count");
    cJSON *value_json = marshal_value(&row_cnt, "uint32_t", "uint32_t", false, false, false, false, false, "row_cnt");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_table_set_selected_cell
void lv_table_set_selected_cell(lv_obj_t* obj, uint16_t row, uint16_t col) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_table_set_selected_cell' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_table_set_selected_cell (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "table_set_selected_cell");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&row, "uint16_t", "uint16_t", false, false, false, false, false, "row");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&col, "uint16_t", "uint16_t", false, false, false, false, false, "col");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_tabview_add_tab
lv_obj_t* lv_tabview_add_tab(lv_obj_t* obj, char* name) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_tabview_add_tab");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&obj, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "obj");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&name, "char*", "char", true, false, false, false, false, "name");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_tabview_create
lv_obj_t* lv_tabview_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_tabview_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_tabview_get_content
lv_obj_t* lv_tabview_get_content(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_tabview_get_content' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_tabview_get_tab_active
uint32_t lv_tabview_get_tab_active(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_tabview_get_tab_active' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_tabview_get_tab_bar
lv_obj_t* lv_tabview_get_tab_bar(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_tabview_get_tab_bar' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_tabview_get_tab_count
uint32_t lv_tabview_get_tab_count(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_tabview_get_tab_count' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_tabview_rename_tab
void lv_tabview_rename_tab(lv_obj_t* obj, uint32_t idx, char* new_name) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_tabview_rename_tab' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_tabview_set_active
void lv_tabview_set_active(lv_obj_t* obj, uint32_t idx, lv_anim_enable_t anim_en) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_tabview_set_active' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_tabview_set_active (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "tabview_set_active");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&idx, "uint32_t", "uint32_t", false, false, false, false, false, "idx");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&anim_en, "lv_anim_enable_t", "lv_anim_enable_t", false, false, false, false, false, "anim_en");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_tabview_set_tab_bar_position
void lv_tabview_set_tab_bar_position(lv_obj_t* obj, lv_dir_t dir) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_tabview_set_tab_bar_position' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_tabview_set_tab_bar_position (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "tabview_set_tab_bar_position");
    cJSON *value_json = marshal_value(&dir, "lv_dir_t", "lv_dir_t", false, true, false, false, false, "dir");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_tabview_set_tab_bar_size
void lv_tabview_set_tab_bar_size(lv_obj_t* obj, int32_t size) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_tabview_set_tab_bar_size' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_tabview_set_tab_bar_size (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "tabview_set_tab_bar_size");
    cJSON *value_json = marshal_value(&size, "int32_t", "int32_t", false, false, false, false, false, "size");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_text_get_size
void lv_text_get_size(struct lv_point_t* size_res, char* text, lv_font_t* font, int32_t letter_space, int32_t line_space, int32_t max_width, lv_text_flag_t flag) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_text_get_size' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_text_get_width
int32_t lv_text_get_width(char* txt, uint32_t length, lv_font_t* font, int32_t letter_space) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_text_get_width' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_text_get_width_with_flags
int32_t lv_text_get_width_with_flags(char* txt, uint32_t length, lv_font_t* font, int32_t letter_space, lv_text_flag_t flags) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_text_get_width_with_flags' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_text_is_cmd
bool lv_text_is_cmd(lv_text_cmd_state_t* state, uint32_t c) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_text_is_cmd' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_textarea_add_char
void lv_textarea_add_char(lv_obj_t* obj, uint32_t c) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_textarea_add_char' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_textarea_add_char (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "textarea_add_char");
    cJSON *value_json = marshal_value(&c, "uint32_t", "uint32_t", false, false, false, false, false, "c");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_textarea_add_text
void lv_textarea_add_text(lv_obj_t* obj, char* txt) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_textarea_add_text' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_textarea_add_text (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "textarea_add_text");
    cJSON *value_json = marshal_value(&txt, "char*", "char", true, false, false, false, false, "txt");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_textarea_clear_selection
void lv_textarea_clear_selection(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_clear_selection' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_textarea_create
lv_obj_t* lv_textarea_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_textarea_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_textarea_cursor_down
void lv_textarea_cursor_down(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_cursor_down' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_textarea_cursor_left
void lv_textarea_cursor_left(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_cursor_left' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_textarea_cursor_right
void lv_textarea_cursor_right(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_cursor_right' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_textarea_cursor_up
void lv_textarea_cursor_up(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_cursor_up' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_textarea_delete_char
void lv_textarea_delete_char(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_delete_char' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_textarea_delete_char_forward
void lv_textarea_delete_char_forward(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_delete_char_forward' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_textarea_get_accepted_chars
char* lv_textarea_get_accepted_chars(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_get_accepted_chars' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_textarea_get_current_char
uint32_t lv_textarea_get_current_char(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_get_current_char' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_textarea_get_cursor_click_pos
bool lv_textarea_get_cursor_click_pos(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_get_cursor_click_pos' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_textarea_get_cursor_pos
uint32_t lv_textarea_get_cursor_pos(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_get_cursor_pos' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_textarea_get_label
lv_obj_t* lv_textarea_get_label(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_get_label' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_textarea_get_max_length
uint32_t lv_textarea_get_max_length(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_get_max_length' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_textarea_get_one_line
bool lv_textarea_get_one_line(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_get_one_line' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_textarea_get_password_bullet
char* lv_textarea_get_password_bullet(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_get_password_bullet' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_textarea_get_password_mode
bool lv_textarea_get_password_mode(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_get_password_mode' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_textarea_get_password_show_time
uint32_t lv_textarea_get_password_show_time(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_get_password_show_time' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_textarea_get_placeholder_text
char* lv_textarea_get_placeholder_text(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_get_placeholder_text' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_textarea_get_text
char* lv_textarea_get_text(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_get_text' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_textarea_get_text_selection
bool lv_textarea_get_text_selection(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_get_text_selection' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_textarea_set_accepted_chars
void lv_textarea_set_accepted_chars(lv_obj_t* obj, char* list) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_textarea_set_accepted_chars' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_textarea_set_accepted_chars (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "textarea_set_accepted_chars");
    cJSON *value_json = marshal_value(&list, "char*", "char", true, false, false, false, false, "list");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_textarea_set_align
void lv_textarea_set_align(lv_obj_t* obj, lv_text_align_t align) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_textarea_set_align' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_textarea_set_align (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "textarea_set_align");
    cJSON *value_json = marshal_value(&align, "lv_text_align_t", "lv_text_align_t", false, true, false, false, false, "align");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_textarea_set_cursor_click_pos
void lv_textarea_set_cursor_click_pos(lv_obj_t* obj, bool en) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_textarea_set_cursor_click_pos' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_textarea_set_cursor_click_pos (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "textarea_set_cursor_click_pos");
    cJSON *value_json = marshal_value(&en, "bool", "bool", false, false, false, false, false, "en");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_textarea_set_cursor_pos
void lv_textarea_set_cursor_pos(lv_obj_t* obj, int32_t pos) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_textarea_set_cursor_pos' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_textarea_set_cursor_pos (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "textarea_set_cursor_pos");
    cJSON *value_json = marshal_value(&pos, "int32_t", "int32_t", false, false, false, false, false, "pos");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_textarea_set_insert_replace
void lv_textarea_set_insert_replace(lv_obj_t* obj, char* txt) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_textarea_set_insert_replace' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_textarea_set_insert_replace (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "textarea_set_insert_replace");
    cJSON *value_json = marshal_value(&txt, "char*", "char", true, false, false, false, false, "txt");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_textarea_set_max_length
void lv_textarea_set_max_length(lv_obj_t* obj, uint32_t num) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_textarea_set_max_length' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_textarea_set_max_length (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "textarea_set_max_length");
    cJSON *value_json = marshal_value(&num, "uint32_t", "uint32_t", false, false, false, false, false, "num");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_textarea_set_one_line
void lv_textarea_set_one_line(lv_obj_t* obj, bool en) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_textarea_set_one_line' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_textarea_set_one_line (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "textarea_set_one_line");
    cJSON *value_json = marshal_value(&en, "bool", "bool", false, false, false, false, false, "en");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_textarea_set_password_bullet
void lv_textarea_set_password_bullet(lv_obj_t* obj, char* bullet) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_textarea_set_password_bullet' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_textarea_set_password_bullet (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "textarea_set_password_bullet");
    cJSON *value_json = marshal_value(&bullet, "char*", "char", true, false, false, false, false, "bullet");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_textarea_set_password_mode
void lv_textarea_set_password_mode(lv_obj_t* obj, bool en) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_textarea_set_password_mode' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_textarea_set_password_mode (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "textarea_set_password_mode");
    cJSON *value_json = marshal_value(&en, "bool", "bool", false, false, false, false, false, "en");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_textarea_set_password_show_time
void lv_textarea_set_password_show_time(lv_obj_t* obj, uint32_t time) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_textarea_set_password_show_time' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_textarea_set_password_show_time (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "textarea_set_password_show_time");
    cJSON *value_json = marshal_value(&time, "uint32_t", "uint32_t", false, false, false, false, false, "time");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_textarea_set_placeholder_text
void lv_textarea_set_placeholder_text(lv_obj_t* obj, char* txt) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_textarea_set_placeholder_text' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_textarea_set_placeholder_text (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "textarea_set_placeholder_text");
    cJSON *value_json = marshal_value(&txt, "char*", "char", true, false, false, false, false, "txt");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_textarea_set_text
void lv_textarea_set_text(lv_obj_t* obj, char* txt) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_textarea_set_text' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_textarea_set_text (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "textarea_set_text");
    cJSON *value_json = marshal_value(&txt, "char*", "char", true, false, false, false, false, "txt");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_textarea_set_text_selection
void lv_textarea_set_text_selection(lv_obj_t* obj, bool en) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(obj);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_textarea_set_text_selection' called on unknown or unregistered opaque pointer %p.\n", (void*)obj);
        // Check if it's maybe NULL
        if (obj == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_textarea_set_text_selection (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "textarea_set_text_selection");
    cJSON *value_json = marshal_value(&en, "bool", "bool", false, false, false, false, false, "en");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_textarea_text_is_selected
bool lv_textarea_text_is_selected(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_textarea_text_is_selected' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_theme_default_deinit
void lv_theme_default_deinit(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_theme_default_deinit' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_theme_default_get
lv_theme_t* lv_theme_default_get(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_theme_default_get' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_theme_t* */
    return NULL;
}

// Wrapper for: lv_theme_default_init
lv_theme_t* lv_theme_default_init(lv_display_t* disp, struct lv_color_t color_primary, struct lv_color_t color_secondary, bool dark, lv_font_t* font) {
    /* Wrapper Type: init */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in init"); assert(false); /* Cannot return if void */ return; }
    const char* type_name = "lv_display_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "initializer_func", "lv_theme_default_init");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *init_args_array = cJSON_CreateArray();
    if (!init_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "init_args", init_args_array);
    cJSON* marshaled_arg = marshal_value(&color_primary, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "color_primary");
    if (marshaled_arg) {
        cJSON_AddItemToArray(init_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(init_args_array, cJSON_CreateNull());
    }
    cJSON* marshaled_arg = marshal_value(&color_secondary, "struct lv_color_t", "lv_color_t", false, false, true, false, false, "color_secondary");
    if (marshaled_arg) {
        cJSON_AddItemToArray(init_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(init_args_array, cJSON_CreateNull());
    }
    cJSON* marshaled_arg = marshal_value(&dark, "bool", "bool", false, false, false, false, false, "dark");
    if (marshaled_arg) {
        cJSON_AddItemToArray(init_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(init_args_array, cJSON_CreateNull());
    }
    cJSON* marshaled_arg = marshal_value(&font, "lv_font_t*", "lv_font_t", true, false, false, false, true, "font");
    if (marshaled_arg) {
        cJSON_AddItemToArray(init_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(init_args_array, cJSON_CreateNull());
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)disp, type_name, obj_id, new_obj_json);
    /* Warning: Init function 'lv_theme_default_init' has non-void return type 'lv_theme_t*'. Returning default. */
    return NULL;
}

// Wrapper for: lv_theme_default_is_inited
bool lv_theme_default_is_inited(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_theme_default_is_inited' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_theme_get_color_primary
struct lv_color_t lv_theme_get_color_primary(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_theme_get_color_primary' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_t */
    return 0;
}

// Wrapper for: lv_theme_get_color_secondary
struct lv_color_t lv_theme_get_color_secondary(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_theme_get_color_secondary' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type struct lv_color_t */
    return 0;
}

// Wrapper for: lv_theme_get_font_large
lv_font_t* lv_theme_get_font_large(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_theme_get_font_large' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_font_t* */
    return NULL;
}

// Wrapper for: lv_theme_get_font_normal
lv_font_t* lv_theme_get_font_normal(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_theme_get_font_normal' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_font_t* */
    return NULL;
}

// Wrapper for: lv_theme_get_font_small
lv_font_t* lv_theme_get_font_small(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_theme_get_font_small' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_font_t* */
    return NULL;
}

// Wrapper for: lv_theme_get_from_obj
lv_theme_t* lv_theme_get_from_obj(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_theme_get_from_obj' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_theme_t* */
    return NULL;
}

// Wrapper for: lv_theme_mono_deinit
void lv_theme_mono_deinit(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_theme_mono_deinit' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_theme_mono_init
lv_theme_t* lv_theme_mono_init(lv_display_t* disp, bool dark_bg, lv_font_t* font) {
    /* Wrapper Type: init */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in init"); assert(false); /* Cannot return if void */ return; }
    const char* type_name = "lv_display_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "initializer_func", "lv_theme_mono_init");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *init_args_array = cJSON_CreateArray();
    if (!init_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "init_args", init_args_array);
    cJSON* marshaled_arg = marshal_value(&dark_bg, "bool", "bool", false, false, false, false, false, "dark_bg");
    if (marshaled_arg) {
        cJSON_AddItemToArray(init_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(init_args_array, cJSON_CreateNull());
    }
    cJSON* marshaled_arg = marshal_value(&font, "lv_font_t*", "lv_font_t", true, false, false, false, true, "font");
    if (marshaled_arg) {
        cJSON_AddItemToArray(init_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(init_args_array, cJSON_CreateNull());
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)disp, type_name, obj_id, new_obj_json);
    /* Warning: Init function 'lv_theme_mono_init' has non-void return type 'lv_theme_t*'. Returning default. */
    return NULL;
}

// Wrapper for: lv_theme_mono_is_inited
bool lv_theme_mono_is_inited(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_theme_mono_is_inited' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_theme_set_parent
void lv_theme_set_parent(lv_theme_t* new_theme, lv_theme_t* parent) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(new_theme);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_theme_set_parent' called on unknown or unregistered opaque pointer %p.\n", (void*)new_theme);
        // Check if it's maybe NULL
        if (new_theme == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_theme_set_parent (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "theme_set_parent");
    cJSON *value_json = marshal_value(&parent, "lv_theme_t*", "lv_theme_t", true, false, false, false, true, "parent");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_theme_simple_deinit
void lv_theme_simple_deinit(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_theme_simple_deinit' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_theme_simple_get
lv_theme_t* lv_theme_simple_get(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_theme_simple_get' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_theme_t* */
    return NULL;
}

// Wrapper for: lv_theme_simple_init
lv_theme_t* lv_theme_simple_init(lv_display_t* disp) {
    /* Wrapper Type: init */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in init"); assert(false); /* Cannot return if void */ return; }
    const char* type_name = "lv_display_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "initializer_func", "lv_theme_simple_init");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *init_args_array = cJSON_CreateArray();
    if (!init_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return; }
    cJSON_AddItemToObject(new_obj_json, "init_args", init_args_array);
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)disp, type_name, obj_id, new_obj_json);
    /* Warning: Init function 'lv_theme_simple_init' has non-void return type 'lv_theme_t*'. Returning default. */
    return NULL;
}

// Wrapper for: lv_theme_simple_is_inited
bool lv_theme_simple_is_inited(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_theme_simple_is_inited' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_tileview_add_tile
lv_obj_t* lv_tileview_add_tile(lv_obj_t* tv, uint8_t col_id, uint8_t row_id, lv_dir_t dir) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_tileview_add_tile");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&tv, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "tv");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&col_id, "uint8_t", "uint8_t", false, false, false, false, false, "col_id");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&row_id, "uint8_t", "uint8_t", false, false, false, false, false, "row_id");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&dir, "lv_dir_t", "lv_dir_t", false, true, false, false, false, "dir");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_tileview_create
lv_obj_t* lv_tileview_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_tileview_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_tileview_get_tile_active
lv_obj_t* lv_tileview_get_tile_active(lv_obj_t* obj) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_tileview_get_tile_active' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_tileview_set_tile
void lv_tileview_set_tile(lv_obj_t* tv, lv_obj_t* tile_obj, lv_anim_enable_t anim_en) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(tv);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_tileview_set_tile' called on unknown or unregistered opaque pointer %p.\n", (void*)tv);
        // Check if it's maybe NULL
        if (tv == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_tileview_set_tile (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "tileview_set_tile");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&tile_obj, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "tile_obj");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&anim_en, "lv_anim_enable_t", "lv_anim_enable_t", false, false, false, false, false, "anim_en");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_tileview_set_tile_by_index
void lv_tileview_set_tile_by_index(lv_obj_t* tv, uint32_t col_id, uint32_t row_id, lv_anim_enable_t anim_en) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(tv);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_tileview_set_tile_by_index' called on unknown or unregistered opaque pointer %p.\n", (void*)tv);
        // Check if it's maybe NULL
        if (tv == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_tileview_set_tile_by_index (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "tileview_set_tile_by_index");
    cJSON *values_array = cJSON_CreateArray();
    if (values_array) {
        cJSON *val_0 = marshal_value(&col_id, "uint32_t", "uint32_t", false, false, false, false, false, "col_id");
        if (val_0) cJSON_AddItemToArray(values_array, val_0); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_1 = marshal_value(&row_id, "uint32_t", "uint32_t", false, false, false, false, false, "row_id");
        if (val_1) cJSON_AddItemToArray(values_array, val_1); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON *val_2 = marshal_value(&anim_en, "lv_anim_enable_t", "lv_anim_enable_t", false, false, false, false, false, "anim_en");
        if (val_2) cJSON_AddItemToArray(values_array, val_2); else cJSON_AddItemToArray(values_array, cJSON_CreateNull());
        cJSON_AddItemToObject(prop_entry, "value", values_array);
    } else {
        perror("Failed to create values array for setter");
        cJSON_AddNullToObject(prop_entry, "value"); // Indicate missing values
    }
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_timer_delete
void lv_timer_delete(lv_timer_t* timer) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_timer_delete' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_timer_enable
void lv_timer_enable(bool en) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_timer_enable' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_timer_get_idle
uint32_t lv_timer_get_idle(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_timer_get_idle' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_timer_get_next
lv_timer_t* lv_timer_get_next(lv_timer_t* timer) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_timer_get_next' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_timer_t* */
    return NULL;
}

// Wrapper for: lv_timer_get_paused
bool lv_timer_get_paused(lv_timer_t* timer) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_timer_get_paused' classified as 'other'. No JSON generated. */
    /* Returning false for bool */
    return false;
}

// Wrapper for: lv_timer_get_time_until_next
uint32_t lv_timer_get_time_until_next(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_timer_get_time_until_next' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type uint32_t */
    return 0;
}

// Wrapper for: lv_timer_get_user_data
void* lv_timer_get_user_data(lv_timer_t* timer) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_timer_get_user_data' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_timer_pause
void lv_timer_pause(lv_timer_t* timer) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_timer_pause' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_timer_periodic_handler
void lv_timer_periodic_handler(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_timer_periodic_handler' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_timer_ready
void lv_timer_ready(lv_timer_t* timer) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_timer_ready' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_timer_reset
void lv_timer_reset(lv_timer_t* timer) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_timer_reset' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_timer_resume
void lv_timer_resume(lv_timer_t* timer) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_timer_resume' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_timer_set_auto_delete
void lv_timer_set_auto_delete(lv_timer_t* timer, bool auto_delete) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(timer);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_timer_set_auto_delete' called on unknown or unregistered opaque pointer %p.\n", (void*)timer);
        // Check if it's maybe NULL
        if (timer == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_timer_set_auto_delete (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_auto_delete");
    cJSON *value_json = marshal_value(&auto_delete, "bool", "bool", false, false, false, false, false, "auto_delete");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_timer_set_period
void lv_timer_set_period(lv_timer_t* timer, uint32_t period) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(timer);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_timer_set_period' called on unknown or unregistered opaque pointer %p.\n", (void*)timer);
        // Check if it's maybe NULL
        if (timer == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_timer_set_period (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_period");
    cJSON *value_json = marshal_value(&period, "uint32_t", "uint32_t", false, false, false, false, false, "period");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_timer_set_repeat_count
void lv_timer_set_repeat_count(lv_timer_t* timer, int32_t repeat_count) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(timer);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_timer_set_repeat_count' called on unknown or unregistered opaque pointer %p.\n", (void*)timer);
        // Check if it's maybe NULL
        if (timer == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_timer_set_repeat_count (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_repeat_count");
    cJSON *value_json = marshal_value(&repeat_count, "int32_t", "int32_t", false, false, false, false, false, "repeat_count");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_timer_set_user_data
void lv_timer_set_user_data(lv_timer_t* timer, void* user_data) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(timer);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_timer_set_user_data' called on unknown or unregistered opaque pointer %p.\n", (void*)timer);
        // Check if it's maybe NULL
        if (timer == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_timer_set_user_data (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "set_user_data");
    cJSON *value_json = marshal_value(&user_data, "void*", "void", true, false, false, false, false, "user_data");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_tiny_ttf_create_data
lv_font_t* lv_tiny_ttf_create_data(void* data, size_t data_size, int32_t font_size) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_tiny_ttf_create_data' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_font_t* */
    return NULL;
}

// Wrapper for: lv_tiny_ttf_create_data_ex
lv_font_t* lv_tiny_ttf_create_data_ex(void* data, size_t data_size, int32_t font_size, lv_font_kerning_t kerning, size_t cache_size) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_tiny_ttf_create_data_ex' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_font_t* */
    return NULL;
}

// Wrapper for: lv_tiny_ttf_destroy
void lv_tiny_ttf_destroy(lv_font_t* font) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_tiny_ttf_destroy' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_tiny_ttf_set_size
void lv_tiny_ttf_set_size(lv_font_t* font, int32_t font_size) {
    /* Wrapper Type: setter */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *target_obj_json = find_json_object(font);
    if (!target_obj_json) {
        fprintf(stderr, "Error: Setter 'lv_tiny_ttf_set_size' called on unknown or unregistered opaque pointer %p.\n", (void*)font);
        // Check if it's maybe NULL
        if (font == NULL) fprintf(stderr, "       (Pointer was NULL)\n");
        // Abort or skip? Let's skip and return default if needed.
        return;
    }
    cJSON *props_array = cJSON_GetObjectItem(target_obj_json, "props");
    if (!props_array || !cJSON_IsArray(props_array)) {
       fprintf(stderr, "Error: 'props' array missing or invalid for object in lv_tiny_ttf_set_size (ID: %s)\n", cJSON_GetStringValue(cJSON_GetObjectItem(target_obj_json, "id")));
       // Attempt to fix by creating the array?
       if (props_array) cJSON_DeleteItemFromObject(target_obj_json, "props");
       props_array = cJSON_CreateArray();
       if (props_array) cJSON_AddItemToObject(target_obj_json, "props", props_array);
       else { /* Still failed, skip */ 
 return;
        }}
    }
    cJSON *prop_entry = cJSON_CreateObject();
    if (!prop_entry) { perror("cJSON_CreateObject failed for prop_entry"); assert(false); /* Skip this call */ return; }
    cJSON_AddStringToObject(prop_entry, "name", "tiny_ttf_set_size");
    cJSON *value_json = marshal_value(&font_size, "int32_t", "int32_t", false, false, false, false, false, "font_size");
    if (value_json) cJSON_AddItemToObject(prop_entry, "value", value_json); else cJSON_AddNullToObject(prop_entry, "value");
    cJSON_AddItemToArray(props_array, prop_entry);
}

// Wrapper for: lv_tjpgd_deinit
void lv_tjpgd_deinit(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_tjpgd_deinit' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_tjpgd_init
void lv_tjpgd_init(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_tjpgd_init' classified as 'other'. No JSON generated. */
    return;
}

// Wrapper for: lv_trigo_cos
int32_t lv_trigo_cos(int16_t angle) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_trigo_cos' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_trigo_sin
int32_t lv_trigo_sin(int16_t angle) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_trigo_sin' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int32_t */
    return 0;
}

// Wrapper for: lv_utils_bsearch
void* lv_utils_bsearch(void* key, void* base, size_t n, size_t size, cmp cmp) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_utils_bsearch' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}

// Wrapper for: lv_version_info
char* lv_version_info(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_version_info' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type char* */
    return NULL;
}

// Wrapper for: lv_version_major
int lv_version_major(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_version_major' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int */
    return 0;
}

// Wrapper for: lv_version_minor
int lv_version_minor(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_version_minor' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int */
    return 0;
}

// Wrapper for: lv_version_patch
int lv_version_patch(void) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_version_patch' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int */
    return 0;
}

// Wrapper for: lv_vsnprintf
int lv_vsnprintf(char* buffer, size_t count, char* format, va_list va) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_vsnprintf' classified as 'other'. No JSON generated. */
    /* Returning 0 for integer-like type int */
    return 0;
}

// Wrapper for: lv_win_add_button
lv_obj_t* lv_win_add_button(lv_obj_t* win, void* icon, int32_t btn_w) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_win_add_button");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&win, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "win");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&icon, "void*", "void", true, false, false, false, false, "icon");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&btn_w, "int32_t", "int32_t", false, false, false, false, false, "btn_w");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_win_add_title
lv_obj_t* lv_win_add_title(lv_obj_t* win, char* txt) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_win_add_title");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&win, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "win");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON* marshaled_arg = marshal_value(&txt, "char*", "char", true, false, false, false, false, "txt");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_win_create
lv_obj_t* lv_win_create(lv_obj_t* parent) {
    /* Wrapper Type: constructor */
    if (!g_root_json_array) emul_lvgl_init();
    cJSON *new_obj_json = cJSON_CreateObject();
    if (!new_obj_json) { perror("cJSON_CreateObject failed in constructor"); assert(false); return NULL; } // Return NULL on failure
    const char* type_name = "lv_obj_t";
    char* obj_id = generate_unique_id(type_name);
    if (!obj_id) { cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddStringToObject(new_obj_json, "id", obj_id);
    cJSON_AddStringToObject(new_obj_json, "type", type_name);
    cJSON_AddStringToObject(new_obj_json, "constructor", "lv_win_create");
    cJSON *props_array = cJSON_CreateArray();
    if (!props_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "props", props_array);
    cJSON *constructor_args_array = cJSON_CreateArray();
    if (!constructor_args_array) { perror("cJSON_CreateArray failed"); free(obj_id); cJSON_Delete(new_obj_json); assert(false); return NULL; }
    cJSON_AddItemToObject(new_obj_json, "constructor_args", constructor_args_array);
    cJSON* marshaled_arg = marshal_value(&parent, "lv_obj_t*", "lv_obj_t", true, false, false, false, true, "parent");
    if (marshaled_arg) {
        cJSON_AddItemToArray(constructor_args_array, marshaled_arg);
    } else {
        cJSON_AddItemToArray(constructor_args_array, cJSON_CreateNull()); // Add null if marshal failed
    }
    cJSON_AddItemToArray(g_root_json_array, new_obj_json);
    register_opaque_object((const void*)new_obj_json, type_name, obj_id, new_obj_json);
    return (lv_obj_t*)new_obj_json;
}

// Wrapper for: lv_win_get_content
lv_obj_t* lv_win_get_content(lv_obj_t* win) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_win_get_content' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_win_get_header
lv_obj_t* lv_win_get_header(lv_obj_t* win) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_win_get_header' classified as 'other'. No JSON generated. */
    /* Returning NULL for opaque pointer type lv_obj_t* */
    return NULL;
}

// Wrapper for: lv_zalloc
void* lv_zalloc(size_t size) {
    /* Wrapper Type: other */
    if (!g_root_json_array) emul_lvgl_init();
    /* Function 'lv_zalloc' classified as 'other'. No JSON generated. */
    /* Returning NULL for pointer type void* */
    return NULL;
}