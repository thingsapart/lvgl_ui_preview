# generator.py
import argparse
import json
import logging
import os
from pathlib import Path

import api_parser
import type_utils
from code_gen import invocation, unmarshal, registry, renderer

# Basic Logging Setup
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
logger = logging.getLogger(__name__)

# --- C File Templates ---

C_HEADER_TEMPLATE = """
#ifndef LVGL_JSON_RENDERER_H
#define LVGL_JSON_RENDERER_H

#ifdef __cplusplus
extern "C" {{
#endif

#include <lvgl.h>
#include <cjson/cJSON.h> // Include for cJSON types used in logging helper
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h> // For fprintf used in logging macros

// --- Logging Macros ---
// Helper to convert cJSON node to string (defined in .c file)
// NOTE: Caller must free the returned string using cJSON_free()
char* json_node_to_string(cJSON *node);

// Define standard log macros
#ifndef LOG_ERR
#define LOG_ERR(fmt, ...) fprintf(stderr, "ERROR: [%s:%d] " fmt "\\n", __FILE__, __LINE__, ##__VA_ARGS__)
#endif
#ifndef LOG_WARN
#define LOG_WARN(fmt, ...) fprintf(stderr, "WARN: [%s:%d] " fmt "\\n", __FILE__, __LINE__, ##__VA_ARGS__)
#endif
#ifndef LOG_INFO
#define LOG_INFO(fmt, ...) printf("INFO: [%s:%d] " fmt "\\n", __FILE__, __LINE__, ##__VA_ARGS__)
#endif
#ifndef LOG_DEBUG // Enable with -DLVGL_JSON_RENDERER_DEBUG
#ifdef LVGL_JSON_RENDERER_DEBUG
#define LOG_DEBUG(fmt, ...) printf("DEBUG: [%s:%d] " fmt "\\n", __FILE__, __LINE__, ##__VA_ARGS__)
#else
#define LOG_DEBUG(fmt, ...) (void)0
#endif
#endif

// Define log macros that include JSON context
#ifndef LOG_ERR_JSON
#define LOG_ERR_JSON(node, fmt, ...) do {{ \\
        char* _json_str = json_node_to_string(node); \\
        fprintf(stderr, "ERROR: [%s:%d] " fmt " [Near JSON: %s]\\n", __FILE__, __LINE__, ##__VA_ARGS__, _json_str ? _json_str : " N/A"); \\
        if (_json_str) cJSON_free(_json_str); \\
    }} while(0)
#endif
#ifndef LOG_WARN_JSON
#define LOG_WARN_JSON(node, fmt, ...) do {{ \\
        char* _json_str = json_node_to_string(node); \\
        fprintf(stderr, "WARN: [%s:%d] " fmt " [Near JSON: %s]\\n", __FILE__, __LINE__, ##__VA_ARGS__, _json_str ? _json_str : " N/A"); \\
        if (_json_str) cJSON_free(_json_str); \\
    }} while(0)
#endif
// Add LOG_INFO_JSON, LOG_DEBUG_JSON if needed

#define LV_MALLOC lv_malloc
#define LV_FREE lv_free


// --- Public API ---

/**
 * @brief Renders a UI described by a cJSON object tree.
 *
 * Parses the JSON definition and creates corresponding LVGL objects and applies properties.
 * Assumes cJSON library is linked. Requires LVGL to be initialized beforehand.
 *
 * @param root_json The root cJSON object (must be an array of objects or a single object).
 * @param implicit_root_parent The LVGL parent object for all top-level elements defined in the JSON.
 *                             If NULL, lv_screen_active() will be used.
 * @return true if rendering was successful, false otherwise. Errors are logged.
 */
bool lvgl_json_render_ui(cJSON *root_json, lv_obj_t *implicit_root_parent);

/**
 * @brief Registers a pointer with a given name. Used for referencing objects/styles by ID ('@name').
 *
 * @param name The name to register the pointer under (should not include '@').
 * @param ptr The pointer to register.
 */
void lvgl_json_register_ptr(const char *name, void *ptr);

/**
 * @brief Retrieves a previously registered pointer by name.
 *
 * @param name The name of the pointer to retrieve (should not include '@').
 * @return The registered pointer, or NULL if not found.
 */
void* lvgl_json_get_registered_ptr(const char *name);

/**
 * @brief Clears all entries from the pointer registry.
 */
void lvgl_json_registry_clear();

// --- Custom Managed Object Creator Prototypes ---
// These are generated by registry.py and added to invoke table,
// direct prototypes not strictly needed but can be useful for documentation/linting.
{custom_creator_prototypes}

#ifdef __cplusplus
}} /*extern "C"*/
#endif

#endif /* LVGL_JSON_RENDERER_H */
"""

C_SOURCE_TEMPLATE = """
#include "lvgl_json_renderer.h"
#include <string.h> // For strcmp, strchr, strncpy, strlen etc.
#include <stdio.h>  // For snprintf, logging
#include <stdlib.h> // For strtoul

// LVGL functions used internally (ensure they are linked)
// extern lv_obj_t * lv_screen_active(void); // Declared in lvgl.h
// extern void *lv_malloc(size_t size); // Declared in lv_mem.h / lv_conf.h
// extern void lv_free(void *ptr);     // Declared in lv_mem.h / lv_conf.h
// extern char *lv_strdup(const char *str); // Declared in lv_mem.h / lv_conf.h

// --- Logging Helper ---
// Convert cJSON node to a compact string for logging (caller must free result)
char* json_node_to_string(cJSON *node) {{
    if (!node) {{
        // Use lv_strdup if linked, otherwise plain strdup (requires stdlib.h)
        #if defined(LV_USE_STDLIB_MALLOC) && LV_USE_STDLIB_MALLOC == LV_STDLIB_BUILTIN
            return lv_strdup("NULL");
        #else
            // Fallback or define lv_strdup wrapper for standard malloc/strdup
             char *null_str = (char*)malloc(5); if(null_str) strcpy(null_str, "NULL"); return null_str;
        #endif
    }}
    // PrintUnformatted is more compact for logs
    char *str = cJSON_PrintUnformatted(node);
    if (!str) {{
        #if defined(LV_USE_STDLIB_MALLOC) && LV_USE_STDLIB_MALLOC == LV_STDLIB_BUILTIN
            return lv_strdup("{{\\\"error\\\":\\\"Failed to print JSON\\\"}}");
        #else
             char *err_str = (char*)malloc(30); if(err_str) strcpy(err_str, "{{\\\"error\\\":\\\"Failed to print JSON\\\"}}"); return err_str;
        #endif
    }}
    // Optional: Truncate very long strings if needed
    // const int max_len = 120;
    // if (strlen(str) > max_len) {{ str[max_len-3] = '.'; str[max_len-2] = '.'; str[max_len-1] = '.'; str[max_len] = '\\0'; }}
    return str; // cJSON_Print... allocates, caller must free using cJSON_free
}}

// --- Invocation Table Data Structures ---
{invocation_table_def}

// --- Configuration ---
// Add any compile-time configuration here if needed

// --- Pointer Registry Implementation ---
{registry_code}

// --- Enum Unmarshaling ---
{enum_unmarshal_code}

// --- Primitive Unmarshalers ---
{primitive_unmarshal_code}

// --- Custom Unmarshalers ---
{custom_unmarshal_code}

// --- Forward declaration needed by invocation helpers ---
static const invoke_table_entry_t* find_invoke_entry(const char *name);
static bool unmarshal_value(cJSON *json_value, const char *expected_c_type, void *dest);

// --- Invocation Helper Functions ---
{invocation_helpers_code}

// --- Invocation Table ---
{invocation_table_code}

// --- Function Lookup Implementation ---
{find_function_code}

// --- Main Value Unmarshaler Implementation ---
{main_unmarshaler_code}

// --- Custom Managed Object Creators Implementation ---
{custom_creators_code}

// --- JSON UI Renderer Implementation ---
{renderer_code}

"""


def main():
    parser = argparse.ArgumentParser(description="LVGL JSON UI Renderer Library Generator")
    parser.add_argument("-a", "--api-json", required=True, help="Path to the LVGL API JSON definition file.")
    parser.add_argument("-o", "--output-dir", default="output", help="Directory to write the generated C library files.")
    # Add arguments for include/exclude lists here if needed
    args = parser.parse_args()

    output_dir = Path(args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    logger.info(f"Parsing API definition from: {args.api_json}")
    # TODO: Pass include/exclude lists from args to parse_api
    api_info = api_parser.parse_api(args.api_json)
    if not api_info:
        logger.critical("Failed to parse API information. Exiting.")
        return 1

    # --- Generate Code Sections ---
    logger.info("Generating pointer registry...")
    registry_c = registry.generate_registry(use_hash_map=True) # Use hash map implementation

    logger.info("Generating enum unmarshalers...")
    enum_unmarshal_c = unmarshal.generate_enum_unmarshalers(api_info['enums'], api_info['enum_members'])

    logger.info("Generating primitive unmarshalers...")
    primitive_unmarshal_c = unmarshal.generate_primitive_unmarshalers()

    logger.info("Generating custom unmarshalers...")
    custom_unmarshal_c = unmarshal.generate_custom_unmarshalers(api_info)

    # Find init funcs and generate managed creators *code*
    logger.info("Finding init functions...")
    init_functions = registry.find_init_functions(api_info['functions'])
    logger.info("Generating custom creators code...")
    custom_creators_c = registry.generate_custom_creators(init_functions, api_info)

    # --- Crucial: Add generated MANAGED creator functions to the list of functions ---
    # --- BEFORE generating signatures, so they get included in the invoke table ---
    managed_creator_names = set()
    custom_creators_map_for_renderer = {} # Map for renderer { "style": "lv_style_create_managed", ... }
    custom_creator_prototypes_h = ""
    logger.info("Adding managed creators to API function list...")
    for func in init_functions:
         # Reconstruct the generated function signature
         arg_type_info = func['_resolved_arg_types'][0] # e.g., ('lv_style_t', 1, False)
         arg_type = arg_type_info[0]
         creator_func_name = f"{arg_type[:-2]}_create_managed"
         managed_creator_names.add(creator_func_name)

         # Map for renderer type->funcname
         widget_name = type_utils.lvgl_type_to_widget_name(arg_type)
         if widget_name: custom_creators_map_for_renderer[widget_name] = creator_func_name

         # Prototype for header
         custom_creator_prototypes_h += f"/** @brief Creates a managed {arg_type} identified by name. */\n"
         custom_creator_prototypes_h += f"extern {arg_type}* {creator_func_name}(const char *name);\n"

         # Create a mock API function entry for the generator
         # Ensure this structure matches what api_parser produces
         api_info['functions'].append({
             "name": creator_func_name,
             "json_type": "function",
             "type": { # Return type lv_xxx_t*
                  "json_type": "ret_type",
                  "type": { "json_type": "pointer", "type": {"json_type": "lvgl_type", "name": arg_type}}
             },
             "args": [{ # Argument const char* name
                 "name": "name", "json_type": "arg",
                 "type": { "json_type": "pointer", "quals": ["const"], "type": {"json_type": "primitive_type", "name": "char"}}
             }],
             # Synthesize resolved types needed by get_signature
             "_resolved_ret_type": (arg_type, 1, False),
             "_resolved_arg_types": [('char', 1, False)] # Note: Treat const char* as ('char', 1, False)
         })
    logger.info(f"Added {len(managed_creator_names)} managed creators to function list for invocation table.")


    logger.info("Grouping functions by signature...")
    # Pass the set of managed creator names to the signature generator
    #signatures = invocation.generate_invoke_signatures(api_info['functions'], managed_creator_names)
    signatures = invocation.generate_invoke_signatures(api_info['functions'])

    logger.info("Generating invocation helpers...")
    invocation_helpers_c, signature_map = invocation.generate_invocation_helpers(signatures, api_info)

    logger.info("Generating invocation table...")
    # The table now includes entries for lv_widget_create and lv_resource_create_managed
    invocation_table_c = invocation.generate_invoke_table(api_info['functions'], signature_map)
    invocation_table_def = invocation.generate_invoke_table_def()

    logger.info("Generating function lookup...")
    find_function_c = invocation.generate_find_function()

    logger.info("Generating main unmarshaler...")
    main_unmarshaler_c = unmarshal.generate_main_unmarshaler()

    # NOTE: custom_creators_c contains the *implementation* of the managed creators

    logger.info("Generating renderer logic...")
    # Pass the simple map {type_name: managed_creator_func_name}
    renderer_c = renderer.generate_renderer(custom_creators_map_for_renderer)

    # --- Assemble Files ---
    logger.info("Assembling C source file...")
    c_source_content = C_SOURCE_TEMPLATE.format(
        registry_code=registry_c,
        enum_unmarshal_code=enum_unmarshal_c,
        primitive_unmarshal_code=primitive_unmarshal_c,
        custom_unmarshal_code=custom_unmarshal_c,
        invocation_helpers_code=invocation_helpers_c,
        invocation_table_code=invocation_table_c,
        find_function_code=find_function_c,
        main_unmarshaler_code=main_unmarshaler_c,
        custom_creators_code=custom_creators_c, # Implementation from registry.py
        renderer_code=renderer_c,
        invocation_table_def=invocation_table_def
    )

    logger.info("Assembling C header file...")
    c_header_content = C_HEADER_TEMPLATE.format(
        custom_creator_prototypes=custom_creator_prototypes_h
    )

    # --- Write Files ---
    header_path = output_dir / "lvgl_json_renderer.h"
    source_path = output_dir / "lvgl_json_renderer.c"

    try:
        logger.info(f"Writing header file to: {header_path}")
        with open(header_path, "w") as f:
            f.write(c_header_content)

        logger.info(f"Writing source file to: {source_path}")
        with open(source_path, "w") as f:
            f.write(c_source_content)
    except IOError as e:
        logger.error(f"Failed to write output file: {e}")
        return 1

    logger.info("Generation complete.")
    return 0

if __name__ == "__main__":
    exit(main())